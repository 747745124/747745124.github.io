
<!DOCTYPE html>
<html lang="en-us,default" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Point Matching - Voting Tree - Niflheimr</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="A personal website for Naoyuki,Chapter 1: IntroductionPoint Matching Problem:Given two polygons (each is defined by set of points),"> 
    <meta name="author" content="Naoyuki"> 
    <link rel="alternative" href="atom.xml" title="Niflheimr" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="Point Matching - Voting Tree - Niflheimr"/>
    <meta name="twitter:description" content="A personal website for Naoyuki,Chapter 1: IntroductionPoint Matching Problem:Given two polygons (each is defined by set of points),"/>
    
    
    
    
    <meta property="og:site_name" content="Niflheimr"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="Point Matching - Voting Tree - Niflheimr"/>
    <meta property="og:description" content="A personal website for Naoyuki,Chapter 1: IntroductionPoint Matching Problem:Given two polygons (each is defined by set of points),"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Niflheimr</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://naoyuki.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Point Matching - Voting Tree</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">
            Point Matching - Voting Tree
        </h1>
        <div class="stuff">
            <span>
                January 17, 2022
            </span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/DataStructure/" rel="tag">DataStructure</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Point-Matching/" rel="tag">Point Matching</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><h3 id="Point-Matching-Problem"><a href="#Point-Matching-Problem" class="headerlink" title="Point Matching Problem:"></a><strong>Point Matching Problem:</strong></h3><p>Given two polygons (each is defined by set of points), return the <strong>best point matching</strong> between the polygons.</p>
<p>To give you a better idea of what a point matching may be look like, here’s an example:</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<p>You can tell that, the match  (a,p), (b,r), (c,q) is not a good match, because $\angle A \ll \angle P$.</p>
<p>In this case, since $ \triangle ABC \sim \triangle QRP$, so we get a good match {(c,p),(b,r),(a,q)}</p>
<p>But you may ask, <strong>Is that match the best match? What is a best matching mathematically?  What if there’s no mathematically similar polygons?</strong>  Well, these problems can be solved by giving our definition of “Good Match”. Through this case, you may get a sense of what is a good match, that is,  <strong>we can define the how well a match is by the similarity between matching points.</strong></p>
<p>A mathematic description is given as below.</p>
<h3 id="Good-Matching"><a href="#Good-Matching" class="headerlink" title="Good Matching:"></a>Good Matching:</h3><h4 id="Similarity-Function"><a href="#Similarity-Function" class="headerlink" title="Similarity Function:"></a>Similarity Function:</h4><p>Follow the principle that: <strong>Define how well a match is by the similarity between matching points.</strong> We have to firstly define a similarity function between two sets of points.</p>
<p>Referencing the similarity function from: <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/511850"><strong>Zhang Yuefeng. A fuzzy approach to digital image warping. IEEE Computer Graphics and Applications, 1996, 16(6):34~41</strong></a></p>
<p><img src="https://i.loli.net/2021/10/21/vt9GwTJgcPCzl8u.png" alt="image-20211021221008037"></p>
<p>Let’s take a look at the similarity function.</p>
<p>Suppose we have two triangles, edges and angles are denoted as above. The Similarity between these two triangles are defined as above. Note that the Similarity Function has two terms:</p>
<ul>
<li><strong>The Edge similarity term:</strong> measures the similarity with respect to length of edges</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/kqYUpSzE3cO9iBj.png" alt="image-20211021225903082" style="zoom:50%;" />

<ul>
<li><strong>The Angle similarity term:</strong> measures the similarity with respect to angle</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/oBhWea6fQLSIHGq.png" alt="image-20211021230014758" style="zoom:50%;" />

<p>The similarity value is the weighted sum of the two similarity term, by default, we set both weight to 0.5, i.e. $w_1 = 0.5,w_2 = 0.5$.</p>
<p>It’s pretty obvious that, the higher the value is, the higher the similarity is.</p>
<p>$Similarity(T_1,T_2) ==1 \iff T1\triangleq T2$</p>
<h4 id="What-is-a-best-matching"><a href="#What-is-a-best-matching" class="headerlink" title="What is a best matching?"></a>What is a best matching?</h4><p>Now we know that, what means a good matching between two triangles.</p>
<p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y)), where\ X.size== Y.size==3)$</p>
<p><strong>Note that, the higher the similarity function value, the better the matching is.</strong>  In this way, to find out the best triangle matching, we only have to find out two ordered sets of point pairs (with a size of 3), which have the highest similarity function value. And such pair is the best matching by our definition.</p>
<p>Actually, we can extend this Similarity Function to polygons with more than 3 edges.</p>
<h4 id="Best-matching-mathematically"><a href="#Best-matching-mathematically" class="headerlink" title="Best matching, mathematically"></a>Best matching, mathematically</h4><p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y))$</p>
<p>$where\ X.size== Y.size==min(A.size(),B.size())$</p>
<p>The Similarity of between 2 size n sets match is defined as below:</p>
<img src="https://i.loli.net/2021/10/22/nuXArDg2wFjoEYT.png" alt="image-20211022000404251" style="zoom:50%;" />

<p>Which is simply the <mark>average of all correspoding triangles’ similarity.</mark> (T means Triangle)</p>
<h4 id="Match-Representation-Tree"><a href="#Match-Representation-Tree" class="headerlink" title="Match Representation: Tree"></a>Match Representation: Tree</h4><p>To find out the best possible match, we have to traverse all possible match sequence, but how do we represent an ordered match between two sets of points?  The answer is tree.</p>
<p>We use a tree node, formed by a point pair to denote a possible match. So a possible node is <code>(a,p)</code>, and there’s <code>m*n</code> (<code>m = setA.size()</code>, <code>n = setB.size()</code>) possible nodes in total. And the children of node <code>(a,p)</code> should be next possible match, in this case, if we only take clockwise move into account, the next possible match is either <code>(c,r)</code> or <code>(c,o)</code>.</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<h5 id="You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule"><a href="#You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule" class="headerlink" title="You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule."></a>You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule.</h5><h4 id="Yet-another-important-rule-Monotonous"><a href="#Yet-another-important-rule-Monotonous" class="headerlink" title="Yet another important rule: Monotonous"></a>Yet another important rule: Monotonous</h4><p>The word <strong>monotonus</strong>, in this context, meaning moving in the same direction from begining to the end. This means that, you can’t go from r to q (clockwise), and then go from q to o (counter-clockwise). Think about it, a matching subsequence <code>(c,r)(b,q)(a,o)</code> breaks the rule of monotonicity. If you connect $RQ$ and $QO$, you will find that $RQ$ overlaps with $QO$.</p>
<p>In fact, you will find out that generally, if a set of points is not connected in a monotonous order (in the same direction), overlapping and crossing edge could happen.</p>
<img src="https://s2.loli.net/2022/01/17/2YjmF46IlrqugKx.png" alt="PNG图像" style="zoom:50%;" />

<p>So inorder to conform to the monotonous rule, the point matching should be move in a certain and unchanged direction, either clock-wise or counter clockwise.<mark> For simplicity, we assume both of the polygons moves clockwise.</mark> <strong>( This leaves a problem in the case of mirrored polygon matching, because in mirrored polygons, two polygons are connected in different direction )</strong> </p>
<p>Although we can simply don’t take mirrored polygons into account, an intuitive concept solution is given at the end of the report.</p>
<p>Since we only allow clockwise moves, <code>(a,p)(c,q)</code> is not a valid match sequence. </p>
<h4 id="How-many-starting-node"><a href="#How-many-starting-node" class="headerlink" title="How many starting node?"></a>How many starting node?</h4><p>On first thought, you may assume that there’s <code>m*n</code> (<code>m = setA.size(), n = setB.size()</code>)  starting point. However, <strong>the nodes in the triangle are logically equivalent.</strong> In the example, setA has a fewer size of 3, which means in next possible match, the first polygon can only move one step clockwise. And you may already find that, once the starting point of polygon A is fixed, the possible match sequence of A is fixed. However, there’s 4 different possibilities of polygon B with a fixed starting point.</p>
<p>So in this case, <strong>we actually have max(m,n) staring nodes</strong>. And for simplicity, we assume that the polygon A always starts at point A.</p>
<h4 id="Sample-Case-Tree"><a href="#Sample-Case-Tree" class="headerlink" title="Sample Case Tree:"></a>Sample Case Tree:</h4><p>With all that being said, all possible match sequences in the sample case are show as tree below.</p>
<p><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2"></p>
<p>Now we may came up with different methods to find out the best matching, in this representation, <mark><strong>the highest average (or cumulative) similarity path from root to leaf</strong>. </mark>But firstly let me simply introduce some other related works.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Firstly give the number of indicies in each polygon, m and n. Then for next m+n line, each line is consist of x and y coordinate of the index (m first then n) . <strong>The points in each polygon are given in clockwise order, and indexed as 1、2、3…n</strong>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Return the best match in the form of (index1,index2) for m lines (suppose m&lt;n)</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#still the same sample, where line 1-4 are m1~m3, line 5-8 are n1~n4.</span></span><br><span class="line"><span class="comment">#the output (1,2)(2,3)(3,4) means m1 matches n2, m2 matches n3, m3 matches n4</span></span><br><span class="line"><span class="built_in">input</span>:</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">4.25</span> <span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line">output:</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Related-Problems-and-Algorithms"><a href="#Related-Problems-and-Algorithms" class="headerlink" title="Related Problems and Algorithms:"></a>Related Problems and Algorithms:</h3><p>In general, this is a 2D point set registration problem,  is the process of finding a spatial <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mathematical_transformation">transformation</a> (<em>e.g.,</em> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scaling_(geometry)">scaling</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rotation">rotation</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Translation_(geometry)">translation</a>) that aligns two <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point_cloud">point clouds</a>. </p>
<p>Many different methods have been proposed to solve this problem, from Graph theory, machine learning, and each of them have a different cost function to achieve, in this case, the similarity function.</p>
<h4 id="For-other-algorithms-on-this-problem-Click-for-more"><a href="#For-other-algorithms-on-this-problem-Click-for-more" class="headerlink" title="For other algorithms on this problem (Click for more):"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point_set_registration#Correspondence-based_registration">For other algorithms on this problem (Click for more):</a></h4><ul>
<li>Iterative Closet Point</li>
<li>RANSAC</li>
<li>Fuzzy Graph Matching</li>
</ul>
<h3 id="Build-Environment-amp-To-Run"><a href="#Build-Environment-amp-To-Run" class="headerlink" title="Build Environment &amp; To Run:"></a>Build Environment &amp; To Run:</h3><p>See <a href="./code/README.md">./code/README.md</a><br>Recommend to open with Typora.</p>
<h3 id="Brief-Description-On-STL-Used"><a href="#Brief-Description-On-STL-Used" class="headerlink" title="Brief Description On STL Used"></a>Brief Description On STL Used</h3><ul>
<li>std::vector<ul>
<li>std::vector is a sequence container for <mark>dynamic size array</mark>.</li>
<li>Elements in vector can be accessed by [] operator, iterators, and offsets to pointers to elements.</li>
<li>The storage of vector is handled automatically, and usually extra memory is allocated for the growth of the vector.</li>
<li>Each time we insert a element to the vector, as long as the extra memory isn’t exhausted, we don’t need to reallocate memory (memory reallocation is expensive).</li>
<li>Time Complexity:<ul>
<li>Random Access: $O(1)$</li>
<li>Insertion or Remove at the end:$O(1)$</li>
<li>Insertion or Remove at the front: $O(n)$</li>
</ul>
</li>
</ul>
</li>
<li><code>std::function</code><ul>
<li><code>std::function</code> is a general wrapper for function, it can store any copyconstructible callable object.</li>
<li>Can be used to store lambda expressions, member functions etc.</li>
<li>One usage is to pass function to function (Like function pointers).<ul>
<li>It has no call overhead</li>
<li>It can capture context variables</li>
</ul>
</li>
</ul>
</li>
<li><code>std::pair</code><ul>
<li>This is used to store 2 different objects in a single unit.</li>
<li>Can be replaced by struct, but std::pair offers a easier way to do so.</li>
<li>To assign value a and b to a <code>pair&lt;int,int&gt;</code><ul>
<li><code>Pair = make_pair(a,b)</code>;</li>
</ul>
</li>
</ul>
</li>
<li><code>std::map</code> (Actually can be replaced by set or vector)<ul>
<li><p>This structure is used to store a key-&gt;value pair</p>
</li>
<li><p>The implementation of Red-Black tree ensures a key-sorted traversal order.</p>
</li>
<li><p>It is implemented by <strong>Red-black tree</strong></p>
<ul>
<li>Search:$O(log(n))$</li>
<li>Insert:$O(log(n))$</li>
<li>Space Complexity:$(O(n))$</li>
</ul>
</li>
<li><p>The basic properties of a red black tree</p>
<ul>
<li>It’s a <strong>self-balanced binary search tree</strong></li>
<li>Each node is either red or black</li>
<li>Root is black</li>
<li>external nodes are black</li>
<li>the children of a red node is black</li>
<li>Any path from external node to root, the number of black nodes along the path are the same.</li>
</ul>
<h4 id="A-sample-red-black-tree"><a href="#A-sample-red-black-tree" class="headerlink" title="A sample red-black tree"></a>A sample red-black tree</h4><img src="https://s2.loli.net/2022/01/17/mrOg85bEWHSvKIN.png" alt="image-20211028155810975" style="zoom:50%;" /></li>
</ul>
</li>
<li><code>std::chrono</code><ul>
<li>This library is used for tracking time with different type of precision.</li>
<li>An massive extension to the time.h</li>
<li><strong>system_clock</strong> offers a wall clock</li>
<li><strong>high_resolution_clock</strong> offers a clock with shortest tick period.</li>
<li><strong>duration</strong> to represent a interval of time.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-2-Algorithm-Specification-Description"><a href="#Chapter-2-Algorithm-Specification-Description" class="headerlink" title="Chapter 2:    Algorithm Specification Description"></a>Chapter 2:    Algorithm Specification Description</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h3><h4 id="Voting-Tree-Idea"><a href="#Voting-Tree-Idea" class="headerlink" title="Voting Tree Idea:"></a>Voting Tree Idea:</h4><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2" style="zoom:50%;" />

<p>Now we can introduce the idea of voting tree. Basically a voting tree is <strong>for each unique path from root to the leaf, if the node is present in the path, the point match presented by this node gets a vote</strong>. The higher votes a match get, the more likely this match could be true. For the tree above, $AP$  have 3 votes, $AR$ have 3 votes too, so does $AO$ …</p>
<p>Soon you will find that for this tree, each match have exactly 3 votes. We can’t get any information out of the tree. This is obvious becuase we haven’t use the point pair information stored at each node. We’re just doing arrangement and combinations now.</p>
<h4 id="Why-Pruning"><a href="#Why-Pruning" class="headerlink" title="Why Pruning?"></a>Why Pruning?</h4><p>If we don’t prune the tree (cut off some branches), the voting process can’t give us any useful information. So we have to prune the tree in advance, based on our similarity function. My prune idea is simple, compute the similarity between two triangles, formed by node, node-&gt;parent, node-&gt;child. If the similarity is above a certain threshold, meaning this tree extension could be valid, else, this tree extension is invalid.</p>
<h4 id="Prune-First-Round"><a href="#Prune-First-Round" class="headerlink" title="Prune: First Round"></a>Prune: First Round</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traverse from root to leaf</span><br><span class="line">    for each node(node.depth&gt;=2)</span><br><span class="line">		for each node.child</span><br><span class="line">		//means not similar enough</span><br><span class="line">    		if(similar(node.parent,node,node.children)&lt;threshold)</span><br><span class="line">    			invalidate(node.children)</span><br><span class="line">    			go deeper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>First round pruning under a high threshold, we only invalidate those nodes(depth&gt;=2)’ children.</p>
<p>In the best case, all nodes(depth&gt;=3) except the best matching has been invalidated.</p>
</blockquote>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%203.png" alt="PNG图像 3" style="zoom:50%;" />

<p><strong>Note that this is actually a greedy algorithm pruning, for each time we only consider the local similarity. And we only leave those branches with high similarity.</strong></p>
<h4 id="Prune-Second-Round"><a href="#Prune-Second-Round" class="headerlink" title="Prune: Second Round"></a>Prune: Second Round</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traverse from depth 2 leaves to root:</span><br><span class="line">	if(node has no valid children)</span><br><span class="line">		invalidate(node)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This is intuitive since if a node(non-leaf) doesn’t have valid children, meaning the match itself is also invalid. In best case, there is only one valid path from root to leaf.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/nDSgJsMRoz5TZaI.png" alt="PNG图像 4" style="zoom:50%;" />

<p>After the pruning, it’s obvious that, the path present yields a higher chance of best matching, so the tree can be used to vote. <strong>However, this algorithm relies heavily on the threshold, if the threshold is set low, it could produce wrong result, if set overly high, there could be no possible match.</strong> (Test on Part 3)</p>
<h4 id="Trivia"><a href="#Trivia" class="headerlink" title="Trivia:"></a>Trivia:</h4><p>We have 2 similar but slightly different ways to determine the best match after voting to get the 2  bonus points.</p>
<h3 id="How-to-Vote"><a href="#How-to-Vote" class="headerlink" title="How to Vote?"></a>How to Vote?</h3><p>The vote process is a little bit tricky, different nodes have different vote counts. Some of the nodes may appear many times in different unique paths, but many nodes (mostly leaf nodes) only appear once in unique path. If we implement the idea of “unique path”, we have to visit some node many times, this requires backtracking technique. <strong>If we calculate the vote counts of node in advance, we only need to visit each node once,</strong> and that is simple to achieve by level order traversal.</p>
<blockquote>
<p>Leaf node has exactly one vote count, and a non-leaf node.voteCount = sum(children.voteCount)</p>
<p>We have to compute from leaf to root.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/V4ocwS36LkT8dZj.png" alt="PNG图像 6" style="zoom:50%;" />

<blockquote>
<p>After computing vote counts, we just traverse the tree, and vote for the matching, we keep a voting table. Table[node]+=node.voteCount</p>
<p>A Voting Table corresponding to the unpruned tree above.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/zWFoClXGudq4Q6L.png" alt="PNG图像 7" style="zoom: 50%;" />



<h3 id="How-to-decide-the-match-out-of-Voting-Table"><a href="#How-to-decide-the-match-out-of-Voting-Table" class="headerlink" title="How to decide the match out of Voting Table?"></a>How to decide the match out of Voting Table?</h3><p><strong>(Bonus is to have 2 different method determine the match)</strong></p>
<h4 id="Simple-Idea-Get-the-first-m-most-votes"><a href="#Simple-Idea-Get-the-first-m-most-votes" class="headerlink" title="Simple Idea:  Get the first m-most votes"></a>Simple Idea:  Get the first m-most votes</h4><blockquote>
<p>To use this method, #define _VOTE_ORDER</p>
</blockquote>
<p>Suppose we have a voting table like this, we have to decide the best match out of the table, we just order them by votes. The result would be <code>(a,q)(c,o)(c,r)</code>.</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%205.png" alt="PNG图像 5" style="zoom:50%;" />

<p>c appears twice in a matching sequence, so this simple idea is sometimes problematic for collision<code>(c,o)</code>and <code>(c,r)</code>, although this isn’t very likely to happen with a properly set threshold.</p>
<h4 id="An-Improved-Idea-for-anti-collision-Vote-By-Row"><a href="#An-Improved-Idea-for-anti-collision-Vote-By-Row" class="headerlink" title="An Improved Idea for anti-collision: Vote By Row"></a>An Improved Idea for anti-collision: Vote By Row</h4><blockquote>
<p>To use this method, #define _ROW_ORDER</p>
</blockquote>
<p>Instead of finding the global max votes, we find out most vote in each row, and in order to avoid collision on a column, after finding the most vote in the row, we set all votes in that column to 0.</p>
<img src="https://i.loli.net/2021/10/22/pZxH7veXsnEOjb9.png" alt="PNG图像 8" style="zoom:50%;" />

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h2><h3 id="Tree-Design"><a href="#Tree-Design" class="headerlink" title="Tree Design:"></a>Tree Design:</h3><p>Now we have to design our tree for implementation. Let’s think about what we need to keep in our tree.</p>
<ul>
<li><p>PointPairs (Storing 2 points’ coordinates)</p>
</li>
<li><p>Indices (2 points’ indices in their polygon)</p>
</li>
<li><p>Depth (In pruning, we have to check whether if a node is of depth 2 or deeper )</p>
</li>
<li><p>Count (Storing the vote count)</p>
</li>
<li><p>isValid (Check if this node need to be pruned or not, check if it is a valid match)</p>
</li>
<li><p>Children (Storing all of it’s children’s address)</p>
</li>
<li><p>Parent (When doing similarity function, we have to pass 3 adjacent nodes, it comes handy if we just pass node, node-&gt;parent, node-&gt;children)</p>
</li>
<li><p>Credit (How many possibilities this node can move, further explanation below)</p>
<blockquote>
<p>Credit indicates how many possibilities a node can move, if a node’s children moves one step, it cost no credit, if more than one step, it cost n-1 credits. The number of credits also indicates the number of children a node can have. </p>
<p>If a node has no credit, it can only move one step further thus have one child. Otherwise, it can move 1<del>n+1 steps, costing 0</del>n credits, thus having n+1 children.</p>
<p>An illustration is below to show the idea of credit.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/wVucOXPY7WM5vek.png" alt="PNG图像 9" style="zoom:50%;" /></li>
</ul>
<p>With credit, you can easily figure out how many children each node can have.</p>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode:"></a>TreeNode:</h3><p>This is all information tree node CR, contains (before pruning).</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%2010.png" alt="PNG图像 10" style="zoom:50%;" />

<h3 id="Build-Tree-with-pruning"><a href="#Build-Tree-with-pruning" class="headerlink" title="Build Tree with pruning"></a>Build Tree with pruning</h3><p>Now we know that what a tree node is, we have to build the tree.</p>
<p>To get cut down time complexity, we can do pruning while building the tree.</p>
<blockquote>
<p>Assume m&lt;n, if not, swap them.</p>
</blockquote>
<ol>
<li><p>Firstly, we build the depth 1 nodes (initial match), given with n-m credits each.</p>
</li>
<li><p>For each depth 1 nodes we recursively build subtree by using helper function.</p>
</li>
<li><p>In the helper function, we pass in a node</p>
<ol>
<li>if the node reaches depth m, means a full match, return</li>
<li>if the node has no credit, means it can only move 1 step further, move, check similarity, if valid then extend and return, if not, don’t extend and return.</li>
<li>if the node has some credits, means it can have credits+1 children, for each children, check similarity, if valid, extend, and pass children to the helper function for recursive call. if not valid, don’t extend, check the next children.</li>
</ol>
</li>
</ol>
<h3 id="Futher-Pruning-Second-Round"><a href="#Futher-Pruning-Second-Round" class="headerlink" title="Futher Pruning (Second Round)"></a>Futher Pruning (Second Round)</h3><p>A top-down approach.</p>
<ol>
<li>Pass the node, if it has a valid children, it is valid. If not, set node.isValid to false, return.</li>
<li>For each children of the node, if it has a valid children, it’s valid. If it doesn’t have children and is depth&lt;m , meaning its children have been pruned while build tree, set node.isValid to false, return.</li>
<li>Recursively call this function step 1~2</li>
</ol>
<h3 id="Level-Order-Traversal"><a href="#Level-Order-Traversal" class="headerlink" title="Level Order Traversal"></a>Level Order Traversal</h3><p>To compute vote count bottom up, it would be convenient if we do level order traversal first.</p>
<p>We implement level order by 2 vectors, curr and next, indicating the nodes to process in this level and next level. We store the result in res vector. (<code>vector&lt;vector&lt;TreeNode*&gt;&gt;</code>)</p>
<ol>
<li>Push root node into curr</li>
<li>While(curr is not empty), push curr to res, traverse all nodes in curr, for each node, we push all its children to next, finally swap(curr,next).</li>
</ol>
<h3 id="Compute-Vote-Count"><a href="#Compute-Vote-Count" class="headerlink" title="Compute Vote Count"></a>Compute Vote Count</h3><ol>
<li>get level order traversal result</li>
<li>start from the last level if it’s valid it has 1 vote count.</li>
<li>For each level, it’s vote count equals to sum of its valid children’s vote count. Iteration ends at depth 1 (Don’t consider root)</li>
</ol>
<h3 id="Voting"><a href="#Voting" class="headerlink" title="Voting:"></a>Voting:</h3><ol>
<li>traverse the tree by level order</li>
<li>The corresponding <code>term +=voteCount</code><ol>
<li>RowOrder: For each row in the table, find the max, set column of max to zero</li>
<li>SimpleIdea: Find the m-most votes in the table.</li>
</ol>
</li>
</ol>
<h2 id="Solution-2-Non-Voting"><a href="#Solution-2-Non-Voting" class="headerlink" title="Solution 2: Non-Voting"></a>Solution 2: Non-Voting</h2><p>Because we apply greedy pruning to our tree, sometimes we may only get the local best match instead of global best. Remeber that, in chapter 1, our goal is to find a path from root to leaf,<mark> with a largest average similarity of corresponding triangles.</mark></p>
<p>In this method, we simply don’t prune, and while we building tree, we keep track of the cumulative similarities of corresponding triangles. <mark>And we get the global best by simply find out the leaf node which havethe largest cumulative similarity.</mark></p>
<p><strong>This method is not reliant on parameters, and ensures a global best match under our definition.</strong></p>
<h4 id="TreeNode-add-a-cumulativeSim-member"><a href="#TreeNode-add-a-cumulativeSim-member" class="headerlink" title="TreeNode: add a cumulativeSim member"></a>TreeNode: add a cumulativeSim member</h4><h4 id="BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity"><a href="#BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity" class="headerlink" title="BuildTree: Almost the same, without pruning, keep track of cumulative similarity"></a>BuildTree: Almost the same, without pruning, keep track of cumulative similarity</h4><h4 id="Further-Pruning-No-need"><a href="#Further-Pruning-No-need" class="headerlink" title="Further Pruning: No need"></a>Further Pruning: No need</h4><h4 id="Level-Order-Traversal-Same"><a href="#Level-Order-Traversal-Same" class="headerlink" title="Level Order Traversal: Same"></a>Level Order Traversal: Same</h4><h4 id="Get-Result"><a href="#Get-Result" class="headerlink" title="Get Result:"></a>Get Result:</h4><ol>
<li>For the last level of the level order traversal (which is actually all the leaf nodes):</li>
<li>Get the node with max cumulative similarity</li>
<li>Trace back this node until root.</li>
</ol>
<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><h3 id="Correctness-Validation-With-A-Strict-Threshold-0-9"><a href="#Correctness-Validation-With-A-Strict-Threshold-0-9" class="headerlink" title="Correctness Validation: With A Strict Threshold = 0.9"></a>Correctness Validation: With A Strict Threshold = 0.9</h3><h4 id="Case-1-Sample-Case"><a href="#Case-1-Sample-Case" class="headerlink" title="Case 1: Sample Case"></a>Case 1: Sample Case</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct"><a href="#ROW-ORDER-Correct" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/Wf4mdv6nYpXGLij.png" alt="image-20211023011656249"></p>
<h4 id="SIMPLE-IDEA-Correct"><a href="#SIMPLE-IDEA-Correct" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/hA8qgKXZjfJe27M.png" alt="image-20211023011856088"></p>
<h4 id="NON-VOTING-Correct"><a href="#NON-VOTING-Correct" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/yMLWOv2CGYBoT3w.png" alt="image-20211023011927482"></p>
<h4 id="Case-2-A-1x1-square-and-a-2x2-square"><a href="#Case-2-A-1x1-square-and-a-2x2-square" class="headerlink" title="Case 2: A 1x1 square and a 2x2 square"></a>Case 2: A 1x1 square and a 2x2 square</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-1"><a href="#ROW-ORDER-Correct-1" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/mw7N2y5vsAK4eXc.png" alt="image-20211023012132695"></p>
<h4 id="SIMPLE-IDEA-Wrong"><a href="#SIMPLE-IDEA-Wrong" class="headerlink" title="SIMPLE_IDEA: Wrong"></a>SIMPLE_IDEA: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/wVcTFonM4X6j3qC.png" alt="image-20211023012203375"></p>
<h4 id="NON-VOTING-Correct-1"><a href="#NON-VOTING-Correct-1" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/3YBdRvUhf8HNZe4.png" alt="image-20211023012224618"></p>
<h4 id="Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon"><a href="#Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon" class="headerlink" title="Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon"></a>Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-2"><a href="#ROW-ORDER-Correct-2" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="/Users/naoyuki/Library/Application%20Support/typora-user-images/image-20211023012422694.png" alt="image-20211023012422694"></p>
<h4 id="SIMPLE-IDEA-Correct-1"><a href="#SIMPLE-IDEA-Correct-1" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/msa17Due6tYdSJC.png" alt="image-20211023012443966"></p>
<h4 id="NON-VOTING-Correct-2"><a href="#NON-VOTING-Correct-2" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/ydZE2seXj1QNM9g.png" alt="image-20211023012508740"></p>
<h4 id="Case-4-Large-Number-M-21-N-28-performance-test"><a href="#Case-4-Large-Number-M-21-N-28-performance-test" class="headerlink" title="Case 4: Large Number(M=21,N=28), performance test"></a>Case 4: Large Number(M=21,N=28), performance test</h4><h4 id="ROW-ORDER-0-005-sec"><a href="#ROW-ORDER-0-005-sec" class="headerlink" title="ROW_ORDER: 0.005 sec"></a>ROW_ORDER: 0.005 sec</h4><h4 id="SIMPLE-IDEA-0-005-sec"><a href="#SIMPLE-IDEA-0-005-sec" class="headerlink" title="SIMPLE_IDEA: 0.005 sec"></a>SIMPLE_IDEA: 0.005 sec</h4><h4 id="NON-VOTING-7-81-sec"><a href="#NON-VOTING-7-81-sec" class="headerlink" title="NON_VOTING: 7.81 sec"></a>NON_VOTING: 7.81 sec</h4><h4 id="Case-5-Mirror-case"><a href="#Case-5-Mirror-case" class="headerlink" title="Case 5: Mirror case"></a>Case 5: Mirror case</h4><p>Test if the algorithm can get the best match if two polygons are mirrored to each other.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Not-Found"><a href="#ROW-ORDER-Not-Found" class="headerlink" title="ROW_ORDER: Not Found"></a>ROW_ORDER: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013827652"></p>
<h4 id="SIMPLE-IDEA-Not-Found"><a href="#SIMPLE-IDEA-Not-Found" class="headerlink" title="SIMPLE_IDEA: Not Found"></a>SIMPLE_IDEA: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013829051"></p>
<h4 id="NON-VOTING-Wrong"><a href="#NON-VOTING-Wrong" class="headerlink" title="NON_VOTING: Wrong"></a>NON_VOTING: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/JzEHr6eXlLbQok7.png" alt="image-20211023013749859"></p>
<p>A solution will be proposed in chapter 4.</p>
<h4 id="Correctness-Table-For-5-test-cases"><a href="#Correctness-Table-For-5-test-cases" class="headerlink" title="Correctness Table (For 5 test cases)"></a>Correctness Table (For 5 test cases)</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<h3 id="Hacking-Cases-During-Peer-Review"><a href="#Hacking-Cases-During-Peer-Review" class="headerlink" title="Hacking Cases During Peer Review"></a>Hacking Cases During Peer Review</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 11</span><br><span class="line">A:(-4,2)(-2,2)(-2,4)(-4,4)</span><br><span class="line">B:(-2 -2)(-1 -2)(-1 -1)(2 2)(4 1)(5 3)(3 4)(3 6)(1 6)(1 4)(-2 -1)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 9</span><br><span class="line">(2 -4) (4 -4)(6 -2)(4 0)(2 0)</span><br><span class="line">(-5 5)(-8 2)(-8 -1)(-6 -1)(-6 -4)(-4 -4)(-4 -1)(-2 -1)(-2 2)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<blockquote>
<h3 id="Major-Problem"><a href="#Major-Problem" class="headerlink" title="Major Problem:"></a>Major Problem:</h3><ul>
<li>The NON_VOTING Method has a comparatively high correctness rate, but the problem is that, it has a high time complexity, which makes it very hard to handle large cases（Acceptable M,N&lt;25）.</li>
<li>The other 2 solutions has a somewhat simple and fast performance, but not that good in the correctness.</li>
</ul>
</blockquote>
<h3 id="Parameters-Test"><a href="#Parameters-Test" class="headerlink" title="Parameters Test:"></a>Parameters Test:</h3><p>Only run sample cases, set threshold differently.</p>
<ul>
<li>Threshold: 0.1<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.3<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.5<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.75<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.9<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Correct</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
</ul>
<p>A good general threshold would be around 0.8~0.9.</p>
<h4 id="Correctness-Table-For-5-thresholds"><a href="#Correctness-Table-For-5-thresholds" class="headerlink" title="Correctness Table: For 5 thresholds"></a>Correctness Table: For 5 thresholds</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
<th>Threshold</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.1</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.3</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.5</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>0.75</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>0.9</td>
</tr>
</tbody></table>
<h3 id="Extra-Comparison-with-Iterative-Closet-Points"><a href="#Extra-Comparison-with-Iterative-Closet-Points" class="headerlink" title="Extra Comparison with Iterative Closet Points:"></a>Extra Comparison with Iterative Closet Points:</h3><p>I tried with Python, using sklearn package to run this method. Using a 2 sets of 30 points. Find one number of pair. Feed the same data with voting tree, it can’t find a full match and thus return.</p>
<blockquote>
<p>The voting tree assumes a good matching with average similarity&gt;=threshold because our pruning.</p>
<p>The non_voting method, on the other hand, returns the best matching possible, though it can be lower than the threshold.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/eTJsu3D2RjxgPdm.png" alt="image-20211023014901237" style="zoom:50%;" />

<p>On a small set of data (e.g. the sample case), the ICP solution can’t converge due to small amount of set size. However, if provided with a reasonable similar point set with a medium size (say, over 30). ICP method is reliable.</p>
<p>Besides, ICP has another strength is that, it can return partial matching, when there’s not a full match, it will return a partial match instead.</p>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4:    Analysis and Comments"></a>Chapter 4:    Analysis and Comments</h2><h3 id="1-Build-Tree"><a href="#1-Build-Tree" class="headerlink" title="1.Build Tree:"></a>1.Build Tree:</h3><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ol>
<li>Build depth 1 children takes O(n) time, there are n nodes at depth 1.</li>
<li>Using build helper to recursively build subtree takes $ O(n*T_{helper}(X))$</li>
</ol>
<p>Since each node only takes O(1) to insert, the overall build tree time complexity equals to the number of nodes.</p>
<h4 id="The-number-of-nodes-are"><a href="#The-number-of-nodes-are" class="headerlink" title="The number of nodes are:"></a>The number of nodes are:</h4><p>$n<em>A^m_m = n</em>m!$</p>
<h4 id="Overall-Time-Complexity-Without-Pruning-O-n-m"><a href="#Overall-Time-Complexity-Without-Pruning-O-n-m" class="headerlink" title="Overall Time Complexity (Without Pruning): $O(n*m!)$"></a>Overall Time Complexity (Without Pruning): $O(n*m!)$</h4><blockquote>
<p>Actually <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The time complexity can be reduced to $O(n^2)$ , since there are  n*(n-m+1) nodes at depth 2 without pruning.</mark></p>
</blockquote>
<h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><p>The Space Complexity = RecursionDepth*Recursion_assisted_space + size of tree.</p>
<ul>
<li>Recursion Term: Recursion Depth = m (match at most m times)</li>
<li>$tree_size= n<em>m!</em>(node_size) = n*m!<em>O(n-m) = O(n^2</em>m!)$</li>
</ul>
<h4 id="Overall-Space-Complexity-Without-Pruning-O-n-2-m"><a href="#Overall-Space-Complexity-Without-Pruning-O-n-2-m" class="headerlink" title="Overall Space Complexity (Without Pruning): $O(n^2*m!)$"></a>Overall Space Complexity (Without Pruning): $O(n^2*m!)$</h4><blockquote>
<p>Samely <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The space complexity can be reduced to $O(n^3)$ , since there are $ n*(n-m+1)$ nodes at depth 2 without pruning. And each takes up to $O(n-m)$ space since it stores its children.</mark></p>
</blockquote>
<h3 id="2-Futher-Pruning"><a href="#2-Futher-Pruning" class="headerlink" title="2.Futher Pruning:"></a>2.Futher Pruning:</h3><h4 id="Time-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Time-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Time Complexity (With rigorous pruning while build tree):"></a>Time Complexity (With rigorous pruning while build tree):</h4><ol>
<li>In this step, we at most prune almost all nodes at depth 2 and some at depth 1, since if we use build-time pruning at step 1, most of nodes will not grow deeper than depth 2.</li>
<li>For each node, we check its children (n-m at most)  if its valid or not. And set isValid accordingly. </li>
</ol>
<ul>
<li>Number of check &lt;=$ (depth 1 +depth 2)<em>(n-m) = (n+n</em>(n-m+1))*(n-m) = $O(n^3)$</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-3"><a href="#Overall-Time-Complexity-O-n-3" class="headerlink" title="Overall Time Complexity: $O(n^3)$"></a>Overall Time Complexity: $O(n^3)$</h4><blockquote>
<p>If not doing a rigorous pruning step while building, it takes nearly <strong>O(n*m!)</strong> to do the pruning</p>
</blockquote>
<h4 id="Space-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Space-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Space Complexity (With rigorous pruning while build tree):"></a>Space Complexity (With rigorous pruning while build tree):</h4><ul>
<li>This step doesn’t need extra space for memoization. However, it takes space for recursion. The space complexity equals to the max depth of the recursion, which is $O(m)$, since we the most depth is no deeper than 2 because of build-time pruning, except the best match path, takes $O(m)$ space for recursion.</li>
</ul>
<blockquote>
<p>If not doing a rigorous pruning step while building, it still takes <strong>O(m)</strong> to do the pruning, since the max depth is still $O(m)$</p>
</blockquote>
<h4 id="Overall-Space-Complexity-O-m"><a href="#Overall-Space-Complexity-O-m" class="headerlink" title="Overall Space Complexity: $O(m)$"></a>Overall Space Complexity: $O(m)$</h4><h3 id="3-Level-Order-Traversal"><a href="#3-Level-Order-Traversal" class="headerlink" title="3.Level Order Traversal"></a>3.Level Order Traversal</h3><h4 id="Time-Complexity-With-rigorous-pruning"><a href="#Time-Complexity-With-rigorous-pruning" class="headerlink" title="Time Complexity (With rigorous pruning):"></a>Time Complexity (With rigorous pruning):</h4><ul>
<li>Level Order traversal visit each node only once, which takes O(1) time, there are O(n^2) nodes if pruned rigorously.</li>
<li>If not pruned rigorously, in worst case, it could produce a result of O(n*m!)</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m"><a href="#Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m" class="headerlink" title="Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$"></a>Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$</h4><h4 id="Space-Complexity-With-rigorous-pruning"><a href="#Space-Complexity-With-rigorous-pruning" class="headerlink" title="Space Complexity (With rigorous pruning):"></a>Space Complexity (With rigorous pruning):</h4><ul>
<li>Level Order Traversal stores each node, each takes up to O(n) space.</li>
</ul>
<h4 id="Overall-Space-Complexity-O-n-2-O-n-m"><a href="#Overall-Space-Complexity-O-n-2-O-n-m" class="headerlink" title="Overall Space Complexity:  $(O(n^2),O(n*m!))$"></a>Overall Space Complexity:  $(O(n^2),O(n*m!))$</h4><h3 id="4-Compute-Vote-Count"><a href="#4-Compute-Vote-Count" class="headerlink" title="4.Compute Vote Count"></a>4.Compute Vote Count</h3><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>This is similar to pruning step. We only compute those valid nodes, and check their children.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$"></a>Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$</h4><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>Space takes for recursion is the same as pruning step</li>
</ul>
<h4 id="Overall-Space-Complexity-O-m-1"><a href="#Overall-Space-Complexity-O-m-1" class="headerlink" title="Overall Space Complexity : $O(m)$"></a>Overall Space Complexity : $O(m)$</h4><h3 id="5-Voting"><a href="#5-Voting" class="headerlink" title="5.Voting"></a>5.Voting</h3><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>Once again, we traverse the tree, and each time we vote to either a map or 2D array.</li>
<li>There are up to $O(n*m!)$ nodes if not well pruned, but at least O(m) nodes.</li>
<li>If we uses a <code>std::map</code> for voting, this takes $O(log(n))$ time for insert, while 2D array only takes $O(1)$</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$"></a>Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$</h4><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>We keeps either a map or 2D array, the overall space is up to all possible pairs, which is <strong>n*m</strong>, <strong>but at least m</strong>, which means only one valid path after pruning.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m"><a href="#Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m" class="headerlink" title="Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$"></a>Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$</h4><h3 id="6-Decide-Match-Voting"><a href="#6-Decide-Match-Voting" class="headerlink" title="6.Decide Match (Voting)"></a>6.Decide Match (Voting)</h3><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>SIMPLE_IDEA searches the largest m element in the table, if use sorting, this could takes, O(nlogn) times where n is the number of nodes.</li>
<li>ROW_ORDER searches the largest element in each line, which takes O(n*m) times, since there’re n rows and m columns.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m"><a href="#Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m" class="headerlink" title="Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$"></a>Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$</h4><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps we use a vector to assist our 2D sorting. Which takes up to O(m) space.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-m"><a href="#Overall-Time-Complexity-O-m" class="headerlink" title="Overall Time Complexity : $O(m)$"></a>Overall Time Complexity : $O(m)$</h4><h3 id="7-Decide-Match-Non-Voting"><a href="#7-Decide-Match-Non-Voting" class="headerlink" title="7.Decide Match (Non Voting)"></a>7.Decide Match (Non Voting)</h3><h4 id="Time-Complexity-4"><a href="#Time-Complexity-4" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>We only visit leaf nodes and find out the node with maximum cumulative similarity.</li>
<li>And then we trace back to root from that node.</li>
<li>There are at most $(n*m!)$ leaf nodes at depth m, since we don’t prune in a non-voting method. Trace back only takes O(m) time.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-m"><a href="#Overall-Time-Complexity-O-n-m" class="headerlink" title="Overall Time Complexity: $O(n*m!)$"></a>Overall Time Complexity: $O(n*m!)$</h4><h4 id="Space-Complexity-4"><a href="#Space-Complexity-4" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps only takes constant space for storing the maximum cumulative similarity and its node..</li>
</ul>
<h4 id="Overall-Time-Complexity-O-1"><a href="#Overall-Time-Complexity-O-1" class="headerlink" title="Overall Time Complexity : $O(1)$"></a>Overall Time Complexity : $O(1)$</h4><h3 id="OVERALL"><a href="#OVERALL" class="headerlink" title="OVERALL"></a>OVERALL</h3><table>
<thead>
<tr>
<th align="left">SIMPLE_IDEA (USE MAP AND VECTOR)</th>
<th>ROW_ORDER(USE 2D VECTOR)</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>It’s pretty obvious that, if we apply set up a good threshold, the ROW_ORDER and SIMPLE_IDEA both can have great time complexity performance. While the NON_VOTING method is an exponential method although it ensures correctness.</p>
</blockquote>
<h3 id="Extra-How-to-solve-the-problem-of-Mirrored-Case"><a href="#Extra-How-to-solve-the-problem-of-Mirrored-Case" class="headerlink" title="Extra: How to solve the problem of Mirrored Case"></a>Extra: How to solve the problem of Mirrored Case</h3><p>The reason we don’t get a good match when facing the mirrored case is that, we assume both polygons move in the same direction. And the solution is simple. </p>
<p>We add another n nodes at depth one, assume those point pairs moves in opposite direction, assume the first move clockwise and the second move counterclockwise. In this way, we can fix the problem.</p>
<img src="https://i.loli.net/2021/10/23/dswPBx9S4plfatK.png" alt="PNG图像 11" style="zoom:67%;" />

<p>Nodes in red colors are indicating two polygons move in opposite direction, while the blue color ones move in the same direction. This address the mirror problem.</p>
<h2 id="Appendix-Source-Code-in-C-11"><a href="#Appendix-Source-Code-in-C-11" class="headerlink" title="Appendix:    Source Code (in C++11)"></a>Appendix:    Source Code (in C++11)</h2><h4 id="tree-hpp"><a href="#tree-hpp" class="headerlink" title="tree.hpp"></a>tree.hpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">structure of the treenode</span></span><br><span class="line"><span class="comment">@memebers:</span></span><br><span class="line"><span class="comment">pointPair(contains the pair of points)</span></span><br><span class="line"><span class="comment">indices(contains the indices of points)</span></span><br><span class="line"><span class="comment">count(how many votes this node have)</span></span><br><span class="line"><span class="comment">isValid(if this node is a valid match, used for pruning)</span></span><br><span class="line"><span class="comment">depth(depth of the node)</span></span><br><span class="line"><span class="comment">credits(how many credits this node can spend, see report for details.</span></span><br><span class="line"><span class="comment">basically, a node with n credits can have n+1 child)</span></span><br><span class="line"><span class="comment">parent(the parent of the node)</span></span><br><span class="line"><span class="comment">children(the children of the node,indexing by the number of children)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//default constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pointPair.first = <span class="built_in">Point</span>();</span><br><span class="line">        pointPair.second = <span class="built_in">Point</span>();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        isValid = <span class="literal">true</span>;</span><br><span class="line">        parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(Point &amp;a, Point &amp;b, TreeNode *parent, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, <span class="keyword">int</span> depth, <span class="keyword">int</span> credit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pointPair = std::<span class="built_in">make_pair</span>(a, b);</span><br><span class="line">        <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">        <span class="keyword">this</span>-&gt;depth = depth;</span><br><span class="line">        <span class="keyword">this</span>-&gt;credits = credit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//corresponding points&#x27; coordinates</span></span><br><span class="line">    std::pair&lt;Point, Point&gt; pointPair;</span><br><span class="line">    <span class="comment">//points&#x27; index respectively</span></span><br><span class="line">    std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//how many votes it has, valid leaf node has 1 vote</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//check if the match is valid</span></span><br><span class="line">    <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//the depth of current node</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//how many credits it can use</span></span><br><span class="line">    <span class="keyword">int</span> credits = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cumulative similarity along the path</span></span><br><span class="line">    <span class="keyword">float</span> cumulativeSim = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//parent node</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="comment">//we use points pairs&#x27; indices as key to get the TreeNode*</span></span><br><span class="line">    <span class="comment">//e.g. children[pair(1,2)] means get a children with pointsA[1] and pointsB[2]</span></span><br><span class="line">    std::map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, TreeNode *&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the structure of the tree</span></span><br><span class="line"><span class="comment">@members:</span></span><br><span class="line"><span class="comment">root (root of the tree)</span></span><br><span class="line"><span class="comment">m,n (the size of point sets)</span></span><br><span class="line"><span class="comment">buildTree (build tree of point sets, with some pruning)</span></span><br><span class="line"><span class="comment">printTree (print all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">invalidate (pruning step, see report for details)</span></span><br><span class="line"><span class="comment">levelOrder (get all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Tree</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees,but this time we don&#x27;t pruning, used for non-voting method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelperWithoutPruning</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// the children&#x27;s index, only move one step</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            <span class="comment">// ready to calculate similarity</span></span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">// set new child, and assign similarity</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            node-&gt;children[idx]-&gt;cumulativeSim = node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children, node with k credits can have k+1 children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">// first index only move one step</span></span><br><span class="line">                <span class="comment">// second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//generate new child</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//only nodes with depth&gt;2 have valid parent and child</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123; <span class="comment">//compute and assign similarity</span></span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    node-&gt;children[idx]-&gt;cumulativeSim += node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees</span></span><br><span class="line">    <span class="comment">//this is with build time pruning</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelper</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//check if the child is valid by comparing the triangle formed by point sets</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">//if similarity is below the threshold, don&#x27;t extend, set the node to invalid</span></span><br><span class="line">            <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if it has no children, this node itself is also not possible</span></span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if similarity is above the threshold, extend it with the last node</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">//second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//pruning step, if the depth of node is same of greater than 2</span></span><br><span class="line">                <span class="comment">//check 2 triangles form by its parent and child and itself are similar</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    <span class="comment">//if not similar, don&#x27;t extend</span></span><br><span class="line">                    <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it&#x27;s shallower or is similar, extend</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//check after the generate step, if the node have children</span></span><br><span class="line">            <span class="comment">//if it have no children, meaning the current match is invalid</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, with build time pruning.</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, but no pruning this time;</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTreeWithoutPruning</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper(without pruning) function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invalidate the node if it has no children, or all of its children are invalid</span></span><br><span class="line">    <span class="comment">//top-down</span></span><br><span class="line">    <span class="comment">//FURTHER PRUNING IN THE REPORT</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if the node has no children and it&#x27;s not a leaf</span></span><br><span class="line">        <span class="comment">//meaning that the node is invalid</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; node-&gt;depth &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has children</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//if some of its children are valid, the node should be valid</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = node-&gt;isValid || kv.second-&gt;isValid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this means the node has no valid children</span></span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;isValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invalidate the children of the node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">invalidate</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print tree node indices by level order, but only print those valid</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nodes = <span class="built_in">levelOrder</span>(root);</span><br><span class="line">        <span class="comment">//skip the dummy root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.first &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the nodes of trees by level order</span></span><br><span class="line">    vector&lt;vector&lt;TreeNode *&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;TreeNode *&gt;&gt; ans;</span><br><span class="line">        vector&lt;TreeNode *&gt; cur, next;</span><br><span class="line">        <span class="comment">//the nodes to process in current/next step;</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">push_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!cur.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">                    <span class="comment">//only process valid nodes</span></span><br><span class="line">                    <span class="keyword">if</span> (kv.second-&gt;isValid)</span><br><span class="line">                        next.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(cur, next);</span><br><span class="line">            next.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="geometry-hpp"><a href="#geometry-hpp" class="headerlink" title="geometry.hpp"></a>geometry.hpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">store the coordinate of a 2D point</span></span><br><span class="line"><span class="comment">With some computing method</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// format the point</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Some utility functions of Geometric computation</span></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threshold of similarity between two polygons</span></span><br><span class="line">    <span class="comment">// a good threshold is 0.7~0.9 in simple case</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> threshold = <span class="number">0.9f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    convert radians to degrees</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">toDegree</span><span class="params">(<span class="keyword">float</span> rad)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rad * <span class="number">180.f</span> / pi;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get length of the edge between two points;</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">(Point &amp;a, Point &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> dx = <span class="built_in">abs</span>(a.x - b.x);</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="built_in">abs</span>(a.y - b.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrtf</span>(dx * dx + dy * dy);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @description: a is in the middle of b and c</span></span><br><span class="line"><span class="comment">    this functions returns the angle CAB or simply angle A</span></span><br><span class="line"><span class="comment">    @assumption: assume convex polygon, only return non-reflex angle</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getAngle</span><span class="params">(Point &amp;a, Point &amp;b, Point &amp;c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> AB = <span class="built_in">getLength</span>(a, b);</span><br><span class="line">        <span class="keyword">float</span> BC = <span class="built_in">getLength</span>(b, c);</span><br><span class="line">        <span class="keyword">float</span> AC = <span class="built_in">getLength</span>(a, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> cosA = (AB * AB + AC * AC - BC * BC) / (<span class="number">2</span> * AB * AC);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">toDegree</span>(<span class="built_in">acos</span>(cosA));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    compute similarity between two sets of points(2 polygons)</span></span><br><span class="line"><span class="comment">    the sets should have the same size.</span></span><br><span class="line"><span class="comment">    For details, see report.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">similarity</span><span class="params">(vector&lt;Point&gt; &amp;a, vector&lt;Point&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        don&#x27;t take similarity between lines into account</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between edges</span></span><br><span class="line">        <span class="keyword">float</span> simLenUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> simLenLower = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[i], b[i + <span class="number">1</span>]);</span><br><span class="line">            simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">            simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//the last edge between the first and the last point</span></span><br><span class="line">        <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>]);</span><br><span class="line">        simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">        simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edge coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simLenUpper / simLenLower);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between angles</span></span><br><span class="line">        <span class="keyword">float</span> simAngUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[i], a[i + <span class="number">1</span>], a[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[i], b[i + <span class="number">1</span>], b[i - <span class="number">1</span>]);</span><br><span class="line">            simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//last 2 angles</span></span><br><span class="line">        <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>], a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        angA = <span class="built_in">getAngle</span>(a[n - <span class="number">1</span>], a[n - <span class="number">2</span>], a[<span class="number">0</span>]);</span><br><span class="line">        angB = <span class="built_in">getAngle</span>(b[n - <span class="number">1</span>], b[n - <span class="number">2</span>], b[<span class="number">0</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//angle coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simAngUpper / <span class="number">180.f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">USAGE ON MACROS:</span></span><br><span class="line"><span class="comment">_ROW_ORDER: VOTING TABLE ROW_ORDERED METHOD</span></span><br><span class="line"><span class="comment">_NON_VOTING: NON VOTING METHOD</span></span><br><span class="line"><span class="comment">_VOTE_ORDER: SIMPLE IDEA METHOD</span></span><br><span class="line"><span class="comment">_USER_INPUT: GET INPUT FROM USER</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AVAIABLE CASES:</span></span><br><span class="line"><span class="comment">    _SAMPLE_CASE1~4</span></span><br><span class="line"><span class="comment">    MIRROR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define _ROW_ORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAMPLE_CASE1</span></span><br><span class="line"><span class="comment">// #define _NON_VOTING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _VOTE_ORDER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TO USE: set C++ standard to C++11 or later</span></span><br><span class="line"><span class="comment">Read &quot;README.md&quot; first.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@params:levelOrder,votingTable,maxDepth</span></span><br><span class="line"><span class="comment">@return:isFullMatch</span></span><br><span class="line"><span class="comment">@description:1.compute how many votes each nodes has 2. visit each valid node, and vote</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">voting</span><span class="params">(vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;levelOrder, map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;table, <span class="keyword">int</span> maxDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//this means no path can be length m, meaning no full match</span></span><br><span class="line">    <span class="keyword">if</span> (levelOrder.<span class="built_in">size</span>() &lt; maxDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No Full Match Under Such Similarity Setting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check the degree of each node, and only visit each node once</span></span><br><span class="line">    <span class="comment">// leaf as one count</span></span><br><span class="line">    <span class="comment">// node.count = node-&gt;left.count+node-&gt;right.count;</span></span><br><span class="line">    <span class="comment">// compute from bottom up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute each node has how many votes,skip the dummy root</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = levelOrder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//leaf nodes has one vote</span></span><br><span class="line">            <span class="keyword">if</span> (levelOrder[i][j]-&gt;depth == maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                levelOrder[i][j]-&gt;count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//non-leaf nodes have vote equals to its all valid children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : levelOrder[i][j]-&gt;children)</span><br><span class="line">                levelOrder[i][j]-&gt;count += kv.second-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after computing how many votes each node has, we need to calculate the final vote count</span></span><br><span class="line">    <span class="comment">//voting process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; levelOrder.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            table[levelOrder[i][j]-&gt;indices] += levelOrder[i][j]-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two vectors to store input</span></span><br><span class="line">    vector&lt;Point&gt; pointsA;</span><br><span class="line">    vector&lt;Point&gt; pointsB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compute answer from user input</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USER_INPUT</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE1</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small square and a 2x square</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE2</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small triangle and a pentagon</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE3</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a large case to test speed performance (M=21,N=28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE4</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this actually got problems, but if we got a match, the overall polygon matching is actually correct,</span></span><br><span class="line"><span class="comment">//we only have to reorder the indices order</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIRROR</span></span><br><span class="line">    <span class="comment">// MIRROR Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureing pointsA always have smaller size</span></span><br><span class="line">    <span class="keyword">if</span> (pointsA.<span class="built_in">size</span>() &gt; pointsB.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    using map for voting table, where key is the point pair indicies</span></span><br><span class="line"><span class="comment">    here we have to use map instead of unordered_map</span></span><br><span class="line"><span class="comment">    because type(pair&lt;int,int&gt;) in C++ STL is not hashable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; votingTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Initialize Tree with given points array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Tree <span class="title">tree</span><span class="params">(pointsA.size(), pointsB.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in non voting method, we didn&#x27;t prune the tree</span></span><br><span class="line"><span class="comment">we calculate the the cumulative Similarity of all the leaf nodes</span></span><br><span class="line"><span class="comment">finding out the one with cumulative largest similarity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree without pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTreeWithoutPruning</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line">    <span class="comment">//leaf nodes are at the last level</span></span><br><span class="line">    <span class="keyword">auto</span> leaves = nodes[nodes.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compare and find out the node with largest cumulative similarity</span></span><br><span class="line">    <span class="keyword">float</span> maxSum = <span class="number">0.f</span>;</span><br><span class="line">    TreeNode *maxNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> leaf : leaves)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaf-&gt;cumulativeSim &gt; maxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = leaf-&gt;cumulativeSim;</span><br><span class="line">            maxNode = leaf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after finding the max cumulativeSimilarity</span></span><br><span class="line">    <span class="comment">//trace back bottom up, push the path to result</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (maxNode-&gt;parent != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(maxNode-&gt;indices);</span><br><span class="line">        maxNode = maxNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print out the path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + res[i].first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + res[i].second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="comment">//print time it takes</span></span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this contains build/prune/level order/vote 4 steps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree with build time pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTree</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// further pruning step</span></span><br><span class="line">    tree.<span class="built_in">invalidate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the valid nodes in the tree, for test</span></span><br><span class="line">    <span class="comment">// tree.printTree();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check if there&#x27;s a full match, also doing the voting</span></span><br><span class="line">    <span class="keyword">bool</span> isFullMatch = <span class="built_in">voting</span>(nodes, votingTable, pointsA.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if no full match, return with -1</span></span><br><span class="line">    <span class="keyword">if</span> (!isFullMatch)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a method ensuring no collision match, with possibility of wrong-matching but no collision</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _ROW_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; row_order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// we use a 2D matrix to represent the table</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            <span class="built_in">res</span>(pointsA.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(pointsB.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert the std::map into 2D vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : votingTable)</span><br><span class="line">        &#123;</span><br><span class="line">            res[kv.first.first][kv.first.second] = kv.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse each row, find out the max element</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; res[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the element has the most votes in the row</span></span><br><span class="line">                <span class="keyword">if</span> (res[i][j] == *<span class="built_in">max_element</span>(res[i].<span class="built_in">begin</span>(), res[i].<span class="built_in">end</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (verbose)</span><br><span class="line">                        <span class="comment">//print out the indicies</span></span><br><span class="line">                        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + j &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//disable the column, in case next row matches the same column</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop for k times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">row_order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//calculate the time performance</span></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this is the SIMPLE_IDEA in the report</span></span><br><span class="line"><span class="comment">//print m matches with top most votes, collision could happen with a low threshold</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _VOTE_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getting matches with order of votes, using with restrict threshold of similarity</span></span><br><span class="line">        vector&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            pairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert map to vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itr = votingTable.<span class="built_in">begin</span>(); itr != votingTable.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(*itr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sort voting table by its vote count</span></span><br><span class="line">        <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), [](pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;a, pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the first m highest votes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointsA.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop for loop_count times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST UTILITY FUNCTIONS</span></span><br><span class="line">    <span class="comment">// auto pp = root-&gt;children[make_pair(0, 0)]-&gt;children[make_pair(1, 1)]-&gt;pointPair;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pp.first.print();</span></span><br><span class="line">    <span class="comment">// pp.second.print();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::similarity(pointsA, pointsB) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::getAngle(pointsA[0], pointsA[1], pointsA[2]) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST INPUT</span></span><br><span class="line">    <span class="comment">// for (const auto &amp;point : pointsA)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     point.print();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration:"></a>Declaration:</h3><h4 id="I-hereby-declare-that-all-the-work-done-in-this-project-titled-“cy2021-3180101246-P2”-is-of-my-independent-effort"><a href="#I-hereby-declare-that-all-the-work-done-in-this-project-titled-“cy2021-3180101246-P2”-is-of-my-independent-effort" class="headerlink" title="I hereby declare that all the work done in this project titled “cy2021_3180101246_P2” is of my independent effort."></a>I hereby declare that all the work done in this project titled “cy2021_3180101246_P2” is of my independent effort.</h4>
                <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
                <audio id="audio" loop="1" preload="auto" controls="controls"
                    data-autoplay=" false">
                    <source type="audio/mpeg" src="">
                </audio>
                
                    <ul id="audio-list" style="display:none">
                        
                            
                                <li title="0" data-url="http://music.163.com/song/media/outer/url?id=430224.mp3"></li>
                                
                                        
                    </ul>
                    
        </div>
        <div id="gitalk-container" class="comment link">Load Comments</div>
    </div>
    
</div>
    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1.1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"vOffset":-100,"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>

    
<script src="/js/Valine.min.js"></script>

        
            
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>

                
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>121.Buy And Sell Stock</title>
    <url>/2021/09/22/121.BuyAndSellStock/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>



<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Traverse all price pairs, ans = max(ans,pair[j]-pair[i]), where j &gt; i.</p>
<p>Steps:$n^2/2$ -&gt; TLE</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Define"><a href="#Define" class="headerlink" title="Define:"></a>Define:</h4><p>Max_profit = max{price[j]-price[i]}</p>
<p>0&lt;= i &lt; j &lt; n-1</p>
<h4 id="Finding"><a href="#Finding" class="headerlink" title="Finding:"></a>Finding:</h4><blockquote>
<p>Buy: price[i] = min{prices[:i]}</p>
<p>Sell: price[j] = max{prices[j:]}</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><h4 id="1-Keep-track-of-the-minimun-price-so-far"><a href="#1-Keep-track-of-the-minimun-price-so-far" class="headerlink" title="1.Keep track of the minimun price so far:"></a>1.Keep track of the minimun price so far:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse the price:</span><br><span class="line"></span><br><span class="line">​	L = the Lowest price up to day i</span><br><span class="line">	P = the max profit up to day i</span><br><span class="line">	</span><br><span class="line">	L.update</span><br><span class="line">	P.update</span><br><span class="line"></span><br><span class="line">//Buy at the lowest price, sell at day i.</span><br></pre></td></tr></table></figure>



<h4 id="2-Convert-the-priceList-to-the-gainList"><a href="#2-Convert-the-priceList-to-the-gainList" class="headerlink" title="2.Convert the priceList to the gainList"></a>2.Convert the priceList to the gainList</h4><blockquote>
<p>Example:</p>
<p>prices = [7,1,5,3,6,4]</p>
<p>Gains = [0,-6,4,-2,3,-2]</p>
</blockquote>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h3><p>The profit is the sum of a subarray in gains.</p>
<p>And the max_profit = the largest sum of subarray of an array(LeetCode 53).</p>
<h4 id="Using-Kadane’s-Algorithm"><a href="#Using-Kadane’s-Algorithm" class="headerlink" title="Using Kadane’s Algorithm"></a>Using Kadane’s Algorithm</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># Kadane&#x27;s Algorithm</span></span><br><span class="line">        maxCurrent = maxGlobal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># the maxCurrent is sum(maxCurrent+num)(the max subarray before this elem) or num</span></span><br><span class="line">            maxCurrent = <span class="built_in">max</span>(nums[i], maxCurrent + nums[i])</span><br><span class="line">            <span class="comment"># update maxGlobal = max(maxCurrent)</span></span><br><span class="line">            maxGlobal = <span class="built_in">max</span>(maxCurrent, maxGlobal)</span><br><span class="line">        <span class="keyword">return</span> maxGlobal</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>1239.Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2021/09/22/1239.Maximum%20Length%20of%20a%20Concatenated%20String%20with%20Unique%20Characters/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of strings <code>arr</code>. String <code>s</code> is a concatenation of a <mark>sub-sequence</mark> of <code>arr</code> which have <strong>unique characters</strong>.</p>
<p>Return <em>the maximum possible length</em> of <code>s</code>.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span><br><span class="line">Maximum length is 4.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">Output: 26</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 16</code></li>
<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>
<li><code>arr[i]</code> contains only lower case English letters.</li>
</ul>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><ul>
<li><p>A subsequence should preserve the order.</p>
<ul>
<li>For example, arr = [“un”,”iq”,”ue”], “iqun” is not a valid answer.</li>
<li>Corollary:<ul>
<li>However, we only want the length of the string, so the <strong>order</strong> of the strings are trivial.</li>
</ul>
</li>
</ul>
</li>
<li><p>The constraints has implied us that the algorithm could be exponential.</p>
</li>
<li><p>if arr[i] itself contains duplicate characters, it’s invalid.</p>
</li>
</ul>
<h3 id="BruteForce"><a href="#BruteForce" class="headerlink" title="BruteForce:"></a>BruteForce:</h3><p>Traverse all the string pair, find if the concantenated string has duplicate char.</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
</blockquote>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique:"></a>Technique:</h3><p>Since the arr[i].length&lt;=26&lt;32, we can use a 32bit int to do the char count</p>
<p>(How many times each character present in a string instead of map)</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
<p>Space Complexity $O(n)$ : using DFS recursion, the space complexity equals to the depth of recursion.</p>
</blockquote>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h4><p><img src="https://i.loli.net/2021/09/22/xbP8JXEZH7VWzdl.png" alt="image-20210922201019533"></p>
<blockquote>
<p>Referenced from Hua Hua@Youtube</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span></span><br><span class="line"><span class="comment">Output: 4</span></span><br><span class="line"><span class="comment">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span></span><br><span class="line"><span class="comment">Maximum length is 4.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//valid string</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string &amp;x : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//bit representations</span></span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//bit representation</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if the char used != the length of string, it contains duplicates.</span></span><br><span class="line">            <span class="comment">//ignore the string</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(mask) != x.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            a.<span class="built_in">push_back</span>(mask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//s is the index of string, mask is the present state</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> s, <span class="keyword">int</span> mask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//update the result</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, __builtin_popcount(mask));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the result is valid</span></span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(mask &amp; a[i]) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//go to combine with next element</span></span><br><span class="line">                    <span class="built_in">dfs</span>(i + <span class="number">1</span>, mask | a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>382. Linked List Random Node</title>
    <url>/2021/11/15/382.%20Linked%20List%20Random%20Node/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>Implement the <code>Solution</code> class:</p>
<ul>
<li><code>Solution(ListNode head)</code> Initializes the object with the integer array nums.</li>
<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg" alt="getrand-linked-list"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 3, 2, 2, 3]</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li>The number of nodes in the linked list will be in the range <code>[1, 104]</code>.</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
<li>At most <code>10^4</code> calls will be made to <code>getRandom</code>.</li>
</ul>
<blockquote>
<p>Since at most 10k calls will be made, the overall time complexity of each random call is expected to be bounded by O(nlogn).</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><p>A simple approach would be converting the linked list into an array, and then random generate a number and random access the array. This would cost extra <code>O(n)</code> space for keeping an array, and <code>O(1)</code> to random access the array.</p>
<blockquote>
<p>Actually, another implementation is that, we could traverse the list to get the length, and then random generate a number, and then take O(n) step to get the number.</p>
<p>This implementation would take O(1) extra space, and O(n) for traversing and accessing.</p>
</blockquote>
<h3 id="What-if…-just-visit-each-node-only-once-and-use-O-1-space"><a href="#What-if…-just-visit-each-node-only-once-and-use-O-1-space" class="headerlink" title="What if… just visit each node only once and use O(1) space?"></a>What if… just visit each node only once and use O(1) space?</h3><blockquote>
<p>The key is, Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>So to ensure the same probability, it is not necessary to use the built-in random function.</p>
</blockquote>
<h3 id="Introducing-Reservoir-Sampling"><a href="#Introducing-Reservoir-Sampling" class="headerlink" title="Introducing Reservoir Sampling:"></a>Introducing Reservoir Sampling:</h3><p>I found a video on YouTube, explaining this idea in an interesting and great way.</p>
<ul>
<li><h4 id="Scenario-A-man-picking-a-hat"><a href="#Scenario-A-man-picking-a-hat" class="headerlink" title="Scenario: A man picking a hat"></a>Scenario: A man picking a hat</h4><ul>
<li><h4 id="each-round-replace-the-old-hat-or-wear-new-hat"><a href="#each-round-replace-the-old-hat-or-wear-new-hat" class="headerlink" title="each round replace the old hat or wear new hat"></a>each round replace the old hat or wear new hat</h4></li>
<li><p>Each round probability of wearing new hat: 1/n</p>
</li>
<li><p>The first hat has a chance of 1/1, so he 100% wear the hat</p>
</li>
<li><p>The second hat has a chance of 1/2, so he 50% wear the 2nd hat, 50% keep the first hat</p>
</li>
<li><p>The third hat has a chance of 1/3, 1/3 wear the 3nd hat, 2/3 keep the original hat</p>
</li>
<li><p>So on and so forth…</p>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/01/08/F9ehzSj1Ovrx6Tq.png" alt="image-20220108005314005" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/01/08/OA8nIcDtopjaB7x.png" alt="image-20220108005616966" style="zoom:50%;" />

<h3 id="The-Good-Side"><a href="#The-Good-Side" class="headerlink" title="The Good Side:"></a>The Good Side:</h3><p>Reservoir sampling doesn’t need to know the length of the list in advance, it’s an online random algorithm.</p>
<h3 id="Proof-on-Equal-Probability"><a href="#Proof-on-Equal-Probability" class="headerlink" title="Proof on Equal Probability:"></a>Proof on Equal Probability:</h3><p>The $i_{th}$ hat has a probability of $\frac{1}{i}$ of being chosen in its round. The probability of  $i_{th}$ hat being chosen after $n$ times can be given as:</p>
<img src="https://s2.loli.net/2022/01/08/XFk2Rr3On7gaKpM.png" alt="image-20220108005314005" style="zoom: 100%;" />

<p>Which is the multiplication of $i_{th}$ hat being chosen, and all the hats after $i_{th}$ hat not being chosen.</p>
<p>And this RHS equals to $\frac{1}n$, which means every hat has the same probability of being chosen.</p>
<ul>
<li>Link: <a href="https://www.youtube.com/watch?v=A1iwzSew5QY">https://www.youtube.com/watch?v=A1iwzSew5QY</a></li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h3><p>Now let’s implement the Reservoir Sampling into our code, note that we still have to simulate the process of spinning the wheel, using the random function to implement. And it’s generally slower to perform floating point division, use integer instead.</p>
<ul>
<li>Instead of <code>1/i</code>, we have <code>1,2,3…i</code>, but only the <code>1</code> means being chosen</li>
<li><code>i</code> start from <code>1</code>, because it’s not valid to divide by 0.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reservoir sampling</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> ListNode *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// we are not allowed to modify the head pointer itself</span></span><br><span class="line">        <span class="comment">// each round we create a new node to do the trick</span></span><br><span class="line">        <span class="keyword">auto</span> node = head;</span><br><span class="line">        <span class="keyword">int</span> res = head-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// random generate 1~i, only 1 means being selected</span></span><br><span class="line">            <span class="comment">// i should start from 1, or there would be divide by 0 issue</span></span><br><span class="line">            <span class="keyword">bool</span> replace = (<span class="built_in">rand</span>() % (i - <span class="number">1</span> + <span class="number">1</span>)) + <span class="number">1</span> == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (replace)</span><br><span class="line">                res = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>98.Validate Binary Search Tree</title>
    <url>/2021/09/30/98.ValidateBST/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: root = [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#x27;s value is 5 but its right child&#x27;s value is 4.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Property-of-a-Binary-Search-Tree"><a href="#Property-of-a-Binary-Search-Tree" class="headerlink" title="Property of a Binary Search Tree:"></a>Property of a Binary Search Tree:</h4><p><img src="https://i.loli.net/2021/09/30/B4ygC6psULPtG5Z.png" alt="image-20210930171547076"></p>
<blockquote>
<p>Ref from Huahua@Youtube</p>
</blockquote>
<p>For each TreeNode</p>
<ul>
<li>cur-&gt;left-&gt;val &lt; cur-&gt;val</li>
<li>cur-&gt;right-&gt;val &gt; cur-&gt;val</li>
</ul>
<h4 id="Consider-the-range"><a href="#Consider-the-range" class="headerlink" title="Consider the range:"></a>Consider the range:</h4><p>The input value ranges from -2^31 &lt;= Node.val &lt;= 2^31 - 1, so the positive/negative infinity should be set to LLONG_MIN, LLONG_MAX. (64-bit)</p>
<h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if nulltree:</span><br><span class="line">	return true;</span><br><span class="line"></span><br><span class="line">//if the node val is beyond the range, it&#x27;s invalid.</span><br><span class="line">if node-&gt;val&lt;=min_val||node-&gt;val&gt;=max_val:</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">//check subtree of both sides</span><br><span class="line">return validate(cur-&gt;left,min,cur-&gt;val)&amp;&amp;validate(cur-&gt;right,cur-&gt;val,max)</span><br></pre></td></tr></table></figure>



<h3 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root, <span class="keyword">long</span> mn, <span class="keyword">long</span> mx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= mn || root-&gt;val &gt;= mx)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, mn, root-&gt;val) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root-&gt;val, mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="For-Your-Consider"><a href="#For-Your-Consider" class="headerlink" title="For Your Consider:"></a>For Your Consider:</h4><p>What if the range extends to -2^64 ~2^64-1?</p>
<p><strong>Hint</strong>: Use nullptr to represent infinity.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender 3.1 Alpha Render Test on M1 Max</title>
    <url>/2021/12/10/Blender%203.1%20Render%20Test/</url>
    <content><![CDATA[<h2 id="All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P"><a href="#All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P" class="headerlink" title="All Scenes are rendered using cycles using GPU Compute 1080P"></a>All Scenes are rendered using cycles using GPU Compute 1080P</h2><h3 id="1-Classroom-300-Samplings"><a href="#1-Classroom-300-Samplings" class="headerlink" title="1.Classroom 300 Samplings"></a>1.Classroom 300 Samplings</h3><ul>
<li><p>Result: 1min 47.32s = 107.32s </p>
</li>
<li><p>Boost compared to CPU: 8*60/107.32 = 4.47x</p>
</li>
<li><p>Roughly equivalent to CUDA 3060Ti @Blender 2.9x </p>
</li>
<li><p>Roughtly equivalent to Optix 2080 @Blender 2.8x and Optix 3060 @Blender 2.9x</p>
</li>
<li><p>According to Rob Williams@<a href="https://techgage.com/article/blender-3-0-gpu-performance/">https://techgage.com/article/blender-3-0-gpu-performance/</a>, the performance of M1 Max is half of the 3060 with Optix 3060 @Blender 3.00. If we assume there is a performance boost of 2 times in Cycles from 2.9x to 3.00, a rough equivalent will be 2060 Max-Q (206s Optix 2.93).</p>
<p><img src="https://s2.loli.net/2022/01/01/WiZIz8rKlXEcOYM.png" alt="image-20220101235753865"></p>
</li>
</ul>
<h3 id="2-BMW27-GPU-Compute-1225-Samplings"><a href="#2-BMW27-GPU-Compute-1225-Samplings" class="headerlink" title="2.BMW27 (GPU Compute) 1225 Samplings"></a>2.BMW27 (GPU Compute) 1225 Samplings</h3><ul>
<li>Result: 43.59s</li>
<li>Boost Compared to CPU: 210/43.59 = 4.82x</li>
<li>Roughly equivalent to CUDA 3060~3060Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2060 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/wZ35lDaBkiJ7mWQ.png" alt="image-20211219164344829" style="zoom:50%;" /></li>
</ul>
<h3 id="3-Barcelona-Pavilion-1000-Samplings"><a href="#3-Barcelona-Pavilion-1000-Samplings" class="headerlink" title="3.Barcelona Pavilion 1000 Samplings"></a>3.Barcelona Pavilion 1000 Samplings</h3><ul>
<li>Result: 176.51s</li>
<li>Boost Compared to CPU: 640/176.51 = 3.62x</li>
<li>Roughly equivalent to CUDA 3070~3070Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2070 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/oBTbOQra1Dp8nZd.png" alt="image-20211219171113341" style="zoom:33%;" /></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
      <tags>
        <tag>Redering</tag>
        <tag>Blender</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-概览笔记</title>
    <url>/2021/09/05/Notes-Computer%20Networks/</url>
    <content><![CDATA[<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client/Server:"></a>Client/Server:</h3><p>应用层，最为抽象</p>
<h3 id="TCP-传输层"><a href="#TCP-传输层" class="headerlink" title="TCP:传输层"></a>TCP:传输层</h3><p>对可靠性要求高、检验错误</p>
<h3 id="UDP："><a href="#UDP：" class="headerlink" title="UDP："></a>UDP：</h3><p>对可靠性要求低、但是能够保证实时</p>
<ul>
<li>直播</li>
<li>事务性应用</li>
</ul>
<h3 id="IP-网络层-End-to-End"><a href="#IP-网络层-End-to-End" class="headerlink" title="IP:网络层 End to End"></a>IP:网络层 End to End</h3><p>从主机到主机</p>
<p>在Link Layer的点到点通讯基础上实现</p>
<h3 id="Link-Layer-点到点通讯"><a href="#Link-Layer-点到点通讯" class="headerlink" title="Link Layer:点到点通讯"></a>Link Layer:点到点通讯</h3><h3 id="Physical-Layer-物理信号-数字信号"><a href="#Physical-Layer-物理信号-数字信号" class="headerlink" title="Physical Layer:物理信号-数字信号"></a>Physical Layer:物理信号-数字信号</h3><p>通过media（介质）：</p>
<ul>
<li>Copper</li>
<li>Fibre</li>
</ul>
<h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><h4 id="传统工作方式：查表-转发"><a href="#传统工作方式：查表-转发" class="headerlink" title="传统工作方式：查表+转发"></a>传统工作方式：查表+转发</h4><ul>
<li>路由器交换信息</li>
<li>计算出路由表</li>
<li>IP协议收到分组后，根据IP查路由表，再根据表转发</li>
</ul>
<h4 id="SDN方式：数据平面-控制系统"><a href="#SDN方式：数据平面-控制系统" class="headerlink" title="SDN方式：数据平面+控制系统"></a>SDN方式：数据平面+控制系统</h4><p>交换机：多字段匹配-&gt;block/转发/flood</p>
<p>操作系统：计算flow table-下发给交换机</p>
<p>（programmable+new features could be added）</p>
<p>比如说要新增加负载均衡，只需要编程即可</p>
<h4 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h4><h3 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h3><p>在下层提供的服务上实现更高级的功能</p>
<h3 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node:"></a>Node:</h4><ul>
<li><p>主机以及主机上的应用程序</p>
</li>
<li><p>路由器、交换机等网络交换设备</p>
</li>
<li><p>方的节点：主要节点（Client/Server）</p>
<p>圆形节点：中转节点</p>
</li>
</ul>
<h4 id="Edge-通信链路"><a href="#Edge-通信链路" class="headerlink" title="Edge:通信链路"></a>Edge:通信链路</h4><ul>
<li>access：主机接入到（最近的交换机）互联网的链路（一方一圆）</li>
<li>backbone：路由器之间的链路（两个圆的）</li>
</ul>
<h4 id="Protocol-对等层实体交换数据所需要遵循的规范"><a href="#Protocol-对等层实体交换数据所需要遵循的规范" class="headerlink" title="Protocol:对等层实体交换数据所需要遵循的规范"></a>Protocol:对等层实体交换数据所需要遵循的规范</h4><p>Protocol Data Unit(PDU)</p>
<h3 id="互联网包括：网络边缘-网络核心-接入网"><a href="#互联网包括：网络边缘-网络核心-接入网" class="headerlink" title="互联网包括：网络边缘/网络核心/接入网"></a>互联网包括：网络边缘/网络核心/接入网</h3><h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><p>网络边缘:</p>
<ul>
<li>主机</li>
<li>应用程序</li>
</ul>
<h3 id="1-3-Core（用于数据交换）"><a href="#1-3-Core（用于数据交换）" class="headerlink" title="1.3 Core（用于数据交换）"></a>1.3 Core（用于数据交换）</h3><ul>
<li>相互连接的路由器</li>
<li>网络的网络</li>
</ul>
<h3 id="1-4-Access"><a href="#1-4-Access" class="headerlink" title="1.4 Access"></a>1.4 Access</h3><ul>
<li>有线或者无线通信链路</li>
</ul>
<p>边缘接入核心-&gt;核心连接所有边缘节点-&gt;边缘可以和任意边缘节点交换</p>
<p>网络核心：相当于全球范围内的切换开关（如果需要交换，就打开）</p>
<h4 id="应用进程交互模式："><a href="#应用进程交互模式：" class="headerlink" title="应用进程交互模式："></a>应用进程交互模式：</h4><ul>
<li><p>Client/Server模式：</p>
<ul>
<li>Client后运行起来，向Server发出请求，资源来自于Server</li>
<li>问题：如果Client特别多，需要准备很多Server，到达一定程度时性能断崖式下跌</li>
</ul>
</li>
<li><p>Peer-Peer 模式：</p>
<ul>
<li>没有专门的服务器</li>
<li>每个节点既是Client也是Server</li>
<li>分布式通信，下载文件的时候，相当于多路下载片段</li>
</ul>
</li>
</ul>
<h4 id="基础设施为网络应用提供的服务："><a href="#基础设施为网络应用提供的服务：" class="headerlink" title="基础设施为网络应用提供的服务："></a>基础设施为网络应用提供的服务：</h4><ul>
<li>TCP（面向连接（端系统知道/路径节点不知道）的通信方式）：Shake Hand方式（数据传输前做好准备）<ul>
<li>可靠：不重复、不丢、不乱序</li>
<li>Flow Control:发送方不会淹没接收方</li>
<li>阻塞控制(Congestion Control)</li>
<li>要考虑网络+设备</li>
</ul>
</li>
<li>UDP(connectless，直接发送，不需要提前连接)<ul>
<li>不可靠</li>
<li>没有流量控制</li>
<li>没有阻塞控制</li>
<li>适合实时多媒体应用</li>
<li>事务性很强的应用（）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>1345. Jump Game IV</title>
    <url>/2022/01/14/1345.%20Jump%20Game%20IV/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of integers <code>arr</code>, you are initially positioned at the first index of the array.</p>
<p>In one step you can jump from index <code>i</code> to index:</p>
<ul>
<li><code>i + 1</code> where: <code>i + 1 &lt; arr.length</code>.</li>
<li><code>i - 1</code> where: <code>i - 1 &gt;= 0</code>.</li>
<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>
</ul>
<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>
<p>Notice that you can not jump outside of the array at any time.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You do not need to jump.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>-10^8 &lt;= arr[i] &lt;= 10^8</code></li>
</ul>
<blockquote>
<p>The length of the array is up to 10^4, the algorithm is expected to be bounded by ==O(nlogn)==</p>
</blockquote>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Each round, you can jump front or back one step, or jump to the place with the same value.</p>
<ul>
<li>Traverse all possibilities that start from index 0, with <code>#step = 0</code>, <code>minStep = INT_MAX</code><ul>
<li>Each time, try out 3 possibilities, <code>#step++</code><ul>
<li>When reaching the end, update the <code>minStep = min(minStep,#step)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>It’s obvious that this method has a factorial time complexity. We can make a little modification, that is, each place can only be visited at most once, or it can’t be the <code>minimum number of steps</code>.</p>
</blockquote>
<h3 id="An-Graph-like-Intuition"><a href="#An-Graph-like-Intuition" class="headerlink" title="An Graph-like Intuition:"></a>An Graph-like Intuition:</h3><ul>
<li><p>Each place is a node on the graph, nodes are sequentially linked according to their order in the array.</p>
</li>
<li><p>If there are nodes with the same value, link them with an edge.</p>
</li>
<li><p>Since we can move forward and backward at each place, the graph is a undirected graph.</p>
</li>
<li><p>Use BFS for solution (Use queue)</p>
</li>
</ul>
<blockquote>
<p>In actual implementation, a graph is not necessary, we can just keep. a hash map, where key is the value, value is the position of these values.</p>
</blockquote>
<h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity:"></a>Complexity:</h3><p>Vertices = N, Edges at max, all nodes have same value, $O(N^2)$, at min, 0.</p>
<ul>
<li><p>Time Complexity: O(V+E)</p>
</li>
<li><p>Space Complexity: O(V+E) (Use Graph), O(V) (Not using extra graph)</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h3><p>In the implementation, our time complexity depends on the number of edges. In cases of the same value, there could be edges at $O(N^2)$. (All nodes have the same value), which is obviously gonna give us a TLE.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In the BFS Step, after we enqueue nodes with the same value, we can clear the entry in the hash map.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//same value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//core step, this will get us away from redundant search</span></span><br><span class="line">    <span class="comment">//this step ensures nodes of the same value won&#x27;t get enqueued overly</span></span><br><span class="line">    <span class="comment">//actually, enqueue nodes of the same value once is enough</span></span><br><span class="line">    <span class="comment">//so we clear out the entry </span></span><br><span class="line">    sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;value,position&gt;</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; sameValueSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sameValueSet[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shortestPath</span><span class="params">(arr.size(), INT32_MAX)</span></span>;</span><br><span class="line">        shortestPath[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : sameValueSet[arr[<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">            &#125;</span><br><span class="line">            sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortestPath[arr.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">100</span>, <span class="number">-23</span>, <span class="number">-23</span>, <span class="number">404</span>, <span class="number">100</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">404</span>&#125;;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">minJumps</span>(arr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1463. Cherry Pickup II</title>
    <url>/2022/01/07/1463.%20Cherry%20Pickup%20II/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>You are given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries where <code>grid[i][j]</code> represents the number of cherries that you can collect from the <code>(i, j)</code> cell.</p>
<p>You have two robots that can collect cherries for you:</p>
<ul>
<li><strong>Robot #1</strong> is located at the <strong>top-left corner</strong> <code>(0, 0)</code>, and</li>
<li><strong>Robot #2</strong> is located at the <strong>top-right corner</strong> <code>(0, cols - 1)</code>.</li>
</ul>
<p>Return <em>the maximum number of cherries collection using both robots by following the rules below</em>:</p>
<ul>
<li>From a cell <code>(i, j)</code>, robots can move to cell <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code>.</li>
<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.</li>
<li>When both robots stay in the same cell, only one takes the cherries.</li>
<li>Both robots cannot move outside of the grid at any moment.</li>
<li>Both robots should reach the bottom row in <code>grid</code>.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png" alt="sample_1_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.</span><br><span class="line">Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.</span><br><span class="line">Total of cherries: 12 + 12 = 24.</span><br></pre></td></tr></table></figure>



<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png" alt="sample_2_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.</span><br><span class="line">Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.</span><br><span class="line">Total of cherries: 17 + 11 = 28.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<blockquote>
<p>We have a maximum input size of 70*70 = 4900, a loose limit would be $O((mn)^2)$.</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><ul>
<li>Each round, each robot would go exactly one step down. And they will always move forward until reaching the end.<ul>
<li>In this way, we can describe the status of two robots by a 3-element tuple <code>(y,x1,x2)</code>. Since <code>#y: row #x: col</code>, there are $O(r*c^2)$ combinations</li>
</ul>
</li>
<li><code>dp[y][x1][x2]</code> means the maximum cherries collected at this combination</li>
<li>Base Case: <code>y&gt;=r, x&lt;0 or x&gt;c</code> (out of bounary), return 0</li>
<li><strong>Transition Equation:</strong> <code>dp[y+1][x1][x2] =&#123;max[y][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0&#125;</code></li>
<li>Time Complexity: $O(r<em>c^2</em>9)$</li>
<li>Space Complexity: $O(r*c^2)$</li>
<li><strong>To get the answer:</strong> find the maximum value in <code>dp[r-1][x1][x2]</code> (traverse)</li>
</ul>
<h3 id="A-Reverse-Solution"><a href="#A-Reverse-Solution" class="headerlink" title="A Reverse Solution:"></a>A Reverse Solution:</h3><p>Robots start at any grid in the last level, and then they go up until one goes to the left corner, the other go to the right corner.</p>
<ul>
<li><p><strong>Transition Equation:</strong> <code>dp[y][x1][x2] =&#123;max[y+1][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0</code>}</p>
</li>
<li><p><strong>To get the answer</strong>: <code>dp[0][0][c-1]</code></p>
</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> triArr = vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">triArr <span class="title">dp</span><span class="params">(r, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(c, vector&lt;<span class="keyword">int</span>&gt;(c, <span class="number">-1</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(<span class="number">0</span>, <span class="number">0</span>, c - <span class="number">1</span>, grid, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// used for recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, triArr &amp;dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; <span class="number">0</span> || x1 &gt;= c || x2 &lt; <span class="number">0</span> || x2 &gt;= c || y &gt;= r || y &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[y][x1][x2];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//if visited return</span></span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = x1 == x2;</span><br><span class="line">        <span class="keyword">int</span> cur = grid[y][x1] + (isSame ? <span class="number">0</span> : grid[y][x2]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d1 = <span class="number">-1</span>; d1 &lt;= <span class="number">1</span>; d1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">-1</span>; d2 &lt;= <span class="number">1</span>; d2++)</span><br><span class="line">            &#123; <span class="comment">// each round find the max one from 9 combinations</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur + <span class="built_in">helper</span>(y + <span class="number">1</span>, x1 + d1, x2 + d2, grid, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//update the answer</span></span><br><span class="line">        dp[y][x1][x2] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Why Tuple?</title>
    <url>/2021/09/21/WhyTuple?/</url>
    <content><![CDATA[<p>C++ 11 introduces a template Tuple, similar to the one in Python, allows you to store data of different types in a single entity. But you may ask, in C/C++,we already have some mechaism called struct allows us to do the same thing, then why do we need tuple?</p>
<h3 id="Case-1-One-Time-Structure-to-Transfer-Data"><a href="#Case-1-One-Time-Structure-to-Transfer-Data" class="headerlink" title="Case 1: One-Time Structure to Transfer Data"></a>Case 1: One-Time Structure to Transfer Data</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;string,<span class="keyword">int</span>&gt; <span class="title">getNameAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">34</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span>string name;<span class="keyword">int</span> age;&#125;p;</span><br><span class="line">    tuple&lt;string,<span class="keyword">int</span>&gt; t;</span><br><span class="line">    </span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">tie</span>(name,age) = <span class="built_in">getNameAge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we want to transfer a group of data for only one time, we may not want to define a struct, and using tuple get us away from these definitions.</p>
<h3 id="Case-2-Fast-Comparison-Using-Tuple-Operators"><a href="#Case-2-Fast-Comparison-Using-Tuple-Operators" class="headerlink" title="Case 2: Fast Comparison Using Tuple Operators"></a>Case 2: Fast Comparison Using Tuple Operators</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; time1,time2;</span><br><span class="line"><span class="keyword">if</span>(time1&gt;time2)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time1 is later&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Case-3-Multi-Index-Map-Unordered-Map"><a href="#Case-3-Multi-Index-Map-Unordered-Map" class="headerlink" title="Case 3: Multi-Index Map/Unordered Map"></a>Case 3: Multi-Index Map/Unordered Map</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define</span></span><br><span class="line">map&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>,<span class="keyword">float</span>&gt;,string&gt; m;</span><br><span class="line"><span class="comment">//indexing</span></span><br><span class="line">m[<span class="built_in">make_tuple</span>(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1.0</span>)] = <span class="string">&quot;Test&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Case-4-Fast-Swap"><a href="#Case-4-Fast-Swap" class="headerlink" title="Case 4: Fast Swap"></a>Case 4: Fast Swap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">tie</span>(b,c,a) = <span class="built_in">make_tuple</span>(a,b,c);</span><br></pre></td></tr></table></figure>



<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><p>Tuple is not recommended to be overused. If needed, use struct instead.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Data_Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>thread and process</title>
    <url>/2021/10/08/thread%20and%20process/</url>
    <content><![CDATA[<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>smallest sequence of programmed instructions that can be managed independently by a scheduler.</li>
<li>Has its own registers, PC. SP.</li>
</ul>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><ul>
<li>Instance of a computer program that is being executed</li>
<li>A process can have one or more threads</li>
</ul>
<h3 id="Parallel-Computing"><a href="#Parallel-Computing" class="headerlink" title="Parallel Computing"></a>Parallel Computing</h3><ul>
<li>Run programs on one or more CPUs</li>
<li>Multi-threading (shared memory)</li>
<li>Multi-processing (Independent-memory)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; a += <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(run)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(run)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread1.<span class="built_in">join</span>(); <span class="comment">//only return after the thread1 finish</span></span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only main thread will execute</span></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading:"></a>Multithreading:</h3><p><img src="https://i.loli.net/2021/10/08/43roIiyfq6DAgS7.png" alt="image-20211008194305920"></p>
<p>Shared memory, so variable can be accessed by both threads.</p>
<p>However, <strong>when multithreads write (non-atomic instruction) a shared variable, inconsistency could happen.</strong></p>
<h3 id="Problem-Access-shared-resources"><a href="#Problem-Access-shared-resources" class="headerlink" title="Problem:Access shared resources:"></a>Problem:Access shared resources:</h3><p>CPU may process instructions randomly.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a += <span class="number">1</span>;<span class="comment">//non-atomic</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r</span><br><span class="line">INC r</span><br><span class="line">STORE r,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">INC r2,</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">// this is sequential</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r2</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>



<h4 id="To-fix"><a href="#To-fix" class="headerlink" title="To fix:"></a>To fix:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//thread blocking</span></span><br><span class="line">	l.<span class="built_in">lock</span>();</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    l.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: only use lock when going to the critical section, becuase multithreading is much faster.</p>
<h4 id="Communicate"><a href="#Communicate" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared variable</li>
<li>semaphore, mutex, lock</li>
</ul>
<h3 id="Multiprocessing"><a href="#Multiprocessing" class="headerlink" title="Multiprocessing:"></a>Multiprocessing:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">bool</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=child?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();<span class="comment">//create a parallel universe</span></span><br><span class="line">    <span class="comment">// all processes will execute this</span></span><br><span class="line">    <span class="built_in">run</span>(pid==<span class="number">0</span>);</span><br><span class="line">    cour&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/08/lxveEnH8zRh6TqB.png" alt="image-20211008195339005"></p>
<p>The pid returned by the fork() will not be 0 (0 as child process)</p>
<p>pid is the child process, should be 2+2;</p>
<p>pid is the parent process, should be 2+1;</p>
<h4 id="Communicate-1"><a href="#Communicate-1" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared memory</li>
<li>pipe</li>
<li>socket</li>
<li>RPC</li>
</ul>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>ノエルのテーマ 〜最後の旅〜</title>
    <url>/2021/09/27/%E3%83%8E%E3%82%A8%E3%83%AB%E3%81%AE%E3%83%86%E3%83%BC%E3%83%9E%E3%80%80%E3%80%9C%E6%9C%80%E5%BE%8C%E3%81%AE%E6%97%85%E3%80%9C/</url>
    <content><![CDATA[<h4 id="Original-Lyrics"><a href="#Original-Lyrics" class="headerlink" title="Original Lyrics:"></a>Original Lyrics:</h4><p>Long ago, when I was just a boy<br>So alone that last of my kind in the world<br>I believe futures could be reborn<br>I would go back in time<br>Change what’s to come</p>
<p>Hunting, searching for futures I’ve dreamed<br>Ever chasing, believing visions unseen<br>Hearing that hope is futile<br>Only inspires me not to give up</p>
<p>Valhalla is calling me to the end<br>I can hear now the beating hearts of lost friends<br>Urging me to not forget them<br>As the last hunter<br>I’ll find the key</p>
<h4 id="Translated-zh-cn"><a href="#Translated-zh-cn" class="headerlink" title="Translated(zh-cn):"></a>Translated(zh-cn):</h4><p>很久之前，当我还是孩童之时</p>
<p>作为族类的最后一人，孑然一身</p>
<p>如果未来可以改变</p>
<p>我将追溯过去，改变将来</p>
<p>苦苦寻求着梦中的未来</p>
<p>漫漫追逐着未见的愿景</p>
<p>正因希望茫茫</p>
<p>而深知此路断不可弃</p>
<p>追随英灵殿的召唤，我来到世界的终末</p>
<p>我离去的朋友啊，心跳声久久回响于耳畔</p>
<p>告诉着我，不能遗忘，断不能遗忘。</p>
<p>背负着大家的使命，我必将找到命运之钥。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Lyrics</tag>
      </tags>
  </entry>
  <entry>
    <title>最近半年的生活状态（上）</title>
    <url>/2022/06/19/%E4%B8%80%E4%BA%9B%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<h3 id="最近半年的生活状态（上）"><a href="#最近半年的生活状态（上）" class="headerlink" title="最近半年的生活状态（上）"></a>最近半年的生活状态（上）</h3><p>​    说起来，自从大四之后就很久很久没有为自己写一些东西，也许是太忙？但也有可能是“我没有把这当作是最重要的事情”，所以一直搁置了。不过临近毕业，总算是稍微有点机会写点什么了，就稍微写一点吧。我想先写一些关于大四上学期的内容，不然就太长了。</p>
<h3 id="大四上"><a href="#大四上" class="headerlink" title="大四上"></a>大四上</h3><p>​    整个大四上发生了很多事情，分手，上课，作品集，申请学校。一直非常焦头烂额，不过好在我在作品集的机构认识了一些朋友，后来11月的时候，还因为疫情的原因在校外酒店住了一个多月。我的整个大四上学期是在忙碌和焦虑中度过的，不过我猜大家都是这样。</p>
<ul>
<li>分手</li>
</ul>
<p>​    学期的一开始，前任就和我提了分手，不过我太想再回忆这些。分手的时候ta撒了一个谎，后来找我复合，我拒绝了。既然已经过去这么久，就这样吧。</p>
<ul>
<li>数据结构基础</li>
</ul>
<p>​    大四上才上数据结构确实挺晚了，甚至申请的时候都不一定会出现在成绩单上，但就当是学知识吧—我是这么想的。学校的数据结构课一开始要分班考，基础还行的同学可以选择困难模式，也就是平时的3个实验课作业题目会变难，好处是评分最多可以比其他同学高5分。我选择了困难模式，当然也为此花了一些时间，现在想想，却也不是那么有必要，尽管确实从一些题目中获得了更深的思考。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0gq6kzmj21yq0tsgrj.jpg" alt="image-20220620001929249" style="zoom:33%;" />

<blockquote>
<p>当时为了练手，日常还会做一些LeetCode补充一下，传到GitHub记录一下？</p>
</blockquote>
<p>​    这门课臭名昭著的地方在于实验课作业的互评制度，也就是大家要互相给代码和实验报告打分。大部分选课的同学应该都是刚上大二，仅校内课程来说，是没有接触过较为现代的Editor或者LaTex/Markdown之类的工具的，于是相当多的同学（至少在我互评的范围内）用Dev C++（大一的时候学校推荐大家使用）写代码，用Word写文档。我觉得他们之中的很多人应该是在这些方面吃了亏，而我可能也只是因为在这些方面（指使用VSCode / Typora）有点接触，在互评上稍微多了点美观分—这其实还挺不公平的…</p>
<p>​    印象比较深的有几件事，一件是期中考试好像只考了69分，还没有到班级平均线。一件是第二个实验课题目比较困难，当时写了有800行代码，较为头疼。不过比较开心的是，那次我实现了一个类似Trie的结构，还是用了比较基础的multithreading和rvalue reference，尽管最后效率非常低…</p>
<p>​    至于这门课的结果还不错，期末考试的800个人里面考了130几名，算是给期中考试挽回了一点颜面吧。</p>
<ul>
<li>作品集</li>
</ul>
<p>​    老实说提起作品集挺汗颜的，只要一想起它我就会非常紧张，但它又是我申请设计/游戏类学校必不可少的一环。暑假因为忙着谈恋爱，浪费（？）了许多时间。我是一个挺恋爱脑的人，所以一旦进入一段关系，效率就会很低下。导致开学的时候，还没有完成多少作品集的内容。从这个意义上来说，幸好分手了，不然以我之前的效率，作品集应该是做不完了吧。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0ekdizkj21750u00wp.jpg" alt="image-20220620001722163" style="zoom:33%;" />

<blockquote>
<p>一张产品渲染图，Blender水平提高了许多</p>
</blockquote>
<p>​    我在作品集机构完成了自己的第一个游戏的Demo，也因此认识了几个好朋友，后来做产品渲染的时候提高了自己的Blender技巧，这些都是我实实在在的收获。果然还是和游戏相关的事情最容易让人获得快乐啊！</p>
<ul>
<li>申请学校</li>
</ul>
<p>​    我这个人申请学校的策略完全就是个超级大海王，或许是怕没有书读，我一共申请了23个项目，光是送分加上申请费用就花了差不多2万块。一开始还会反复检查信息是否有误，到后来麻木了，就不太检查了。而选校的事情本身也不甚严谨，当时甚至是昨天刚听说一个项目，今天就决定申请这个项目。实际上我最终决定去的项目，也是我申请结束前10天听说的。不过，反正多申请一个学校也不会缺斤少两，多申请总不会后悔！</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0kqwfmcj214y0ti41g.jpg" alt="image-20220620002158278" style="zoom:33%;" />

<blockquote>
<p>最后打算去这里了，加州见！</p>
</blockquote>
<ul>
<li>关于日常生活</li>
</ul>
<p>​    上个学期最喜欢的事情是因为临时封校，在外面的酒店住了一个多月。一个多月里我能够每天吃麦当劳，每天喝喜茶。每天都只需要步行去机构，坐在人体工学椅上。晚上洗澡，躺在酒店超级软的床上面。真幸福啊…</p>
<p>​    考GRE那天是万圣节，我当时上午没吃饭就去考试，结果一直到14:30才吃上饭。考完试后去机构继续做作品集，而后回到学校换上我的万圣节costume，扮成迈尔斯来吓人！</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0kp8ijpj20sm12s43z.jpg" alt="image-20220620002245778" style="zoom:33%;" />

<blockquote>
<p>Happy Halloween~</p>
</blockquote>
<p>​    12月的时候我去吃了一个人均500的日料自助。值得一提的是，套餐里有一只大虾，但是是生的。我不喜欢吃刺身，却又不敢说“能不能帮我烤一下”（这太不符合高级日料店的风格了！），于是就只能硬着头皮吃下去。一句题外话，日料的omakase（大概就是自助吧）似乎都挺贵的，好像人均会是4位数，那么看来我吃的这一家店还算比较实惠（？），也不能这么想啦！</p>
<p>​    最后一件事是关于生日，大学四年我过生日都还算比较有仪式感。唯独21岁这次生日，因为忙着做作品集，从早忙到了晚，就没有考虑过生日怎么过。后来，和舍友（他也要做作品集）一起在机构附近简单吃了个饭，就当是过了生日，希望明年一定要补上。还有一点是，虚幻4在我生日这天崩溃了4次，确实挺让我崩溃的。</p>
<p>​    我想这就是我对大四上生活的一些简单回顾吧。哦对了，还有一件事，在学期末找了一些同学组队参加了GameJam，还是挺开心的！大四上在一片忙碌中就这样结束了。</p>
]]></content>
      <categories>
        <category>Life, Journal</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>Missing triangle in BVH</title>
    <url>/2023/05/22/Little%20Caveat%20in%20BVH%20of%20Triangles/</url>
    <content><![CDATA[<p>Recently I was applying Bounding Volume Hierachy to a Whitted-style Raytracing system. The idea of BVH and implementation are well described in <strong>Ray Tracing in the Next Week</strong> by Peter Shirly. It’s a really great book. And here’s the link <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></p>
<p>One key component in BVH is AABB (Axis-Aligned-Bounding-Box) intersects with ray. People usually adopt Slab method to address this problem. To be more specific, computing the ray-AABB intersection along 3 different axis, if these intervals produces an overlapping region, then the ray intersects with AABB and vice versa.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compute (tx0, tx1)</span><br><span class="line">compute (ty0, ty1)</span><br><span class="line">compute (tz0, tz1)</span><br><span class="line">return overlap?( (tx0, tx1), (ty0, ty1), (tz0, tz1))</span><br></pre></td></tr></table></figure>



<img src="https://s2.loli.net/2023/05/23/vhnUw7z6Z1xqeHg.png" alt="image-20230522223149832" style="zoom:33%;" />

<p>After applying this method to the scene rendering, I lost some of the triangles in the scene. However, all spheres are kept intact. For example, here’s what I got after applying BVH and the latter is before BVH.</p>
<img src="https://s2.loli.net/2023/05/23/dN6TeBRK4MjtzSm.png" alt="image-20230522224231933" style="zoom:33%;" />

<img src="https://s2.loli.net/2023/05/23/xQ8LMCgjAqoVWPw.png" alt="image-20230522224256173" style="zoom:33%;" />

<p> After couple hours of <code>step_into</code> debugging, I found the reason to be as follows:</p>
<blockquote>
<p>For spheres, the Bouding box will always have some length along 3 axis. However, this isn’t necessarily the case for AABB of triangles. ==Bounding Box of triangles can fall back to plane if the triangle is parallel to either xy, yz or xz plane== . </p>
<p>Let’s say a triangle is parallel to the <code>xz</code> plane, so the 3 vertices has the same <code>y</code> value. And this makes <code>ty0</code> and <code>ty1</code> to be the same in above computation, and thus resulting no overlapping region for other 2 axis. i.e. The bounding box doesn’t intersect with the triangle (which is a false statement)</p>
</blockquote>
<p>To address this, simply add some thickness to each axis while building bounding box for triangles. In my case, I use <code>1e-3</code>, and boom, problem solved!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in triangle class  </span></span><br><span class="line"><span class="function">AABB <span class="title">getAABB</span><span class="params">(<span class="keyword">float</span> t0, <span class="keyword">float</span> t1)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> min_x = std::<span class="built_in">min</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">x</span>()&#125;);</span><br><span class="line">    <span class="keyword">auto</span> min_y = std::<span class="built_in">min</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">y</span>()&#125;);</span><br><span class="line">    <span class="keyword">auto</span> min_z = std::<span class="built_in">min</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">z</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">z</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">z</span>()&#125;);</span><br><span class="line">    <span class="keyword">auto</span> max_x = std::<span class="built_in">max</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">x</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">x</span>()&#125;);</span><br><span class="line">    <span class="keyword">auto</span> max_y = std::<span class="built_in">max</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">y</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">y</span>()&#125;);</span><br><span class="line">    <span class="keyword">auto</span> max_z = std::<span class="built_in">max</span>(</span><br><span class="line">        &#123;<span class="keyword">this</span>-&gt;v0.position.<span class="built_in">z</span>(), <span class="keyword">this</span>-&gt;v1.position.<span class="built_in">z</span>(), <span class="keyword">this</span>-&gt;v2.position.<span class="built_in">z</span>()&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AABB</span>(gl::<span class="built_in">vec3</span>(min_x<span class="number">-1e3</span>, min_y<span class="number">-1e3</span>, min_z<span class="number">-1e3</span>), gl::<span class="built_in">vec3</span>(max_x, max_y, max_z));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Rendering</tag>
      </tags>
  </entry>
  <entry>
    <title>Portfolio Site</title>
    <url>/2022/01/19/Portfolio%20Site%20Online/</url>
    <content><![CDATA[<p>Recently I began my Master application for 2022 Fall, and some of the universities, require the applicants to submit their portfolio in the form of personal website. I was intended to submit this site, however, this site only contains daily logs and technical topic posts. So I would rather create another website for my portfolio works.</p>
<p>After one afternoon’s work, new Portfolio Website was online, powering by Wix. Actually I found the Wix tool quite easy to use, only drags and drops are needed, just like what they’ve shown in the Youtube ads. The problem is, it’s not suitable for me to contantly update the contents since it tooks a lot more to render a single site in Wix. You have to drag and drop each paragraph yourself. However, it’s pretty easy to publish a post in Hexo. I can just use Typora and markdown to upload a post in seconds. Also, Wix doesn’t have good support for code snippets as the Markdown does. So I‘m just gonna post most of my daily thoughts and progresses here. And major works on the portfolio site.</p>
<p>I actually want to merge these two sites, this site and the portfolio site, into one. However, I find the two sites’ styles are quite different and I’m not interested in writing pieces of CSS code anyway. Maybe I will merge them someday.</p>
<p>Finally, if you are interested in my portfolio, check  <a href = "https://zhaonzh.wixsite.com/mysite-1">Portfolio Site</a>.</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>About Me</tag>
      </tags>
  </entry>
  <entry>
    <title>雨滴合成器/A Raindrop Synthesizer</title>
    <url>/2023/03/23/%E9%9B%A8%E6%BB%B4%E5%90%88%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>​        这学期的Audio Programming课写了一个雨滴合成器作为最终作业，期间因为种种原因代码改了好几个版本，现在的版本效果算是差强人意。虽然结果不是尽善尽美，整个迭代的过程还是值得记录的，如此也就有了这篇博客。</p>
<h4 id="为什么想做雨滴合成器？"><a href="#为什么想做雨滴合成器？" class="headerlink" title="为什么想做雨滴合成器？"></a>为什么想做雨滴合成器？</h4><p>​        这学期的其中一个作业是复现一篇1984年的physcally-based synthesizer (Karplus-Strong model). 简单来说，就是基于物理规则对声音进行建模，例如市场上有物理建模钢琴<code>pianoteq</code>，据说声音可以媲美昂贵的采样音源，而且体积非常小巧。对钢琴来说，物理建模就需要包括琴槌的属性，琴槌击弦发声的过程，以及声音在钢琴腔体内的传播等等。每一个步骤都会涉及到非常复杂的推导过程，所以不适合数学不好的我（悲）。</p>
<p>​        我觉得这种物理建模合成器非常神奇，不需要预录好的audio sample也可以产生出非常真实的声音，因此，我想试一试能不能做一个简单的物理合成器。然后我就选择了雨滴合成器。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>​        既然想要基于物理，就得找到合适的公式。在参考了一圈之后，我找到了这篇04年的论文。</p>
<blockquote>
<p><a href="http://huelights.com/docs/P_169.pdf">http://huelights.com/docs/P_169.pdf</a></p>
</blockquote>
<img src="https://s2.loli.net/2023/03/24/rcQSwlteACn2TvN.png" alt="image-20230323223922933" style="zoom:33%;" />

<p>​        其中，作者给出了以上的波形图。雨滴的波形通常可以分为两个不同的阶段：第一阶段，水滴打到硬表面。第二阶段，水滴打到湿表面，逐渐衰减。整个过程约持续10-20 ms。</p>
<p>​        其中，第一阶段的波形由以下公式给出:</p>
<img src="https://s2.loli.net/2023/03/24/v3HVjwd1l8JUkaM.png" alt="image-20230323224134739" style="zoom: 50%;" />

<p>​        其中，<code>p</code>代表在<code>t</code>时间点,<code>H</code>的高度上雨滴产生的声压，而右侧参数多到让人直接昏厥。虽然形式看起来很复杂，但是大部分都是固定的参数。例如<code>c</code>代表声音的传播速度,<code>v_term</code>代表雨滴的终止速度等等。假设聆听者的高度<code>H</code>固定为1.85m (是谁的身高？)，那么整个函数其实只和时间<code>t</code>有关，我们只需要给定一个时间，函数就会返回声压级，这个声压级也就可以近似认为是这个时间点的响度。</p>
<p>​        第二阶段如下给出：</p>
<p>​    <img src="https://s2.loli.net/2023/03/24/fOt5SzgyXlrA287.png" alt="image-20230323224924652" style="zoom: 50%;" /></p>
<blockquote>
<p> 给定时间<code>t</code>和某个水波形状相关参数<code>l</code>，这一时间点的声压如上，对应波形图的上下来回并衰减的部分。</p>
</blockquote>
<h4 id="有了公式，然后呢？"><a href="#有了公式，然后呢？" class="headerlink" title="有了公式，然后呢？"></a>有了公式，然后呢？</h4><p>​        有了公式之后，只要把这些公式写下来，给定时间，返回值就可以了吧？不行。</p>
<p>​        基于物理的建模虽然很精确，但是这得基于一个前提：参数是准确的。如果参数不准确，那么结果自然也不准确。而我恰好不知道怎样是好的参数。</p>
<p>​        例如我第一次应用第一阶段的公式的时候，整个第一阶段只能产生3-4个sample（以44100Hz的sample rate为例，也就是只有0.06 ms），仅仅三四个sample哪里有声儿啊。同理，第二阶段参数设置也很复杂。考虑到一个水滴的完整声波应该有10-20 ms，我显然搞错了参数，但我也不知道从哪个开始改起。</p>
<h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>​        现有公式参数太多了，让我不知从何下手。但至少我知道我波形图应该长什么样子，也知道整体的时长为10-20 ms。我们可以直接使用参数更少的波形去近似复杂的公式，同时让结果尽可能接近给定的波形图。</p>
<p>​        在这样的想法下，第一阶段的函数被简化为了:</p>
<img src="https://s2.loli.net/2023/03/24/kGK83WihZf2XmHS.png" alt="image-20230324012054270" style="zoom:50%;" />

<blockquote>
<p>其中<code>A0</code>用于控制响度，<code>k</code>用于控制波形的宽度，而<code>s</code>用于控制水滴发声的时间。</p>
</blockquote>
<p>​        同理，第二阶段的函数也被简化成了:</p>
<img src="https://s2.loli.net/2023/03/24/tsajbyK821pnQJS.png" alt="image-20230324011547436" style="zoom: 50%;" />

<blockquote>
<p>其中<code>A1</code>用于控制响度，<code>m</code>用于控制响度衰减的速度，<code>f</code>用于控制衰减的频率，<code>q</code>用于控制水滴发声的时间。</p>
</blockquote>
<p>​        这是近似后产生的波形图，和给定的波形图是比较相似的。而且这一近似模型参数较少，易于控制。所以在实现的时候我就采用了这个近似模型。</p>
<img src="https://s2.loli.net/2023/03/24/HEfziy7sa2hIRl3.png" alt="image-20230323232308569" style="zoom:33%;" />



<h4 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h4><p>​        前景提要：音频计算通常是以block_rate为单位，一个block通常含有512个samples，在audio programming中每一个sample通俗理解就是一个时间点的数值。计算时基本上是一次性计算512个samples，然后再播放这512个samples，以此往复。</p>
<ul>
<li><strong>Amplitude Normalize</strong></li>
</ul>
<p>​        既然是雨滴生成器，那一滴雨肯定不够。怎么说也得每秒来一千个水滴吧？我给每个雨滴设置了不同的起始时间，使得这些雨滴均匀分布在1秒内。尝试一番后，我试着输出每个时间点t（也就是一个sample）的数值，发现有不少的sample数值大于30或小于-5。通常来说，每个sample的result都应该被限制在[-1,1]之间，否则就没有意义。因此，我需要对所有的samples进行normalize。直接clamp/cutoff肯定不行，这样会损失掉samples之间相对大小的信息。我采取的方法比较简单，先记录下所有的sample数值，并找到其中绝对值的最大值，然后每个数除以这个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(std::vector&lt;<span class="keyword">float</span>&gt; &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> max_abs = *std::<span class="built_in">max_element</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), [](<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">                                     &#123; <span class="keyword">return</span> std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : result)</span><br><span class="line">    &#123;</span><br><span class="line">        elem /= max_abs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子来说，<code>&#123;10.0,-20.0,-30.0&#125;</code>的结果在normalize之后应该是<code>&#123;1/3,-2/3,-1&#125;</code>。</p>
<p>​        这样做有一个问题，音频的计算通常是以block_rate / sample_rate 作为单位，也就是说需要在512/44100 秒内完成计算。==由于我无法提前得知1秒内的最大绝对值==，因此只能提前计算完1秒内所有的samples (44100个samples，每个sample可能有几百个水滴，需要在512/44100秒内完成计算)，找到max_abs，然后再对所有的samples进行处理。显然CPU是没有这样的速度的，audio thread会被block，从而听不到任何声音。</p>
<p>​        倘若采取<code>std::async</code>的方式进行异步计算，即每512/44100秒内，根据用户给定的参数，计算新的44100个samples的数值，当计算的thread完成后，现在的samples就会被替换成新的samples。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个block_rate完成如下计算</span></span><br><span class="line"><span class="keyword">auto</span> future = std::<span class="built_in">async</span>(std::launch::async, &amp;Raindrops::recompute, <span class="keyword">this</span>, randomness-&gt;<span class="built_in">get</span>(), density-&gt;<span class="built_in">get</span>(), decay_frequency-&gt;<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.<span class="built_in">getNumSamples</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    left[i] = <span class="built_in">soft_clip</span>(drops-&gt;<span class="built_in">next_sample</span>(start_sample, end_sample) * <span class="built_in">dbtoa</span>(gain-&gt;<span class="built_in">get</span>()));</span><br><span class="line">    left[i] = <span class="built_in">mix</span>(left[i], last_sample, <span class="number">0.5f</span>);</span><br><span class="line">    right[i] = left[i];</span><br><span class="line">    last_sample = left[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//recompute会替换当前雨滴的sample,并使用std::mutex上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recompute</span><span class="params">(<span class="keyword">float</span> rnd, <span class="keyword">float</span> ds, <span class="keyword">float</span> d_freq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    drops = std::make_unique&lt;Drops&gt;(rnd, ds, <span class="number">0.0</span>, <span class="number">4.0</span>, d_freq, <span class="number">2.0</span>);</span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由于不知道什么时候可以计算完（通常都比较慢），用户变更参数就会变得非常不灵敏，通常都得等上一段时间才会播放最新计算出来的samples。</p>
<p>​        现在我们陷入了两难，不计算1秒内所有的samples，我就不能知道最大绝对值，也就不能normalize，提前计算好1秒内所有的samples又实在太慢。有没有什么两全其美的办法呢？用running max替代global max。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#每个<span class="function">sample <span class="title">time</span><span class="params">(<span class="number">1</span>/<span class="number">44100</span>秒)</span> 进行如下计算</span></span><br><span class="line"><span class="function">result </span>= drops-&gt;<span class="built_in">sample_at</span>(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(res) &gt; <span class="built_in">fabs</span>(running_max))</span><br><span class="line">&#123;</span><br><span class="line">	running_max = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = res / <span class="built_in">fabs</span>(running_max);</span><br></pre></td></tr></table></figure>

<p>​        之前我们需要预计算是因为我们希望使用global max进行normalize。假设我们采用running max，那么就不需要提前计算1秒的所有samples，我们只需要每个时间点计算出一个值，更新running max，再除以running max就可以了。</p>
<ul>
<li><strong>Inter-block Cutoff</strong></li>
</ul>
<p>​        由于不需要知道global max，我们计算的逻辑已经从每个block_rate (512/44100秒)计算1秒的所有samples (44100个)变成了计算每个block 的所有samples (512个)。这个量级基本可以实现实时计算了。但另一方面，由于每block_rate就会计算出512个新的samples，samples的更新速度非常快。那么就有可能存在以下的情况：</p>
<p>​        在上一个block中，有一个水滴在还在第一阶段，并且没有结束第一阶段，所以按理来说，到下一个block的时候，上一个水滴应该继续第一阶段的波形。但是==由于计算一个新的block时会重新初始化所有的水滴(reset水滴的timer)==，那么不同的block之间就变得完全无关了。可能上一个block中某个水滴还在第一阶段，一到下一个block这个水滴却还没有进入第一阶段。这种跨越block时的不连贯我暂且称其为<code>inter-block cutoff</code> 。我总觉得这里应该配张图才能更好解释这个概念，不过后面再说吧。</p>
<p>​        总之作为结果，这种不连贯会产生一种click的效果，听起来比较像鼠标按左键的声音。</p>
<p>​        既然计算新的block时初始化所有的水滴会导致这样的不连贯性，那么只要不初始化不就行了吗？之所以我们需要初始化所有的水滴，是因为如果不初始化，按照当前设置的参数，所有的水滴只会均匀分布在0-1s的时间轴上，因而一旦时间超过1秒，所有的水滴都不会产生声音。而初始化所有的水滴就能reset时间轴，从而能够实现持续播放的效果。</p>
<p>​        想要保持连贯，那么我们就需要保证在新的block开始时，每一个水滴的timer和上一个block结束时的timer只差了一个sample_step（1/44100秒），也就是上一段中提到的“不初始化”。那么我们该怎样实现持续播放呢？注意到所有的水滴都只有可能在[0,1]的区间上发出声音，如果我们需要让模拟器持续发出声音，那么每个水滴的时间轴就需要在这个区间上循环。如果重置时间轴发生在第一个阶段中或者第二个阶段中，那么就会产生cutoff，我们只需要确保重置时间轴时，水滴已经结束第一或者第二阶段（即不发出声音），此时，由于重置前后结果都为0，也就没有了cutoff带来的click效果。</p>
<h4 id="可以控制的参数："><a href="#可以控制的参数：" class="headerlink" title="可以控制的参数："></a>可以控制的参数：</h4><p>​        在这个插件中，你可以调整这些参数来产生不同的效果</p>
<ul>
<li><p>Gain - Overall audio gain</p>
</li>
<li><p>Density - How many drops in one second</p>
</li>
<li><p>Freq Coeff - Controls overall frequency</p>
</li>
<li><p>Interval Coeff - Controls average duration of drops</p>
</li>
<li><p>Noise Level - White noise level</p>
</li>
<li><p>High pass filter and Low pass filter</p>
<ul>
<li>12dB / Oct</li>
</ul>
</li>
</ul>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>​        其实在写代码之前，用Max做了一个雨声生成器的原型，思路来自于以下这篇文章。里面提到procedural的雨声可以由高频的烧水声+中频的烧水声+噪声+单独的水滴声组合而成。现在雨滴合成器可以通过调整参数实现一层烧水声+一层噪声的组合。理论上只要开2-3个雨滴合成器的instance，调整合适的参数后再按一定比例混合起来，就可以实现更为逼真的程序化的雨声了。</p>
<blockquote>
<p> <a href="https://blog.audiokinetic.com/zh/generating-rain-with-pure-synthesis/">https://blog.audiokinetic.com/zh/generating-rain-with-pure-synthesis/</a></p>
</blockquote>
<p>​        后面可能也许会考虑直接在插件里面写两个instance，然后用户可以直接控制每个instance的参数。另一方面还希望可以加一点UI，以及莫名出现的seg fault也需要debug。</p>
<h4 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h4><p>​        这是小玩具的地址，需要用到JUCE submodule，有兴趣的可以试一试。</p>
<p><a href="https://github.com/747745124/Raindrop-Generator">https://github.com/747745124/Raindrop-Generator</a></p>
]]></content>
      <categories>
        <category>Audio Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Audio Programming</tag>
        <tag>JUCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Point Matching - Voting Tree</title>
    <url>/2022/01/17/Point%20Matching%20-%20A%20Voting%20Tree%20Method/</url>
    <content><![CDATA[<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><h3 id="Point-Matching-Problem"><a href="#Point-Matching-Problem" class="headerlink" title="Point Matching Problem:"></a><strong>Point Matching Problem:</strong></h3><p>Given two polygons (each is defined by set of points), return the <strong>best point matching</strong> between the polygons.</p>
<p>To give you a better idea of what a point matching may be look like, here’s an example:</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<p>You can tell that, the match  (a,p), (b,r), (c,q) is not a good match, because $\angle A \ll \angle P$.</p>
<p>In this case, since $ \triangle ABC \sim \triangle QRP$, so we get a good match <code>(c,p),(b,r),(a,q)</code></p>
<p>But you may ask, <strong>Is that match the best match? What is a best matching mathematically?  What if there’s no mathematically similar polygons?</strong>  Well, these problems can be solved by giving our definition of “Good Match”. Through this case, you may get a sense of what is a good match, that is,  <strong>we can define the how well a match is by the similarity between matching points.</strong></p>
<p>A mathematic description is given as below.</p>
<h3 id="Good-Matching"><a href="#Good-Matching" class="headerlink" title="Good Matching:"></a>Good Matching:</h3><h4 id="Similarity-Function"><a href="#Similarity-Function" class="headerlink" title="Similarity Function:"></a>Similarity Function:</h4><p>Follow the principle that: <strong>Define how well a match is by the similarity between matching points.</strong> We have to firstly define a similarity function between two sets of points.</p>
<p>Referencing the similarity function from: <a href="https://ieeexplore.ieee.org/abstract/document/511850"><strong>Zhang Yuefeng. A fuzzy approach to digital image warping. IEEE Computer Graphics and Applications, 1996, 16(6):34~41</strong></a></p>
<p><img src="https://i.loli.net/2021/10/21/vt9GwTJgcPCzl8u.png" alt="image-20211021221008037"></p>
<p>Let’s take a look at the similarity function.</p>
<p>Suppose we have two triangles, edges and angles are denoted as above. The Similarity between these two triangles are defined as above. Note that the Similarity Function has two terms:</p>
<ul>
<li><strong>The Edge similarity term:</strong> measures the similarity with respect to length of edges</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/kqYUpSzE3cO9iBj.png" alt="image-20211021225903082" style="zoom:50%;" />

<ul>
<li><strong>The Angle similarity term:</strong> measures the similarity with respect to angle</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/oBhWea6fQLSIHGq.png" alt="image-20211021230014758" style="zoom:50%;" />

<p>The similarity value is the weighted sum of the two similarity term, by default, we set both weight to 0.5, i.e. $w_1 = 0.5,w_2 = 0.5$.</p>
<p>It’s pretty obvious that, the higher the value is, the higher the similarity is.</p>
<p>$Similarity(T_1,T_2) ==1 \iff T1\triangleq T2$</p>
<h4 id="What-is-a-best-matching"><a href="#What-is-a-best-matching" class="headerlink" title="What is a best matching?"></a>What is a best matching?</h4><p>Now we know that, what means a good matching between two triangles.</p>
<p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y)), where\ X.size== Y.size==3)$</p>
<p><strong>Note that, the higher the similarity function value, the better the matching is.</strong>  In this way, to find out the best triangle matching, we only have to find out two ordered sets of point pairs (with a size of 3), which have the highest similarity function value. And such pair is the best matching by our definition.</p>
<p>Actually, we can extend this Similarity Function to polygons with more than 3 edges.</p>
<h4 id="Best-matching-mathematically"><a href="#Best-matching-mathematically" class="headerlink" title="Best matching, mathematically"></a>Best matching, mathematically</h4><p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y))$</p>
<p>$where\ X.size== Y.size==min(A.size(),B.size())$</p>
<p>The Similarity of between 2 size n sets match is defined as below:</p>
<img src="https://i.loli.net/2021/10/22/nuXArDg2wFjoEYT.png" alt="image-20211022000404251" style="zoom:50%;" />

<p>Which is simply the <mark>average of all correspoding triangles’ similarity.</mark> (T means Triangle)</p>
<h4 id="Match-Representation-Tree"><a href="#Match-Representation-Tree" class="headerlink" title="Match Representation: Tree"></a>Match Representation: Tree</h4><p>To find out the best possible match, we have to traverse all possible match sequence, but how do we represent an ordered match between two sets of points?  The answer is tree.</p>
<p>We use a tree node, formed by a point pair to denote a possible match. So a possible node is <code>(a,p)</code>, and there’s <code>m*n</code> (<code>m = setA.size()</code>, <code>n = setB.size()</code>) possible nodes in total. And the children of node <code>(a,p)</code> should be next possible match, in this case, if we only take clockwise move into account, the next possible match is either <code>(c,r)</code> or <code>(c,o)</code>.</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<h5 id="You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule"><a href="#You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule" class="headerlink" title="You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule."></a>You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule.</h5><h4 id="Yet-another-important-rule-Monotonous"><a href="#Yet-another-important-rule-Monotonous" class="headerlink" title="Yet another important rule: Monotonous"></a>Yet another important rule: Monotonous</h4><p>The word <strong>monotonus</strong>, in this context, meaning moving in the same direction from begining to the end. This means that, you can’t go from r to q (clockwise), and then go from q to o (counter-clockwise). Think about it, a matching subsequence <code>(c,r)(b,q)(a,o)</code> breaks the rule of monotonicity. If you connect $RQ$ and $QO$, you will find that $RQ$ overlaps with $QO$.</p>
<p>In fact, you will find out that generally, if a set of points is not connected in a monotonous order (in the same direction), overlapping and crossing edge could happen.</p>
<img src="https://s2.loli.net/2022/01/17/2YjmF46IlrqugKx.png" alt="PNG图像" style="zoom:50%;" />

<p>So inorder to conform to the monotonous rule, the point matching should be move in a certain and unchanged direction, either clock-wise or counter clockwise.<mark> For simplicity, we assume both of the polygons moves clockwise.</mark> <strong>( This leaves a problem in the case of mirrored polygon matching, because in mirrored polygons, two polygons are connected in different direction )</strong> </p>
<p>Although we can simply don’t take mirrored polygons into account, an intuitive concept solution is given at the end of the report.</p>
<p>Since we only allow clockwise moves, <code>(a,p)(c,q)</code> is not a valid match sequence. </p>
<h4 id="How-many-starting-node"><a href="#How-many-starting-node" class="headerlink" title="How many starting node?"></a>How many starting node?</h4><p>On first thought, you may assume that there’s <code>m*n</code> (<code>m = setA.size(), n = setB.size()</code>)  starting point. However, <strong>the nodes in the triangle are logically equivalent.</strong> In the example, setA has a fewer size of 3, which means in next possible match, the first polygon can only move one step clockwise. And you may already find that, once the starting point of polygon A is fixed, the possible match sequence of A is fixed. However, there’s 4 different possibilities of polygon B with a fixed starting point.</p>
<p>So in this case, <strong>we actually have max(m,n) staring nodes</strong>. And for simplicity, we assume that the polygon A always starts at point A.</p>
<h4 id="Sample-Case-Tree"><a href="#Sample-Case-Tree" class="headerlink" title="Sample Case Tree:"></a>Sample Case Tree:</h4><p>With all that being said, all possible match sequences in the sample case are show as tree below.</p>
<p><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2"></p>
<p>Now we may came up with different methods to find out the best matching, in this representation, <mark><strong>the highest average (or cumulative) similarity path from root to leaf</strong>. </mark>But firstly let me simply introduce some other related works.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Firstly give the number of indicies in each polygon, m and n. Then for next m+n line, each line is consist of x and y coordinate of the index (m first then n) . <strong>The points in each polygon are given in clockwise order, and indexed as 1、2、3…n</strong>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Return the best match in the form of (index1,index2) for m lines (suppose m&lt;n)</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#still the same sample, where line 1-4 are m1~m3, line 5-8 are n1~n4.</span></span><br><span class="line"><span class="comment">#the output (1,2)(2,3)(3,4) means m1 matches n2, m2 matches n3, m3 matches n4</span></span><br><span class="line"><span class="built_in">input</span>:</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">4.25</span> <span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line">output:</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Related-Problems-and-Algorithms"><a href="#Related-Problems-and-Algorithms" class="headerlink" title="Related Problems and Algorithms:"></a>Related Problems and Algorithms:</h3><p>In general, this is a 2D point set registration problem,  is the process of finding a spatial <a href="https://en.wikipedia.org/wiki/Mathematical_transformation">transformation</a> (<em>e.g.,</em> <a href="https://en.wikipedia.org/wiki/Scaling_(geometry)">scaling</a>, <a href="https://en.wikipedia.org/wiki/Rotation">rotation</a> and <a href="https://en.wikipedia.org/wiki/Translation_(geometry)">translation</a>) that aligns two <a href="https://en.wikipedia.org/wiki/Point_cloud">point clouds</a>. </p>
<p>Many different methods have been proposed to solve this problem, from Graph theory, machine learning, and each of them have a different cost function to achieve, in this case, the similarity function.</p>
<h4 id="For-other-algorithms-on-this-problem-Click-for-more"><a href="#For-other-algorithms-on-this-problem-Click-for-more" class="headerlink" title="For other algorithms on this problem (Click for more):"></a><a href="https://en.wikipedia.org/wiki/Point_set_registration#Correspondence-based_registration">For other algorithms on this problem (Click for more):</a></h4><ul>
<li>Iterative Closet Point</li>
<li>RANSAC</li>
<li>Fuzzy Graph Matching</li>
</ul>
<h3 id="Build-Environment-amp-To-Run"><a href="#Build-Environment-amp-To-Run" class="headerlink" title="Build Environment &amp; To Run:"></a>Build Environment &amp; To Run:</h3><p>See <a href="./code/README.md">./code/README.md</a><br>Recommend to open with Typora.</p>
<h3 id="Brief-Description-On-STL-Used"><a href="#Brief-Description-On-STL-Used" class="headerlink" title="Brief Description On STL Used"></a>Brief Description On STL Used</h3><ul>
<li>std::vector<ul>
<li>std::vector is a sequence container for <mark>dynamic size array</mark>.</li>
<li>Elements in vector can be accessed by [] operator, iterators, and offsets to pointers to elements.</li>
<li>The storage of vector is handled automatically, and usually extra memory is allocated for the growth of the vector.</li>
<li>Each time we insert a element to the vector, as long as the extra memory isn’t exhausted, we don’t need to reallocate memory (memory reallocation is expensive).</li>
<li>Time Complexity:<ul>
<li>Random Access: $O(1)$</li>
<li>Insertion or Remove at the end:$O(1)$</li>
<li>Insertion or Remove at the front: $O(n)$</li>
</ul>
</li>
</ul>
</li>
<li><code>std::function</code><ul>
<li><code>std::function</code> is a general wrapper for function, it can store any copyconstructible callable object.</li>
<li>Can be used to store lambda expressions, member functions etc.</li>
<li>One usage is to pass function to function (Like function pointers).<ul>
<li>It has no call overhead</li>
<li>It can capture context variables</li>
</ul>
</li>
</ul>
</li>
<li><code>std::pair</code><ul>
<li>This is used to store 2 different objects in a single unit.</li>
<li>Can be replaced by struct, but std::pair offers a easier way to do so.</li>
<li>To assign value a and b to a <code>pair&lt;int,int&gt;</code><ul>
<li><code>Pair = make_pair(a,b)</code>;</li>
</ul>
</li>
</ul>
</li>
<li><code>std::map</code> (Actually can be replaced by set or vector)<ul>
<li><p>This structure is used to store a key-&gt;value pair</p>
</li>
<li><p>The implementation of Red-Black tree ensures a key-sorted traversal order.</p>
</li>
<li><p>It is implemented by <strong>Red-black tree</strong></p>
<ul>
<li>Search:$O(log(n))$</li>
<li>Insert:$O(log(n))$</li>
<li>Space Complexity:$(O(n))$</li>
</ul>
</li>
<li><p>The basic properties of a red black tree</p>
<ul>
<li>It’s a <strong>self-balanced binary search tree</strong></li>
<li>Each node is either red or black</li>
<li>Root is black</li>
<li>external nodes are black</li>
<li>the children of a red node is black</li>
<li>Any path from external node to root, the number of black nodes along the path are the same.</li>
</ul>
<h4 id="A-sample-red-black-tree"><a href="#A-sample-red-black-tree" class="headerlink" title="A sample red-black tree"></a>A sample red-black tree</h4><img src="https://s2.loli.net/2022/01/17/mrOg85bEWHSvKIN.png" alt="image-20211028155810975" style="zoom:50%;" /></li>
</ul>
</li>
<li><code>std::chrono</code><ul>
<li>This library is used for tracking time with different type of precision.</li>
<li>An massive extension to the time.h</li>
<li><strong>system_clock</strong> offers a wall clock</li>
<li><strong>high_resolution_clock</strong> offers a clock with shortest tick period.</li>
<li><strong>duration</strong> to represent a interval of time.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-2-Algorithm-Specification-Description"><a href="#Chapter-2-Algorithm-Specification-Description" class="headerlink" title="Chapter 2:    Algorithm Specification Description"></a>Chapter 2:    Algorithm Specification Description</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h3><h4 id="Voting-Tree-Idea"><a href="#Voting-Tree-Idea" class="headerlink" title="Voting Tree Idea:"></a>Voting Tree Idea:</h4><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2" style="zoom:50%;" />

<p>Now we can introduce the idea of voting tree. Basically a voting tree is <strong>for each unique path from root to the leaf, if the node is present in the path, the point match presented by this node gets a vote</strong>. The higher votes a match get, the more likely this match could be true. For the tree above, $AP$  have 3 votes, $AR$ have 3 votes too, so does $AO$ …</p>
<p>Soon you will find that for this tree, each match have exactly 3 votes. We can’t get any information out of the tree. This is obvious becuase we haven’t use the point pair information stored at each node. We’re just doing arrangement and combinations now.</p>
<h4 id="Why-Pruning"><a href="#Why-Pruning" class="headerlink" title="Why Pruning?"></a>Why Pruning?</h4><p>If we don’t prune the tree (cut off some branches), the voting process can’t give us any useful information. So we have to prune the tree in advance, based on our similarity function. My prune idea is simple, compute the similarity between two triangles, formed by node, node-&gt;parent, node-&gt;child. If the similarity is above a certain threshold, meaning this tree extension could be valid, else, this tree extension is invalid.</p>
<h4 id="Prune-First-Round"><a href="#Prune-First-Round" class="headerlink" title="Prune: First Round"></a>Prune: First Round</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse from root to leaf</span><br><span class="line">    for each node(node.depth&gt;=2)</span><br><span class="line">		for each node.child</span><br><span class="line">		//means not similar enough</span><br><span class="line">    		if(similar(node.parent,node,node.children)&lt;threshold)</span><br><span class="line">    			invalidate(node.children)</span><br><span class="line">    			go deeper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>First round pruning under a high threshold, we only invalidate those nodes(depth&gt;=2)’ children.</p>
<p>In the best case, all nodes(depth&gt;=3) except the best matching has been invalidated.</p>
</blockquote>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%203.png" alt="PNG图像 3" style="zoom:50%;" />

<p><strong>Note that this is actually a greedy algorithm pruning, for each time we only consider the local similarity. And we only leave those branches with high similarity.</strong></p>
<h4 id="Prune-Second-Round"><a href="#Prune-Second-Round" class="headerlink" title="Prune: Second Round"></a>Prune: Second Round</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse from depth 2 leaves to root:</span><br><span class="line">	if(node has no valid children)</span><br><span class="line">		invalidate(node)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This is intuitive since if a node(non-leaf) doesn’t have valid children, meaning the match itself is also invalid. In best case, there is only one valid path from root to leaf.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/nDSgJsMRoz5TZaI.png" alt="PNG图像 4" style="zoom:50%;" />

<p>After the pruning, it’s obvious that, the path present yields a higher chance of best matching, so the tree can be used to vote. <strong>However, this algorithm relies heavily on the threshold, if the threshold is set low, it could produce wrong result, if set overly high, there could be no possible match.</strong> (Test on Part 3)</p>
<h4 id="Trivia"><a href="#Trivia" class="headerlink" title="Trivia:"></a>Trivia:</h4><p>We have 2 similar but slightly different ways to determine the best match after voting to get the 2  bonus points.</p>
<h3 id="How-to-Vote"><a href="#How-to-Vote" class="headerlink" title="How to Vote?"></a>How to Vote?</h3><p>The vote process is a little bit tricky, different nodes have different vote counts. Some of the nodes may appear many times in different unique paths, but many nodes (mostly leaf nodes) only appear once in unique path. If we implement the idea of “unique path”, we have to visit some node many times, this requires backtracking technique. <strong>If we calculate the vote counts of node in advance, we only need to visit each node once,</strong> and that is simple to achieve by level order traversal.</p>
<blockquote>
<p>Leaf node has exactly one vote count, and a non-leaf node.voteCount = sum(children.voteCount)</p>
<p>We have to compute from leaf to root.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/V4ocwS36LkT8dZj.png" alt="PNG图像 6" style="zoom:50%;" />

<blockquote>
<p>After computing vote counts, we just traverse the tree, and vote for the matching, we keep a voting table. Table[node]+=node.voteCount</p>
<p>A Voting Table corresponding to the unpruned tree above.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/zWFoClXGudq4Q6L.png" alt="PNG图像 7" style="zoom: 50%;" />



<h3 id="How-to-decide-the-match-out-of-Voting-Table"><a href="#How-to-decide-the-match-out-of-Voting-Table" class="headerlink" title="How to decide the match out of Voting Table?"></a>How to decide the match out of Voting Table?</h3><p><strong>(Bonus is to have 2 different method determine the match)</strong></p>
<h4 id="Simple-Idea-Get-the-first-m-most-votes"><a href="#Simple-Idea-Get-the-first-m-most-votes" class="headerlink" title="Simple Idea:  Get the first m-most votes"></a>Simple Idea:  Get the first m-most votes</h4><blockquote>
<p>To use this method, #define _VOTE_ORDER</p>
</blockquote>
<p>Suppose we have a voting table like this, we have to decide the best match out of the table, we just order them by votes. The result would be <code>(a,q)(c,o)(c,r)</code>.</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%205.png" alt="PNG图像 5" style="zoom:50%;" />

<p>c appears twice in a matching sequence, so this simple idea is sometimes problematic for collision<code>(c,o)</code>and <code>(c,r)</code>, although this isn’t very likely to happen with a properly set threshold.</p>
<h4 id="An-Improved-Idea-for-anti-collision-Vote-By-Row"><a href="#An-Improved-Idea-for-anti-collision-Vote-By-Row" class="headerlink" title="An Improved Idea for anti-collision: Vote By Row"></a>An Improved Idea for anti-collision: Vote By Row</h4><blockquote>
<p>To use this method, #define _ROW_ORDER</p>
</blockquote>
<p>Instead of finding the global max votes, we find out most vote in each row, and in order to avoid collision on a column, after finding the most vote in the row, we set all votes in that column to 0.</p>
<img src="https://i.loli.net/2021/10/22/pZxH7veXsnEOjb9.png" alt="PNG图像 8" style="zoom:50%;" />

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h2><h3 id="Tree-Design"><a href="#Tree-Design" class="headerlink" title="Tree Design:"></a>Tree Design:</h3><p>Now we have to design our tree for implementation. Let’s think about what we need to keep in our tree.</p>
<ul>
<li><p>PointPairs (Storing 2 points’ coordinates)</p>
</li>
<li><p>Indices (2 points’ indices in their polygon)</p>
</li>
<li><p>Depth (In pruning, we have to check whether if a node is of depth 2 or deeper )</p>
</li>
<li><p>Count (Storing the vote count)</p>
</li>
<li><p>isValid (Check if this node need to be pruned or not, check if it is a valid match)</p>
</li>
<li><p>Children (Storing all of it’s children’s address)</p>
</li>
<li><p>Parent (When doing similarity function, we have to pass 3 adjacent nodes, it comes handy if we just pass node, node-&gt;parent, node-&gt;children)</p>
</li>
<li><p>Credit (How many possibilities this node can move, further explanation below)</p>
<blockquote>
<p>Credit indicates how many possibilities a node can move, if a node’s children moves one step, it cost no credit, if more than one step, it cost n-1 credits. The number of credits also indicates the number of children a node can have. </p>
<p>If a node has no credit, it can only move one step further thus have one child. Otherwise, it can move 1<del>n+1 steps, costing 0</del>n credits, thus having n+1 children.</p>
<p>An illustration is below to show the idea of credit.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/wVucOXPY7WM5vek.png" alt="PNG图像 9" style="zoom:50%;" /></li>
</ul>
<p>With credit, you can easily figure out how many children each node can have.</p>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode:"></a>TreeNode:</h3><p>This is all information tree node CR, contains (before pruning).</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%2010.png" alt="PNG图像 10" style="zoom:50%;" />

<h3 id="Build-Tree-with-pruning"><a href="#Build-Tree-with-pruning" class="headerlink" title="Build Tree with pruning"></a>Build Tree with pruning</h3><p>Now we know that what a tree node is, we have to build the tree.</p>
<p>To get cut down time complexity, we can do pruning while building the tree.</p>
<blockquote>
<p>Assume m&lt;n, if not, swap them.</p>
</blockquote>
<ol>
<li><p>Firstly, we build the depth 1 nodes (initial match), given with n-m credits each.</p>
</li>
<li><p>For each depth 1 nodes we recursively build subtree by using helper function.</p>
</li>
<li><p>In the helper function, we pass in a node</p>
<ol>
<li>if the node reaches depth m, means a full match, return</li>
<li>if the node has no credit, means it can only move 1 step further, move, check similarity, if valid then extend and return, if not, don’t extend and return.</li>
<li>if the node has some credits, means it can have credits+1 children, for each children, check similarity, if valid, extend, and pass children to the helper function for recursive call. if not valid, don’t extend, check the next children.</li>
</ol>
</li>
</ol>
<h3 id="Futher-Pruning-Second-Round"><a href="#Futher-Pruning-Second-Round" class="headerlink" title="Futher Pruning (Second Round)"></a>Futher Pruning (Second Round)</h3><p>A top-down approach.</p>
<ol>
<li>Pass the node, if it has a valid children, it is valid. If not, set node.isValid to false, return.</li>
<li>For each children of the node, if it has a valid children, it’s valid. If it doesn’t have children and is depth&lt;m , meaning its children have been pruned while build tree, set node.isValid to false, return.</li>
<li>Recursively call this function step 1~2</li>
</ol>
<h3 id="Level-Order-Traversal"><a href="#Level-Order-Traversal" class="headerlink" title="Level Order Traversal"></a>Level Order Traversal</h3><p>To compute vote count bottom up, it would be convenient if we do level order traversal first.</p>
<p>We implement level order by 2 vectors, curr and next, indicating the nodes to process in this level and next level. We store the result in res vector. (<code>vector&lt;vector&lt;TreeNode*&gt;&gt;</code>)</p>
<ol>
<li>Push root node into curr</li>
<li>While(curr is not empty), push curr to res, traverse all nodes in curr, for each node, we push all its children to next, finally swap(curr,next).</li>
</ol>
<h3 id="Compute-Vote-Count"><a href="#Compute-Vote-Count" class="headerlink" title="Compute Vote Count"></a>Compute Vote Count</h3><ol>
<li>get level order traversal result</li>
<li>start from the last level if it’s valid it has 1 vote count.</li>
<li>For each level, it’s vote count equals to sum of its valid children’s vote count. Iteration ends at depth 1 (Don’t consider root)</li>
</ol>
<h3 id="Voting"><a href="#Voting" class="headerlink" title="Voting:"></a>Voting:</h3><ol>
<li>traverse the tree by level order</li>
<li>The corresponding <code>term +=voteCount</code><ol>
<li>RowOrder: For each row in the table, find the max, set column of max to zero</li>
<li>SimpleIdea: Find the m-most votes in the table.</li>
</ol>
</li>
</ol>
<h2 id="Solution-2-Non-Voting"><a href="#Solution-2-Non-Voting" class="headerlink" title="Solution 2: Non-Voting"></a>Solution 2: Non-Voting</h2><p>Because we apply greedy pruning to our tree, sometimes we may only get the local best match instead of global best. Remeber that, in chapter 1, our goal is to find a path from root to leaf,<mark> with a largest average similarity of corresponding triangles.</mark></p>
<p>In this method, we simply don’t prune, and while we building tree, we keep track of the cumulative similarities of corresponding triangles. <mark>And we get the global best by simply find out the leaf node which havethe largest cumulative similarity.</mark></p>
<p><strong>This method is not reliant on parameters, and ensures a global best match under our definition.</strong></p>
<h4 id="TreeNode-add-a-cumulativeSim-member"><a href="#TreeNode-add-a-cumulativeSim-member" class="headerlink" title="TreeNode: add a cumulativeSim member"></a>TreeNode: add a cumulativeSim member</h4><h4 id="BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity"><a href="#BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity" class="headerlink" title="BuildTree: Almost the same, without pruning, keep track of cumulative similarity"></a>BuildTree: Almost the same, without pruning, keep track of cumulative similarity</h4><h4 id="Further-Pruning-No-need"><a href="#Further-Pruning-No-need" class="headerlink" title="Further Pruning: No need"></a>Further Pruning: No need</h4><h4 id="Level-Order-Traversal-Same"><a href="#Level-Order-Traversal-Same" class="headerlink" title="Level Order Traversal: Same"></a>Level Order Traversal: Same</h4><h4 id="Get-Result"><a href="#Get-Result" class="headerlink" title="Get Result:"></a>Get Result:</h4><ol>
<li>For the last level of the level order traversal (which is actually all the leaf nodes):</li>
<li>Get the node with max cumulative similarity</li>
<li>Trace back this node until root.</li>
</ol>
<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><h3 id="Correctness-Validation-With-A-Strict-Threshold-0-9"><a href="#Correctness-Validation-With-A-Strict-Threshold-0-9" class="headerlink" title="Correctness Validation: With A Strict Threshold = 0.9"></a>Correctness Validation: With A Strict Threshold = 0.9</h3><h4 id="Case-1-Sample-Case"><a href="#Case-1-Sample-Case" class="headerlink" title="Case 1: Sample Case"></a>Case 1: Sample Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct"><a href="#ROW-ORDER-Correct" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/Wf4mdv6nYpXGLij.png" alt="image-20211023011656249"></p>
<h4 id="SIMPLE-IDEA-Correct"><a href="#SIMPLE-IDEA-Correct" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/hA8qgKXZjfJe27M.png" alt="image-20211023011856088"></p>
<h4 id="NON-VOTING-Correct"><a href="#NON-VOTING-Correct" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/yMLWOv2CGYBoT3w.png" alt="image-20211023011927482"></p>
<h4 id="Case-2-A-1x1-square-and-a-2x2-square"><a href="#Case-2-A-1x1-square-and-a-2x2-square" class="headerlink" title="Case 2: A 1x1 square and a 2x2 square"></a>Case 2: A 1x1 square and a 2x2 square</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-1"><a href="#ROW-ORDER-Correct-1" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/mw7N2y5vsAK4eXc.png" alt="image-20211023012132695"></p>
<h4 id="SIMPLE-IDEA-Wrong"><a href="#SIMPLE-IDEA-Wrong" class="headerlink" title="SIMPLE_IDEA: Wrong"></a>SIMPLE_IDEA: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/wVcTFonM4X6j3qC.png" alt="image-20211023012203375"></p>
<h4 id="NON-VOTING-Correct-1"><a href="#NON-VOTING-Correct-1" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/3YBdRvUhf8HNZe4.png" alt="image-20211023012224618"></p>
<h4 id="Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon"><a href="#Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon" class="headerlink" title="Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon"></a>Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-2"><a href="#ROW-ORDER-Correct-2" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="/Users/naoyuki/Library/Application%20Support/typora-user-images/image-20211023012422694.png" alt="image-20211023012422694"></p>
<h4 id="SIMPLE-IDEA-Correct-1"><a href="#SIMPLE-IDEA-Correct-1" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/msa17Due6tYdSJC.png" alt="image-20211023012443966"></p>
<h4 id="NON-VOTING-Correct-2"><a href="#NON-VOTING-Correct-2" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/ydZE2seXj1QNM9g.png" alt="image-20211023012508740"></p>
<h4 id="Case-4-Large-Number-M-21-N-28-performance-test"><a href="#Case-4-Large-Number-M-21-N-28-performance-test" class="headerlink" title="Case 4: Large Number(M=21,N=28), performance test"></a>Case 4: Large Number(M=21,N=28), performance test</h4><h4 id="ROW-ORDER-0-005-sec"><a href="#ROW-ORDER-0-005-sec" class="headerlink" title="ROW_ORDER: 0.005 sec"></a>ROW_ORDER: 0.005 sec</h4><h4 id="SIMPLE-IDEA-0-005-sec"><a href="#SIMPLE-IDEA-0-005-sec" class="headerlink" title="SIMPLE_IDEA: 0.005 sec"></a>SIMPLE_IDEA: 0.005 sec</h4><h4 id="NON-VOTING-7-81-sec"><a href="#NON-VOTING-7-81-sec" class="headerlink" title="NON_VOTING: 7.81 sec"></a>NON_VOTING: 7.81 sec</h4><h4 id="Case-5-Mirror-case"><a href="#Case-5-Mirror-case" class="headerlink" title="Case 5: Mirror case"></a>Case 5: Mirror case</h4><p>Test if the algorithm can get the best match if two polygons are mirrored to each other.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Not-Found"><a href="#ROW-ORDER-Not-Found" class="headerlink" title="ROW_ORDER: Not Found"></a>ROW_ORDER: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013827652"></p>
<h4 id="SIMPLE-IDEA-Not-Found"><a href="#SIMPLE-IDEA-Not-Found" class="headerlink" title="SIMPLE_IDEA: Not Found"></a>SIMPLE_IDEA: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013829051"></p>
<h4 id="NON-VOTING-Wrong"><a href="#NON-VOTING-Wrong" class="headerlink" title="NON_VOTING: Wrong"></a>NON_VOTING: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/JzEHr6eXlLbQok7.png" alt="image-20211023013749859"></p>
<p>A solution will be proposed in chapter 4.</p>
<h4 id="Correctness-Table-For-5-test-cases"><a href="#Correctness-Table-For-5-test-cases" class="headerlink" title="Correctness Table (For 5 test cases)"></a>Correctness Table (For 5 test cases)</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<h3 id="Hacking-Cases-During-Peer-Review"><a href="#Hacking-Cases-During-Peer-Review" class="headerlink" title="Hacking Cases During Peer Review"></a>Hacking Cases During Peer Review</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 11</span><br><span class="line">A:(-4,2)(-2,2)(-2,4)(-4,4)</span><br><span class="line">B:(-2 -2)(-1 -2)(-1 -1)(2 2)(4 1)(5 3)(3 4)(3 6)(1 6)(1 4)(-2 -1)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">(2 -4) (4 -4)(6 -2)(4 0)(2 0)</span><br><span class="line">(-5 5)(-8 2)(-8 -1)(-6 -1)(-6 -4)(-4 -4)(-4 -1)(-2 -1)(-2 2)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<blockquote>
<h3 id="Major-Problem"><a href="#Major-Problem" class="headerlink" title="Major Problem:"></a>Major Problem:</h3><ul>
<li>The NON_VOTING Method has a comparatively high correctness rate, but the problem is that, it has a high time complexity, which makes it very hard to handle large cases（Acceptable M,N&lt;25）.</li>
<li>The other 2 solutions has a somewhat simple and fast performance, but not that good in the correctness.</li>
</ul>
</blockquote>
<h3 id="Parameters-Test"><a href="#Parameters-Test" class="headerlink" title="Parameters Test:"></a>Parameters Test:</h3><p>Only run sample cases, set threshold differently.</p>
<ul>
<li>Threshold: 0.1<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.3<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.5<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.75<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.9<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Correct</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
</ul>
<p>A good general threshold would be around 0.8~0.9.</p>
<h4 id="Correctness-Table-For-5-thresholds"><a href="#Correctness-Table-For-5-thresholds" class="headerlink" title="Correctness Table: For 5 thresholds"></a>Correctness Table: For 5 thresholds</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
<th>Threshold</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.1</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.3</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.5</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>0.75</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>0.9</td>
</tr>
</tbody></table>
<h3 id="Extra-Comparison-with-Iterative-Closet-Points"><a href="#Extra-Comparison-with-Iterative-Closet-Points" class="headerlink" title="Extra Comparison with Iterative Closet Points:"></a>Extra Comparison with Iterative Closet Points:</h3><p>I tried with Python, using sklearn package to run this method. Using a 2 sets of 30 points. Find one number of pair. Feed the same data with voting tree, it can’t find a full match and thus return.</p>
<blockquote>
<p>The voting tree assumes a good matching with average similarity&gt;=threshold because our pruning.</p>
<p>The non_voting method, on the other hand, returns the best matching possible, though it can be lower than the threshold.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/eTJsu3D2RjxgPdm.png" alt="image-20211023014901237" style="zoom:50%;" />

<p>On a small set of data (e.g. the sample case), the ICP solution can’t converge due to small amount of set size. However, if provided with a reasonable similar point set with a medium size (say, over 30). ICP method is reliable.</p>
<p>Besides, ICP has another strength is that, it can return partial matching, when there’s not a full match, it will return a partial match instead.</p>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4:    Analysis and Comments"></a>Chapter 4:    Analysis and Comments</h2><h3 id="1-Build-Tree"><a href="#1-Build-Tree" class="headerlink" title="1.Build Tree:"></a>1.Build Tree:</h3><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ol>
<li>Build depth 1 children takes O(n) time, there are n nodes at depth 1.</li>
<li>Using build helper to recursively build subtree takes $ O(n*T_{helper}(X))$</li>
</ol>
<p>Since each node only takes O(1) to insert, the overall build tree time complexity equals to the number of nodes.</p>
<h4 id="The-number-of-nodes-are"><a href="#The-number-of-nodes-are" class="headerlink" title="The number of nodes are:"></a>The number of nodes are:</h4><p>$n<em>A^m_m = n</em>m!$</p>
<h4 id="Overall-Time-Complexity-Without-Pruning-O-n-m"><a href="#Overall-Time-Complexity-Without-Pruning-O-n-m" class="headerlink" title="Overall Time Complexity (Without Pruning): $O(n*m!)$"></a>Overall Time Complexity (Without Pruning): $O(n*m!)$</h4><blockquote>
<p>Actually <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The time complexity can be reduced to $O(n^2)$ , since there are  n*(n-m+1) nodes at depth 2 without pruning.</mark></p>
</blockquote>
<h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><p>The Space Complexity = RecursionDepth*Recursion_assisted_space + size of tree.</p>
<ul>
<li>Recursion Term: Recursion Depth = m (match at most m times)</li>
<li>$tree_size= n<em>m!</em>(node_size) = n*m!<em>O(n-m) = O(n^2</em>m!)$</li>
</ul>
<h4 id="Overall-Space-Complexity-Without-Pruning-O-n-2-m"><a href="#Overall-Space-Complexity-Without-Pruning-O-n-2-m" class="headerlink" title="Overall Space Complexity (Without Pruning): $O(n^2*m!)$"></a>Overall Space Complexity (Without Pruning): $O(n^2*m!)$</h4><blockquote>
<p>Samely <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The space complexity can be reduced to $O(n^3)$ , since there are $ n*(n-m+1)$ nodes at depth 2 without pruning. And each takes up to $O(n-m)$ space since it stores its children.</mark></p>
</blockquote>
<h3 id="2-Futher-Pruning"><a href="#2-Futher-Pruning" class="headerlink" title="2.Futher Pruning:"></a>2.Futher Pruning:</h3><h4 id="Time-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Time-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Time Complexity (With rigorous pruning while build tree):"></a>Time Complexity (With rigorous pruning while build tree):</h4><ol>
<li>In this step, we at most prune almost all nodes at depth 2 and some at depth 1, since if we use build-time pruning at step 1, most of nodes will not grow deeper than depth 2.</li>
<li>For each node, we check its children (n-m at most)  if its valid or not. And set isValid accordingly. </li>
</ol>
<ul>
<li>Number of check &lt;=$ (depth 1 +depth 2)<em>(n-m) = (n+n</em>(n-m+1))*(n-m) = $O(n^3)$</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-3"><a href="#Overall-Time-Complexity-O-n-3" class="headerlink" title="Overall Time Complexity: $O(n^3)$"></a>Overall Time Complexity: $O(n^3)$</h4><blockquote>
<p>If not doing a rigorous pruning step while building, it takes nearly <strong>O(n*m!)</strong> to do the pruning</p>
</blockquote>
<h4 id="Space-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Space-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Space Complexity (With rigorous pruning while build tree):"></a>Space Complexity (With rigorous pruning while build tree):</h4><ul>
<li>This step doesn’t need extra space for memoization. However, it takes space for recursion. The space complexity equals to the max depth of the recursion, which is $O(m)$, since we the most depth is no deeper than 2 because of build-time pruning, except the best match path, takes $O(m)$ space for recursion.</li>
</ul>
<blockquote>
<p>If not doing a rigorous pruning step while building, it still takes <strong>O(m)</strong> to do the pruning, since the max depth is still $O(m)$</p>
</blockquote>
<h4 id="Overall-Space-Complexity-O-m"><a href="#Overall-Space-Complexity-O-m" class="headerlink" title="Overall Space Complexity: $O(m)$"></a>Overall Space Complexity: $O(m)$</h4><h3 id="3-Level-Order-Traversal"><a href="#3-Level-Order-Traversal" class="headerlink" title="3.Level Order Traversal"></a>3.Level Order Traversal</h3><h4 id="Time-Complexity-With-rigorous-pruning"><a href="#Time-Complexity-With-rigorous-pruning" class="headerlink" title="Time Complexity (With rigorous pruning):"></a>Time Complexity (With rigorous pruning):</h4><ul>
<li>Level Order traversal visit each node only once, which takes O(1) time, there are O(n^2) nodes if pruned rigorously.</li>
<li>If not pruned rigorously, in worst case, it could produce a result of O(n*m!)</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m"><a href="#Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m" class="headerlink" title="Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$"></a>Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$</h4><h4 id="Space-Complexity-With-rigorous-pruning"><a href="#Space-Complexity-With-rigorous-pruning" class="headerlink" title="Space Complexity (With rigorous pruning):"></a>Space Complexity (With rigorous pruning):</h4><ul>
<li>Level Order Traversal stores each node, each takes up to O(n) space.</li>
</ul>
<h4 id="Overall-Space-Complexity-O-n-2-O-n-m"><a href="#Overall-Space-Complexity-O-n-2-O-n-m" class="headerlink" title="Overall Space Complexity:  $(O(n^2),O(n*m!))$"></a>Overall Space Complexity:  $(O(n^2),O(n*m!))$</h4><h3 id="4-Compute-Vote-Count"><a href="#4-Compute-Vote-Count" class="headerlink" title="4.Compute Vote Count"></a>4.Compute Vote Count</h3><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>This is similar to pruning step. We only compute those valid nodes, and check their children.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$"></a>Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$</h4><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>Space takes for recursion is the same as pruning step</li>
</ul>
<h4 id="Overall-Space-Complexity-O-m-1"><a href="#Overall-Space-Complexity-O-m-1" class="headerlink" title="Overall Space Complexity : $O(m)$"></a>Overall Space Complexity : $O(m)$</h4><h3 id="5-Voting"><a href="#5-Voting" class="headerlink" title="5.Voting"></a>5.Voting</h3><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>Once again, we traverse the tree, and each time we vote to either a map or 2D array.</li>
<li>There are up to $O(n*m!)$ nodes if not well pruned, but at least O(m) nodes.</li>
<li>If we uses a <code>std::map</code> for voting, this takes $O(log(n))$ time for insert, while 2D array only takes $O(1)$</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$"></a>Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$</h4><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>We keeps either a map or 2D array, the overall space is up to all possible pairs, which is <strong>n*m</strong>, <strong>but at least m</strong>, which means only one valid path after pruning.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m"><a href="#Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m" class="headerlink" title="Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$"></a>Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$</h4><h3 id="6-Decide-Match-Voting"><a href="#6-Decide-Match-Voting" class="headerlink" title="6.Decide Match (Voting)"></a>6.Decide Match (Voting)</h3><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>SIMPLE_IDEA searches the largest m element in the table, if use sorting, this could takes, O(nlogn) times where n is the number of nodes.</li>
<li>ROW_ORDER searches the largest element in each line, which takes O(n*m) times, since there’re n rows and m columns.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m"><a href="#Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m" class="headerlink" title="Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$"></a>Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$</h4><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps we use a vector to assist our 2D sorting. Which takes up to O(m) space.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-m"><a href="#Overall-Time-Complexity-O-m" class="headerlink" title="Overall Time Complexity : $O(m)$"></a>Overall Time Complexity : $O(m)$</h4><h3 id="7-Decide-Match-Non-Voting"><a href="#7-Decide-Match-Non-Voting" class="headerlink" title="7.Decide Match (Non Voting)"></a>7.Decide Match (Non Voting)</h3><h4 id="Time-Complexity-4"><a href="#Time-Complexity-4" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>We only visit leaf nodes and find out the node with maximum cumulative similarity.</li>
<li>And then we trace back to root from that node.</li>
<li>There are at most $(n*m!)$ leaf nodes at depth m, since we don’t prune in a non-voting method. Trace back only takes O(m) time.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-m"><a href="#Overall-Time-Complexity-O-n-m" class="headerlink" title="Overall Time Complexity: $O(n*m!)$"></a>Overall Time Complexity: $O(n*m!)$</h4><h4 id="Space-Complexity-4"><a href="#Space-Complexity-4" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps only takes constant space for storing the maximum cumulative similarity and its node..</li>
</ul>
<h4 id="Overall-Time-Complexity-O-1"><a href="#Overall-Time-Complexity-O-1" class="headerlink" title="Overall Time Complexity : $O(1)$"></a>Overall Time Complexity : $O(1)$</h4><h3 id="OVERALL"><a href="#OVERALL" class="headerlink" title="OVERALL"></a>OVERALL</h3><table>
<thead>
<tr>
<th align="left">SIMPLE_IDEA (USE MAP AND VECTOR)</th>
<th>ROW_ORDER(USE 2D VECTOR)</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>It’s pretty obvious that, if we apply set up a good threshold, the ROW_ORDER and SIMPLE_IDEA both can have great time complexity performance. While the NON_VOTING method is an exponential method although it ensures correctness.</p>
</blockquote>
<h3 id="Extra-How-to-solve-the-problem-of-Mirrored-Case"><a href="#Extra-How-to-solve-the-problem-of-Mirrored-Case" class="headerlink" title="Extra: How to solve the problem of Mirrored Case"></a>Extra: How to solve the problem of Mirrored Case</h3><p>The reason we don’t get a good match when facing the mirrored case is that, we assume both polygons move in the same direction. And the solution is simple. </p>
<p>We add another n nodes at depth one, assume those point pairs moves in opposite direction, assume the first move clockwise and the second move counterclockwise. In this way, we can fix the problem.</p>
<img src="https://i.loli.net/2021/10/23/dswPBx9S4plfatK.png" alt="PNG图像 11" style="zoom:67%;" />

<p>Nodes in red colors are indicating two polygons move in opposite direction, while the blue color ones move in the same direction. This address the mirror problem.</p>
<h2 id="Appendix-Source-Code-in-C-11"><a href="#Appendix-Source-Code-in-C-11" class="headerlink" title="Appendix:    Source Code (in C++11)"></a>Appendix:    Source Code (in C++11)</h2><h4 id="tree-hpp"><a href="#tree-hpp" class="headerlink" title="tree.hpp"></a>tree.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">structure of the treenode</span></span><br><span class="line"><span class="comment">@memebers:</span></span><br><span class="line"><span class="comment">pointPair(contains the pair of points)</span></span><br><span class="line"><span class="comment">indices(contains the indices of points)</span></span><br><span class="line"><span class="comment">count(how many votes this node have)</span></span><br><span class="line"><span class="comment">isValid(if this node is a valid match, used for pruning)</span></span><br><span class="line"><span class="comment">depth(depth of the node)</span></span><br><span class="line"><span class="comment">credits(how many credits this node can spend, see report for details.</span></span><br><span class="line"><span class="comment">basically, a node with n credits can have n+1 child)</span></span><br><span class="line"><span class="comment">parent(the parent of the node)</span></span><br><span class="line"><span class="comment">children(the children of the node,indexing by the number of children)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//default constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pointPair.first = <span class="built_in">Point</span>();</span><br><span class="line">        pointPair.second = <span class="built_in">Point</span>();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        isValid = <span class="literal">true</span>;</span><br><span class="line">        parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(Point &amp;a, Point &amp;b, TreeNode *parent, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, <span class="keyword">int</span> depth, <span class="keyword">int</span> credit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pointPair = std::<span class="built_in">make_pair</span>(a, b);</span><br><span class="line">        <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">        <span class="keyword">this</span>-&gt;depth = depth;</span><br><span class="line">        <span class="keyword">this</span>-&gt;credits = credit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//corresponding points&#x27; coordinates</span></span><br><span class="line">    std::pair&lt;Point, Point&gt; pointPair;</span><br><span class="line">    <span class="comment">//points&#x27; index respectively</span></span><br><span class="line">    std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//how many votes it has, valid leaf node has 1 vote</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//check if the match is valid</span></span><br><span class="line">    <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//the depth of current node</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//how many credits it can use</span></span><br><span class="line">    <span class="keyword">int</span> credits = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cumulative similarity along the path</span></span><br><span class="line">    <span class="keyword">float</span> cumulativeSim = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//parent node</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="comment">//we use points pairs&#x27; indices as key to get the TreeNode*</span></span><br><span class="line">    <span class="comment">//e.g. children[pair(1,2)] means get a children with pointsA[1] and pointsB[2]</span></span><br><span class="line">    std::map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, TreeNode *&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the structure of the tree</span></span><br><span class="line"><span class="comment">@members:</span></span><br><span class="line"><span class="comment">root (root of the tree)</span></span><br><span class="line"><span class="comment">m,n (the size of point sets)</span></span><br><span class="line"><span class="comment">buildTree (build tree of point sets, with some pruning)</span></span><br><span class="line"><span class="comment">printTree (print all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">invalidate (pruning step, see report for details)</span></span><br><span class="line"><span class="comment">levelOrder (get all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Tree</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees,but this time we don&#x27;t pruning, used for non-voting method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelperWithoutPruning</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// the children&#x27;s index, only move one step</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            <span class="comment">// ready to calculate similarity</span></span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">// set new child, and assign similarity</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            node-&gt;children[idx]-&gt;cumulativeSim = node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children, node with k credits can have k+1 children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">// first index only move one step</span></span><br><span class="line">                <span class="comment">// second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//generate new child</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//only nodes with depth&gt;2 have valid parent and child</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123; <span class="comment">//compute and assign similarity</span></span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    node-&gt;children[idx]-&gt;cumulativeSim += node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees</span></span><br><span class="line">    <span class="comment">//this is with build time pruning</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelper</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//check if the child is valid by comparing the triangle formed by point sets</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">//if similarity is below the threshold, don&#x27;t extend, set the node to invalid</span></span><br><span class="line">            <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if it has no children, this node itself is also not possible</span></span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if similarity is above the threshold, extend it with the last node</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">//second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//pruning step, if the depth of node is same of greater than 2</span></span><br><span class="line">                <span class="comment">//check 2 triangles form by its parent and child and itself are similar</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    <span class="comment">//if not similar, don&#x27;t extend</span></span><br><span class="line">                    <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it&#x27;s shallower or is similar, extend</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//check after the generate step, if the node have children</span></span><br><span class="line">            <span class="comment">//if it have no children, meaning the current match is invalid</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, with build time pruning.</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, but no pruning this time;</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTreeWithoutPruning</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper(without pruning) function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invalidate the node if it has no children, or all of its children are invalid</span></span><br><span class="line">    <span class="comment">//top-down</span></span><br><span class="line">    <span class="comment">//FURTHER PRUNING IN THE REPORT</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if the node has no children and it&#x27;s not a leaf</span></span><br><span class="line">        <span class="comment">//meaning that the node is invalid</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; node-&gt;depth &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has children</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//if some of its children are valid, the node should be valid</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = node-&gt;isValid || kv.second-&gt;isValid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this means the node has no valid children</span></span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;isValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invalidate the children of the node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">invalidate</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print tree node indices by level order, but only print those valid</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nodes = <span class="built_in">levelOrder</span>(root);</span><br><span class="line">        <span class="comment">//skip the dummy root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.first &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the nodes of trees by level order</span></span><br><span class="line">    vector&lt;vector&lt;TreeNode *&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;TreeNode *&gt;&gt; ans;</span><br><span class="line">        vector&lt;TreeNode *&gt; cur, next;</span><br><span class="line">        <span class="comment">//the nodes to process in current/next step;</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">push_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!cur.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">                    <span class="comment">//only process valid nodes</span></span><br><span class="line">                    <span class="keyword">if</span> (kv.second-&gt;isValid)</span><br><span class="line">                        next.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(cur, next);</span><br><span class="line">            next.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="geometry-hpp"><a href="#geometry-hpp" class="headerlink" title="geometry.hpp"></a>geometry.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">store the coordinate of a 2D point</span></span><br><span class="line"><span class="comment">With some computing method</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// format the point</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Some utility functions of Geometric computation</span></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threshold of similarity between two polygons</span></span><br><span class="line">    <span class="comment">// a good threshold is 0.7~0.9 in simple case</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> threshold = <span class="number">0.9f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    convert radians to degrees</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">toDegree</span><span class="params">(<span class="keyword">float</span> rad)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rad * <span class="number">180.f</span> / pi;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get length of the edge between two points;</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">(Point &amp;a, Point &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> dx = <span class="built_in">abs</span>(a.x - b.x);</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="built_in">abs</span>(a.y - b.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrtf</span>(dx * dx + dy * dy);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @description: a is in the middle of b and c</span></span><br><span class="line"><span class="comment">    this functions returns the angle CAB or simply angle A</span></span><br><span class="line"><span class="comment">    @assumption: assume convex polygon, only return non-reflex angle</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getAngle</span><span class="params">(Point &amp;a, Point &amp;b, Point &amp;c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> AB = <span class="built_in">getLength</span>(a, b);</span><br><span class="line">        <span class="keyword">float</span> BC = <span class="built_in">getLength</span>(b, c);</span><br><span class="line">        <span class="keyword">float</span> AC = <span class="built_in">getLength</span>(a, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> cosA = (AB * AB + AC * AC - BC * BC) / (<span class="number">2</span> * AB * AC);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">toDegree</span>(<span class="built_in">acos</span>(cosA));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    compute similarity between two sets of points(2 polygons)</span></span><br><span class="line"><span class="comment">    the sets should have the same size.</span></span><br><span class="line"><span class="comment">    For details, see report.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">similarity</span><span class="params">(vector&lt;Point&gt; &amp;a, vector&lt;Point&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        don&#x27;t take similarity between lines into account</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between edges</span></span><br><span class="line">        <span class="keyword">float</span> simLenUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> simLenLower = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[i], b[i + <span class="number">1</span>]);</span><br><span class="line">            simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">            simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//the last edge between the first and the last point</span></span><br><span class="line">        <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>]);</span><br><span class="line">        simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">        simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edge coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simLenUpper / simLenLower);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between angles</span></span><br><span class="line">        <span class="keyword">float</span> simAngUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[i], a[i + <span class="number">1</span>], a[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[i], b[i + <span class="number">1</span>], b[i - <span class="number">1</span>]);</span><br><span class="line">            simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//last 2 angles</span></span><br><span class="line">        <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>], a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        angA = <span class="built_in">getAngle</span>(a[n - <span class="number">1</span>], a[n - <span class="number">2</span>], a[<span class="number">0</span>]);</span><br><span class="line">        angB = <span class="built_in">getAngle</span>(b[n - <span class="number">1</span>], b[n - <span class="number">2</span>], b[<span class="number">0</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//angle coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simAngUpper / <span class="number">180.f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">USAGE ON MACROS:</span></span><br><span class="line"><span class="comment">_ROW_ORDER: VOTING TABLE ROW_ORDERED METHOD</span></span><br><span class="line"><span class="comment">_NON_VOTING: NON VOTING METHOD</span></span><br><span class="line"><span class="comment">_VOTE_ORDER: SIMPLE IDEA METHOD</span></span><br><span class="line"><span class="comment">_USER_INPUT: GET INPUT FROM USER</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AVAIABLE CASES:</span></span><br><span class="line"><span class="comment">    _SAMPLE_CASE1~4</span></span><br><span class="line"><span class="comment">    MIRROR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define _ROW_ORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAMPLE_CASE1</span></span><br><span class="line"><span class="comment">// #define _NON_VOTING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _VOTE_ORDER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TO USE: set C++ standard to C++11 or later</span></span><br><span class="line"><span class="comment">Read &quot;README.md&quot; first.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@params:levelOrder,votingTable,maxDepth</span></span><br><span class="line"><span class="comment">@return:isFullMatch</span></span><br><span class="line"><span class="comment">@description:1.compute how many votes each nodes has 2. visit each valid node, and vote</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">voting</span><span class="params">(vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;levelOrder, map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;table, <span class="keyword">int</span> maxDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//this means no path can be length m, meaning no full match</span></span><br><span class="line">    <span class="keyword">if</span> (levelOrder.<span class="built_in">size</span>() &lt; maxDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No Full Match Under Such Similarity Setting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check the degree of each node, and only visit each node once</span></span><br><span class="line">    <span class="comment">// leaf as one count</span></span><br><span class="line">    <span class="comment">// node.count = node-&gt;left.count+node-&gt;right.count;</span></span><br><span class="line">    <span class="comment">// compute from bottom up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute each node has how many votes,skip the dummy root</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = levelOrder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//leaf nodes has one vote</span></span><br><span class="line">            <span class="keyword">if</span> (levelOrder[i][j]-&gt;depth == maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                levelOrder[i][j]-&gt;count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//non-leaf nodes have vote equals to its all valid children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : levelOrder[i][j]-&gt;children)</span><br><span class="line">                levelOrder[i][j]-&gt;count += kv.second-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after computing how many votes each node has, we need to calculate the final vote count</span></span><br><span class="line">    <span class="comment">//voting process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; levelOrder.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            table[levelOrder[i][j]-&gt;indices] += levelOrder[i][j]-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two vectors to store input</span></span><br><span class="line">    vector&lt;Point&gt; pointsA;</span><br><span class="line">    vector&lt;Point&gt; pointsB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compute answer from user input</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USER_INPUT</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE1</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small square and a 2x square</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE2</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small triangle and a pentagon</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE3</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a large case to test speed performance (M=21,N=28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE4</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this actually got problems, but if we got a match, the overall polygon matching is actually correct,</span></span><br><span class="line"><span class="comment">//we only have to reorder the indices order</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIRROR</span></span><br><span class="line">    <span class="comment">// MIRROR Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureing pointsA always have smaller size</span></span><br><span class="line">    <span class="keyword">if</span> (pointsA.<span class="built_in">size</span>() &gt; pointsB.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    using map for voting table, where key is the point pair indicies</span></span><br><span class="line"><span class="comment">    here we have to use map instead of unordered_map</span></span><br><span class="line"><span class="comment">    because type(pair&lt;int,int&gt;) in C++ STL is not hashable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; votingTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Initialize Tree with given points array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Tree <span class="title">tree</span><span class="params">(pointsA.size(), pointsB.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in non voting method, we didn&#x27;t prune the tree</span></span><br><span class="line"><span class="comment">we calculate the the cumulative Similarity of all the leaf nodes</span></span><br><span class="line"><span class="comment">finding out the one with cumulative largest similarity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree without pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTreeWithoutPruning</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line">    <span class="comment">//leaf nodes are at the last level</span></span><br><span class="line">    <span class="keyword">auto</span> leaves = nodes[nodes.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compare and find out the node with largest cumulative similarity</span></span><br><span class="line">    <span class="keyword">float</span> maxSum = <span class="number">0.f</span>;</span><br><span class="line">    TreeNode *maxNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> leaf : leaves)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaf-&gt;cumulativeSim &gt; maxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = leaf-&gt;cumulativeSim;</span><br><span class="line">            maxNode = leaf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after finding the max cumulativeSimilarity</span></span><br><span class="line">    <span class="comment">//trace back bottom up, push the path to result</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (maxNode-&gt;parent != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(maxNode-&gt;indices);</span><br><span class="line">        maxNode = maxNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print out the path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + res[i].first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + res[i].second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="comment">//print time it takes</span></span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this contains build/prune/level order/vote 4 steps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree with build time pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTree</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// further pruning step</span></span><br><span class="line">    tree.<span class="built_in">invalidate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the valid nodes in the tree, for test</span></span><br><span class="line">    <span class="comment">// tree.printTree();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check if there&#x27;s a full match, also doing the voting</span></span><br><span class="line">    <span class="keyword">bool</span> isFullMatch = <span class="built_in">voting</span>(nodes, votingTable, pointsA.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if no full match, return with -1</span></span><br><span class="line">    <span class="keyword">if</span> (!isFullMatch)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a method ensuring no collision match, with possibility of wrong-matching but no collision</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _ROW_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; row_order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// we use a 2D matrix to represent the table</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            <span class="built_in">res</span>(pointsA.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(pointsB.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert the std::map into 2D vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : votingTable)</span><br><span class="line">        &#123;</span><br><span class="line">            res[kv.first.first][kv.first.second] = kv.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse each row, find out the max element</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; res[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the element has the most votes in the row</span></span><br><span class="line">                <span class="keyword">if</span> (res[i][j] == *<span class="built_in">max_element</span>(res[i].<span class="built_in">begin</span>(), res[i].<span class="built_in">end</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (verbose)</span><br><span class="line">                        <span class="comment">//print out the indicies</span></span><br><span class="line">                        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + j &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//disable the column, in case next row matches the same column</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop for k times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">row_order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//calculate the time performance</span></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this is the SIMPLE_IDEA in the report</span></span><br><span class="line"><span class="comment">//print m matches with top most votes, collision could happen with a low threshold</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _VOTE_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getting matches with order of votes, using with restrict threshold of similarity</span></span><br><span class="line">        vector&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            pairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert map to vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itr = votingTable.<span class="built_in">begin</span>(); itr != votingTable.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(*itr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sort voting table by its vote count</span></span><br><span class="line">        <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), [](pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;a, pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the first m highest votes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointsA.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop for loop_count times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST UTILITY FUNCTIONS</span></span><br><span class="line">    <span class="comment">// auto pp = root-&gt;children[make_pair(0, 0)]-&gt;children[make_pair(1, 1)]-&gt;pointPair;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pp.first.print();</span></span><br><span class="line">    <span class="comment">// pp.second.print();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::similarity(pointsA, pointsB) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::getAngle(pointsA[0], pointsA[1], pointsA[2]) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST INPUT</span></span><br><span class="line">    <span class="comment">// for (const auto &amp;point : pointsA)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     point.print();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DataStructure</tag>
        <tag>Point Matching</tag>
      </tags>
  </entry>
  <entry>
    <title>折叠表达式(Fold Expression)，低速下脚现代C++ Chapter 2 Exercise</title>
    <url>/2022/01/01/%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F(Fold%20Expression)%EF%BC%9A%E4%BD%8E%E9%80%9F%E4%B8%8B%E8%84%9A%E7%8E%B0%E4%BB%A3C++%20Chapter%202%20Exercise/</url>
    <content><![CDATA[<h3 id="折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise"><a href="#折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise" class="headerlink" title="折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise"></a>折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise</h3><p>最近在看高速上手现代C++，这是一本很不错的书，作者用仅80余页的长度介绍了C++自C++11以来至C++20带来的许多特性。这些特性给C++带来了语言可用性上的强化，运行期的强化 etc. 以及使得这门语言本身更好地支持例如函数式编程的范式。</p>
<p>每一章的结尾作者都会提供一些简单的小题目，其中第二章的小题目cover了折叠表达式(Fold Expression, since C++17)和结构化绑定（Structured Binding, since C++17）。在自己闲着摸索的时候发现了一个有意思的小事情，于是稍微写点东西记录一下。</p>
<blockquote>
<p>感觉光看这本书和课后的题的话，内容还是不太能掌握，可能跟着其他博客看一看会比较好。</p>
</blockquote>
<h3 id="为什么需要Fold-Expression"><a href="#为什么需要Fold-Expression" class="headerlink" title="为什么需要Fold Expression?"></a>为什么需要Fold Expression?</h3><p>模版是C++比较重要的一个板块之一，但是C++11之前，模版的参数数量是固定的。自从C++11之后，新引入的表示方法允许声明时引入任意数量的参数，即如下形式:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br></pre></td></tr></table></figure>

<p>有了可变长模版，我们就可以写一个允许任意长度参数的函数模版了。一个显而易见的好处是，我们可用这样的语法实现以下函数功能，并且只要写一个函数模版。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个函数模版 mean_val，接受任意长度的参数，返回平均值</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// return 2</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// return 3.5</span></span><br></pre></td></tr></table></figure>

<p>不过在C++17之前，这样的函数模版在解包(unpack)的时候会比较麻烦，因为我们在写函数模版的时候并不知道究竟会传几个参数进来，而参数包又不像是std::vector之类的容器有简单的方式进行遍历，因此我们对于函数参数的实际操作就变得比较麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如说我想实现max_val，但是我并没有直观的方式遍历args的内容</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//我该怎么获得args的内容呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过目前来说，我们可以通过sizeof… 来计算参数的个数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;std::endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// cout:3</span></span><br></pre></td></tr></table></figure>

<h4 id="一个比较常见的做法是利用递归来进行参数解包"><a href="#一个比较常见的做法是利用递归来进行参数解包" class="headerlink" title="一个比较常见的做法是利用递归来进行参数解包:"></a>一个比较常见的做法是利用递归来进行参数解包:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//书中的案例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt; <span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;<span class="comment">//每次取出一个T，然后递归再取出一个T</span></span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>); <span class="comment">//输出所有参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的确比较繁琐，而C++17中引入了一种比较简洁的方式来实现这种功能需求，这就是标题里的折叠表达式。</p>
<ul>
<li>考虑下面的代码，下面的函数模版可以实现任意长度立即数的求和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> <span class="comment">//C++14，函数返回值自动推断</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> (t + ...); <span class="comment">//折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过书中没有仔细讲这个折叠表达式的内容，因此原理上就有些不清晰，这里做一些补充。</p>
<h3 id="折叠表达式的语法："><a href="#折叠表达式的语法：" class="headerlink" title="折叠表达式的语法："></a>折叠表达式的语法：</h3><ul>
<li><code>pack op ...</code> (一元右折叠 / unary right fold)</li>
<li><code>... op pack</code> (一元左折叠 / unary right fold)</li>
<li><code>pack op ... op init</code> (二元右折叠 / binary right fold)</li>
<li><code>init op ... op pack</code> (二元左折叠 / binary left fold)</li>
</ul>
<p>其中，<code>pack</code>是参数包，即上述代码中的t，op即operator，支持32种二元运算符，例如<code>+,-,*,/</code> , <code>init</code>表示最后一层展开时二元运算符的另一个操作数。 其中在二元折叠中两个operator要保持一致。</p>
<h3 id="以上四个表达式和以下内容等价："><a href="#以上四个表达式和以下内容等价：" class="headerlink" title="以上四个表达式和以下内容等价："></a>以上四个表达式和以下内容等价：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(args op ...) &lt;-&gt; (arg1 op (arg2 op (arg3 op (... op (arg_n-1 op arg_n)))))</span><br><span class="line">(... op args) &lt;-&gt; (((arg1 op arg2) op ...) op arg_n)</span><br><span class="line">(args op ... op init) &lt;-&gt; (arg1 op (... op (arg_n−1 op (arg_n op init))))</span><br><span class="line">(init args op ... op ) &lt;-&gt; ((((init op arg1) op arg2) op ...) op arg_n)</span><br></pre></td></tr></table></figure>

<p>这么写可能还是有点晕，举两个例子可能更好:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">(args - ...) &lt;-&gt; (<span class="number">1</span> - (<span class="number">2</span> - <span class="number">3</span>))</span><br><span class="line">(<span class="number">3</span> - ... - args) &lt;-&gt; (((<span class="number">3</span><span class="number">-1</span>)<span class="number">-2</span>)<span class="number">-3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a></p>
</blockquote>
<p>下面是一个注意点，由于运算符优先级问题，第一种备注是掉的写法并不被接受，需要写成第二种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  return (args + ... + 1 * 2);   // Error: operator with precedence below cast</span></span><br><span class="line">    <span class="keyword">return</span> (args + ... + (<span class="number">1</span> * <span class="number">2</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作业题："><a href="#作业题：" class="headerlink" title="作业题："></a>作业题：</h3><p>利用折叠表达式写一个计算求均值的函数模版:</p>
<p>答案如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mean</span><span class="params">(T... t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mean</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure>

<h3 id="但是…"><a href="#但是…" class="headerlink" title="但是…"></a>但是…</h3><p>不知道为什么我突然想试着把 <code>+</code> 改成 <code>-</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t - ...)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; (<span class="number">1</span>-(<span class="number">2</span>-(<span class="number">3</span>-(<span class="number">4</span><span class="number">-5</span>)))) = (<span class="keyword">int</span>)<span class="number">3</span>/<span class="number">5</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个例子倒是没有问题，如果我改成左折叠:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">return</span> (... - t) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//output: 3689348814741910320</span></span><br></pre></td></tr></table></figure>

<p>这个一长串数字并不是随机数，运行了好几次都是同一个结果。但是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(... - t)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; ((((<span class="number">1</span><span class="number">-2</span>)<span class="number">-3</span>)<span class="number">-4</span>)<span class="number">-5</span>)/<span class="number">5</span> = <span class="number">-13</span>/<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>本应该输出-2才对，那么究竟是哪里出问题了呢？</p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>首先我查看了折叠表达式和<code>sizeof…(t)</code>的返回值，用lldb调试后发现数值没有问题，那么应该是除法这一步出了问题。</p>
<p><img src="https://s2.loli.net/2022/01/01/v2aCilBbDmuOLEj.png" alt="image-20220101230639043"></p>
<p>当我将p的类型从auto改为int之后，返回值就变成-2了：</p>
<p><img src="https://s2.loli.net/2022/01/01/16UWplfXmMLCNTv.png" alt="image-20220101230834880"></p>
<p>那么看来应该是<code>sizeof…</code>返回值的问题。</p>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>询问学长之后发现，<code>sizeof...</code>返回的是一个<code>size_t</code>类型的值，在64-bit操作系统中类型是<code>uint64_t</code>，即64位无符号整型。然后折叠表达式自动推断返回为int（<code>int32_t</code>), 二者做除法的时候int被提升到<code>uint64_t</code>，然后又因为负数的符号位在最高位，被转换成unsigned的时候，数值就变得非常大了。</p>
<p>可以具体算一下这个<code>3689348814741910320</code>的由来，结果是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-13 = (hex) FFFFFFFFFFFFFFF3 -&gt; 18,446,744,073,709,551,603</span><br><span class="line">int(18,446,744,073,709,551,603 / 5) = 3689348814741910320</span><br></pre></td></tr></table></figure>

<p>所以需要注意的是，一行的表达式，其实包含了一次类型推断和一次隐式类型转换，所以使用的时候需要比较小心一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//equivalent as below</span></span><br><span class="line"><span class="keyword">auto</span> p = (t + ...);</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="keyword">return</span> p/i;</span><br></pre></td></tr></table></figure>

<p>等我看完Chapter 4的时候可能会再来写一点内容，感觉还是得一边看一边跟着例子写一点才好。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>One day in Monterey</title>
    <url>/2023/06/20/One%20Day%20in%20Monterey/</url>
    <content><![CDATA[<h3 id="One-day-in-Monterey"><a href="#One-day-in-Monterey" class="headerlink" title="One day in Monterey"></a>One day in Monterey</h3><p>​    因为赶着要去实习(在San Jose)，Path Tracer的作业又拖到最后一天才交，上学和实习便几乎是无缝衔接了。具体衔接得有多紧密呢？我18号中午提交完作业，20号就要开始实习。实习的公司距离学校很远，开车要4.5小时。即使我想一天冲到实习期间的住处，房东也只有19号才有空，这就意味着我只能19号到San Jose，第二天便直接迎接实习生活了。</p>
<p>​    既然不能一天狂奔到公司，我就估摸着中间找个地方休息一天。南加州和北加州中间选哪呢？San-Luis-Obispo，感觉没什么好玩的，pass。Santa Maria，感觉和Santa Barbara（我学校在的地方）差不多，pass。其他地方感觉也没有什么特别的，也许是加州的小城市都大同小异吧？最后我选择Monterey的原因是1. 听说水族馆很漂亮，是美国第二大的水族馆（第一大在Atlanta）2. macOS 12.0的版本好就是Monterey 3. 有一次在学校旁的iHop吃饭，有一位阿姨说自己住在Monterey，她今天把孩子接回去。稍微聊了几句之后，她便结账离开了。后来我才知道，她也帮我买了单。</p>
<p>​    选定好地点之后，选择酒店也是纠结了许久。难得出来玩一趟，总得住点好的吧，这可不得Hilton, Hyatt定起来？可是看到Hyatt Regency 358刀一晚的价格的时候，还是一下就退缩了。最终我选择了一个110刀的汽车旅馆，差不多是这个区域里最平价的住处之一了，虽然不如高端酒店豪华，但是评分竟也有8.8，Hyatt Regency评分也不过9.0。就当我怀疑是不是旅馆老板疯狂刷单做评分的时候，我的手已经按下了付款键。</p>
<p>​    万事俱备，18号交完作业，再次检查行李，加完油，洗车，出发！</p>
<p>​    沿着101公路一路向北开了1个多小时之后，我的肚子就饿得不行了，毕竟那时已经下午4点半，而我一天都没有吃东西。最后就近下高速，路边找了个麦当劳，点了个巨无霸，麦乐鸡一顿狂吃。啊～活过来了。</p>
<p>​    再往北开2小时，路上许多飞虫会撞向挡风玻璃，这也就意味着，我的车白洗了。除开这个点，路上的风景倒是很多样，有峡谷，有农田，有沙丘。整体路况而言还可以，大多数时候能开到70-80 mph (国内112-128码)。下午7:30，开到了！在一家中餐馆简单解决晚饭后，我便开回酒店，准备第二天前往水族馆。</p>
<p>​    <img src="https://s2.loli.net/2023/06/20/oITjcvFuNDAkHyG.png" style="zoom:50%;" /></p>
<blockquote>
<p>中餐馆 (Full Moon Chinese Restaurant) 的蟹黄豆腐，他们家分量太足了，饭是用平底的碗装的，差不多是平时2人的量。</p>
</blockquote>
<p>​    回去的路上，车辆一直在提示玻璃水不足，我便去加油站的超市里买了一瓶玻璃水。回到酒店的时候，便尝试打开引擎盖，自己添加玻璃水。结果我竟然连怎么打开引擎盖都不会！为了避免行驶过程中汽车引擎盖弹起，汽车引擎盖通常是双层解锁设计，不仅需要车内拉动开关，还需要拉动引擎盖内的锁扣，才能完全解锁。我按照教程摸了半天上方的锁扣，却完全是抓瞎。无奈之下，只能求助于一旁的酒店工作人员，没想到他三下五除二就帮我打开了汽车锁扣——原来我的车的锁扣设置在引擎盖下方。接下来，他熟练地帮我加完玻璃水，此时，我内心的崇拜之情已经无以言表。就在我以为一切完美结束的时候，我才发现引擎盖关不上了，准确来说，是引擎盖的锁扣坏了。酒店人员看到这种情况后，他也尝试着帮我复位锁扣，可惜不管如何拨动都于事无补。他向我指了一个附近的修车店，并告知我“这种情况下千万不能上高速，因为有可能引擎盖会弹起来，挡住视线”。我很无奈，却也只能回到房间，准备第二天一早去维修店碰碰运气。睡觉之前，我不甘心，再去试试把引擎盖压回原位，依然是没有成功。</p>
<p>​    第二天一早，我便开车去了一个最近的修车店。店内清一色的BBA，保时捷，有些一看就是老古董了。正当我准备下车和店主说明情况的时候，店主和我说，我们不修这种车，你得去隔壁看看。这还是我第一次感觉到阶级的差异，毕竟这汽修店也只是在小破巷里，谁又能想到他有这么大的口气呢？倒车离开的时候，店主因为担心我倒车撞倒后放的古董保时捷，还让我下车，他亲自倒车。我在一片尴尬的氛围中来到了隔壁汽修店，只可惜他也是无能为力，他推荐我去品牌4S店进行维修。</p>
<p>​    我打开地图，最近的马自达4S店在13英里外，而现在的车况是不能上高速的。无奈之下，我只能去Subaru的4S店寻求帮助，没想到前台的亚裔小哥帮我联系了马自达的4S店，并且询问他们能不能把零件寄过来维修，那一刻我内心涌起一股“Asian help asian”的感动。因为次日我就要去实习，而维修也无法当日完成。在这种情况下，他们不知道用了什么法子，帮我把引擎盖关上了（具体怎么关我也不清楚），并建议我周末到附近的4S店更换这个零件。在得知这一切都不需要收费的情况下，我恨不得当即跪下来给他磕三个头。因为要是关不上，我就去不成水族馆，并且接下来几天就都需要租车，我的车也只能放在他这里维修，甚至之后还要从San Jose开到这边来取（来回就要接近3小时）。</p>
<p>​    车子能上路了，我就前往了Monterey的水族馆（淘宝买的票竟然只要官网价格的1/7），虽然Santa Barbra也有水族馆，并且同样也以海鲜闻名，但就水族馆而言，终究还是比不上Monterey的规模。文字叙述水族馆的美还是太苍白了，这里便用图片说明吧（其实也是因为流水账太长了）。</p>
<p><img src="https://s2.loli.net/2023/06/20/C3skF8hro5JVbAN.png" alt="image-20230620003020062"></p>
<blockquote>
<p>水族馆的沙丁鱼群，在Open Sea 区域</p>
</blockquote>
<p>​    离开水族馆后，我预约了公司附近的车辆维修，然后便直接往住处开去。虽然在蒙特雷只是短短呆了一天，甚至不到24小时，但是实惠的饭菜份量，全能的酒店服务员，热情的4S店员都让我对这个城市有着很好的印象（那个只为富人修车的店家除外）。下次有机会一定会再来！</p>
]]></content>
      <categories>
        <category>Life, Journal, Travel</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>121.Buy And Sell Stock</title>
    <url>/2021/09/22/121.BuyAndSellStock/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>



<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Traverse all price pairs, ans = max(ans,pair[j]-pair[i]), where j &gt; i.</p>
<p>Steps:$n^2/2$ -&gt; TLE</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Define"><a href="#Define" class="headerlink" title="Define:"></a>Define:</h4><p>Max_profit = max{price[j]-price[i]}</p>
<p>0&lt;= i &lt; j &lt; n-1</p>
<h4 id="Finding"><a href="#Finding" class="headerlink" title="Finding:"></a>Finding:</h4><blockquote>
<p>Buy: price[i] = min{prices[:i]}</p>
<p>Sell: price[j] = max{prices[j:]}</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><h4 id="1-Keep-track-of-the-minimun-price-so-far"><a href="#1-Keep-track-of-the-minimun-price-so-far" class="headerlink" title="1.Keep track of the minimun price so far:"></a>1.Keep track of the minimun price so far:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse the price:</span><br><span class="line"></span><br><span class="line">​	L = the Lowest price up to day i</span><br><span class="line">	P = the max profit up to day i</span><br><span class="line">	</span><br><span class="line">	L.update</span><br><span class="line">	P.update</span><br><span class="line"></span><br><span class="line">//Buy at the lowest price, sell at day i.</span><br></pre></td></tr></table></figure>



<h4 id="2-Convert-the-priceList-to-the-gainList"><a href="#2-Convert-the-priceList-to-the-gainList" class="headerlink" title="2.Convert the priceList to the gainList"></a>2.Convert the priceList to the gainList</h4><blockquote>
<p>Example:</p>
<p>prices = [7,1,5,3,6,4]</p>
<p>Gains = [0,-6,4,-2,3,-2]</p>
</blockquote>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h3><p>The profit is the sum of a subarray in gains.</p>
<p>And the max_profit = the largest sum of subarray of an array(LeetCode 53).</p>
<h4 id="Using-Kadane’s-Algorithm"><a href="#Using-Kadane’s-Algorithm" class="headerlink" title="Using Kadane’s Algorithm"></a>Using Kadane’s Algorithm</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># Kadane&#x27;s Algorithm</span></span><br><span class="line">        maxCurrent = maxGlobal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># the maxCurrent is sum(maxCurrent+num)(the max subarray before this elem) or num</span></span><br><span class="line">            maxCurrent = <span class="built_in">max</span>(nums[i], maxCurrent + nums[i])</span><br><span class="line">            <span class="comment"># update maxGlobal = max(maxCurrent)</span></span><br><span class="line">            maxGlobal = <span class="built_in">max</span>(maxCurrent, maxGlobal)</span><br><span class="line">        <span class="keyword">return</span> maxGlobal</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>1239.Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2021/09/22/1239.Maximum%20Length%20of%20a%20Concatenated%20String%20with%20Unique%20Characters/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of strings <code>arr</code>. String <code>s</code> is a concatenation of a <mark>sub-sequence</mark> of <code>arr</code> which have <strong>unique characters</strong>.</p>
<p>Return <em>the maximum possible length</em> of <code>s</code>.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span><br><span class="line">Maximum length is 4.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">Output: 26</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 16</code></li>
<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>
<li><code>arr[i]</code> contains only lower case English letters.</li>
</ul>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><ul>
<li><p>A subsequence should preserve the order.</p>
<ul>
<li>For example, arr = [“un”,”iq”,”ue”], “iqun” is not a valid answer.</li>
<li>Corollary:<ul>
<li>However, we only want the length of the string, so the <strong>order</strong> of the strings are trivial.</li>
</ul>
</li>
</ul>
</li>
<li><p>The constraints has implied us that the algorithm could be exponential.</p>
</li>
<li><p>if arr[i] itself contains duplicate characters, it’s invalid.</p>
</li>
</ul>
<h3 id="BruteForce"><a href="#BruteForce" class="headerlink" title="BruteForce:"></a>BruteForce:</h3><p>Traverse all the string pair, find if the concantenated string has duplicate char.</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
</blockquote>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique:"></a>Technique:</h3><p>Since the arr[i].length&lt;=26&lt;32, we can use a 32bit int to do the char count</p>
<p>(How many times each character present in a string instead of map)</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
<p>Space Complexity $O(n)$ : using DFS recursion, the space complexity equals to the depth of recursion.</p>
</blockquote>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h4><p><img src="https://i.loli.net/2021/09/22/xbP8JXEZH7VWzdl.png" alt="image-20210922201019533"></p>
<blockquote>
<p>Referenced from Hua Hua@Youtube</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span></span><br><span class="line"><span class="comment">Output: 4</span></span><br><span class="line"><span class="comment">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span></span><br><span class="line"><span class="comment">Maximum length is 4.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//valid string</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string &amp;x : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//bit representations</span></span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//bit representation</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if the char used != the length of string, it contains duplicates.</span></span><br><span class="line">            <span class="comment">//ignore the string</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(mask) != x.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            a.<span class="built_in">push_back</span>(mask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//s is the index of string, mask is the present state</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> s, <span class="keyword">int</span> mask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//update the result</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, __builtin_popcount(mask));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the result is valid</span></span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(mask &amp; a[i]) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//go to combine with next element</span></span><br><span class="line">                    <span class="built_in">dfs</span>(i + <span class="number">1</span>, mask | a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>98.Validate Binary Search Tree</title>
    <url>/2021/09/30/98.ValidateBST/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: root = [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#x27;s value is 5 but its right child&#x27;s value is 4.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Property-of-a-Binary-Search-Tree"><a href="#Property-of-a-Binary-Search-Tree" class="headerlink" title="Property of a Binary Search Tree:"></a>Property of a Binary Search Tree:</h4><p><img src="https://i.loli.net/2021/09/30/B4ygC6psULPtG5Z.png" alt="image-20210930171547076"></p>
<blockquote>
<p>Ref from Huahua@Youtube</p>
</blockquote>
<p>For each TreeNode</p>
<ul>
<li>cur-&gt;left-&gt;val &lt; cur-&gt;val</li>
<li>cur-&gt;right-&gt;val &gt; cur-&gt;val</li>
</ul>
<h4 id="Consider-the-range"><a href="#Consider-the-range" class="headerlink" title="Consider the range:"></a>Consider the range:</h4><p>The input value ranges from -2^31 &lt;= Node.val &lt;= 2^31 - 1, so the positive/negative infinity should be set to LLONG_MIN, LLONG_MAX. (64-bit)</p>
<h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if nulltree:</span><br><span class="line">	return true;</span><br><span class="line"></span><br><span class="line">//if the node val is beyond the range, it&#x27;s invalid.</span><br><span class="line">if node-&gt;val&lt;=min_val||node-&gt;val&gt;=max_val:</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">//check subtree of both sides</span><br><span class="line">return validate(cur-&gt;left,min,cur-&gt;val)&amp;&amp;validate(cur-&gt;right,cur-&gt;val,max)</span><br></pre></td></tr></table></figure>



<h3 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root, <span class="keyword">long</span> mn, <span class="keyword">long</span> mx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= mn || root-&gt;val &gt;= mx)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, mn, root-&gt;val) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root-&gt;val, mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="For-Your-Consider"><a href="#For-Your-Consider" class="headerlink" title="For Your Consider:"></a>For Your Consider:</h4><p>What if the range extends to -2^64 ~2^64-1?</p>
<p><strong>Hint</strong>: Use nullptr to represent infinity.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Why Tuple?</title>
    <url>/2021/09/21/WhyTuple?/</url>
    <content><![CDATA[<p>C++ 11 introduces a template Tuple, similar to the one in Python, allows you to store data of different types in a single entity. But you may ask, in C/C++,we already have some mechaism called struct allows us to do the same thing, then why do we need tuple?</p>
<h3 id="Case-1-One-Time-Structure-to-Transfer-Data"><a href="#Case-1-One-Time-Structure-to-Transfer-Data" class="headerlink" title="Case 1: One-Time Structure to Transfer Data"></a>Case 1: One-Time Structure to Transfer Data</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;string,<span class="keyword">int</span>&gt; <span class="title">getNameAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">34</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span>string name;<span class="keyword">int</span> age;&#125;p;</span><br><span class="line">    tuple&lt;string,<span class="keyword">int</span>&gt; t;</span><br><span class="line">    </span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">tie</span>(name,age) = <span class="built_in">getNameAge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we want to transfer a group of data for only one time, we may not want to define a struct, and using tuple get us away from these definitions.</p>
<h3 id="Case-2-Fast-Comparison-Using-Tuple-Operators"><a href="#Case-2-Fast-Comparison-Using-Tuple-Operators" class="headerlink" title="Case 2: Fast Comparison Using Tuple Operators"></a>Case 2: Fast Comparison Using Tuple Operators</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; time1,time2;</span><br><span class="line"><span class="keyword">if</span>(time1&gt;time2)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time1 is later&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Case-3-Multi-Index-Map-Unordered-Map"><a href="#Case-3-Multi-Index-Map-Unordered-Map" class="headerlink" title="Case 3: Multi-Index Map/Unordered Map"></a>Case 3: Multi-Index Map/Unordered Map</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define</span></span><br><span class="line">map&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>,<span class="keyword">float</span>&gt;,string&gt; m;</span><br><span class="line"><span class="comment">//indexing</span></span><br><span class="line">m[<span class="built_in">make_tuple</span>(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1.0</span>)] = <span class="string">&quot;Test&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Case-4-Fast-Swap"><a href="#Case-4-Fast-Swap" class="headerlink" title="Case 4: Fast Swap"></a>Case 4: Fast Swap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">tie</span>(b,c,a) = <span class="built_in">make_tuple</span>(a,b,c);</span><br></pre></td></tr></table></figure>



<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><p>Tuple is not recommended to be overused. If needed, use struct instead.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Data_Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>ノエルのテーマ 〜最後の旅〜</title>
    <url>/2021/09/27/%E3%83%8E%E3%82%A8%E3%83%AB%E3%81%AE%E3%83%86%E3%83%BC%E3%83%9E%E3%80%80%E3%80%9C%E6%9C%80%E5%BE%8C%E3%81%AE%E6%97%85%E3%80%9C/</url>
    <content><![CDATA[<h4 id="Original-Lyrics"><a href="#Original-Lyrics" class="headerlink" title="Original Lyrics:"></a>Original Lyrics:</h4><p>Long ago, when I was just a boy<br>So alone that last of my kind in the world<br>I believe futures could be reborn<br>I would go back in time<br>Change what’s to come</p>
<p>Hunting, searching for futures I’ve dreamed<br>Ever chasing, believing visions unseen<br>Hearing that hope is futile<br>Only inspires me not to give up</p>
<p>Valhalla is calling me to the end<br>I can hear now the beating hearts of lost friends<br>Urging me to not forget them<br>As the last hunter<br>I’ll find the key</p>
<h4 id="Translated-zh-cn"><a href="#Translated-zh-cn" class="headerlink" title="Translated(zh-cn):"></a>Translated(zh-cn):</h4><p>很久之前，当我还是孩童之时</p>
<p>作为族类的最后一人，孑然一身</p>
<p>如果未来可以改变</p>
<p>我将追溯过去，改变将来</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Lyrics</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-概览笔记</title>
    <url>/2021/09/06/Notes-Computer%20Networks/</url>
    <content><![CDATA[<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client/Server:"></a>Client/Server:</h3><p>应用层，最为抽象</p>
<h3 id="TCP-传输层"><a href="#TCP-传输层" class="headerlink" title="TCP:传输层"></a>TCP:传输层</h3><p>对可靠性要求高、检验错误</p>
<h3 id="UDP："><a href="#UDP：" class="headerlink" title="UDP："></a>UDP：</h3><p>对可靠性要求低、但是能够保证实时</p>
<ul>
<li>直播</li>
<li>事务性应用</li>
</ul>
<h3 id="IP-网络层-End-to-End"><a href="#IP-网络层-End-to-End" class="headerlink" title="IP:网络层 End to End"></a>IP:网络层 End to End</h3><p>从主机到主机</p>
<p>在Link Layer的点到点通讯基础上实现</p>
<h3 id="Link-Layer-点到点通讯"><a href="#Link-Layer-点到点通讯" class="headerlink" title="Link Layer:点到点通讯"></a>Link Layer:点到点通讯</h3><h3 id="Physical-Layer-物理信号-数字信号"><a href="#Physical-Layer-物理信号-数字信号" class="headerlink" title="Physical Layer:物理信号-数字信号"></a>Physical Layer:物理信号-数字信号</h3><p>通过media（介质）：</p>
<ul>
<li>Copper</li>
<li>Fibre</li>
</ul>
<h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><h4 id="传统工作方式：查表-转发"><a href="#传统工作方式：查表-转发" class="headerlink" title="传统工作方式：查表+转发"></a>传统工作方式：查表+转发</h4><ul>
<li>路由器交换信息</li>
<li>计算出路由表</li>
<li>IP协议收到分组后，根据IP查路由表，再根据表转发</li>
</ul>
<h4 id="SDN方式：数据平面-控制系统"><a href="#SDN方式：数据平面-控制系统" class="headerlink" title="SDN方式：数据平面+控制系统"></a>SDN方式：数据平面+控制系统</h4><p>交换机：多字段匹配-&gt;block/转发/flood</p>
<p>操作系统：计算flow table-下发给交换机</p>
<p>（programmable+new features could be added）</p>
<p>比如说要新增加负载均衡，只需要编程即可</p>
<h4 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h4><h3 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h3><p>在下层提供的服务上实现更高级的功能</p>
<h3 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node:"></a>Node:</h4><ul>
<li><p>主机以及主机上的应用程序</p>
</li>
<li><p>路由器、交换机等网络交换设备</p>
</li>
<li><p>方的节点：主要节点（Client/Server）</p>
<p>圆形节点：中转节点</p>
</li>
</ul>
<h4 id="Edge-通信链路"><a href="#Edge-通信链路" class="headerlink" title="Edge:通信链路"></a>Edge:通信链路</h4><ul>
<li>access：主机接入到（最近的交换机）互联网的链路（一方一圆）</li>
<li>backbone：路由器之间的链路（两个圆的）</li>
</ul>
<h4 id="Protocol-对等层实体交换数据所需要遵循的规范"><a href="#Protocol-对等层实体交换数据所需要遵循的规范" class="headerlink" title="Protocol:对等层实体交换数据所需要遵循的规范"></a>Protocol:对等层实体交换数据所需要遵循的规范</h4><p>Protocol Data Unit(PDU)</p>
<h3 id="互联网包括：网络边缘-网络核心-接入网"><a href="#互联网包括：网络边缘-网络核心-接入网" class="headerlink" title="互联网包括：网络边缘/网络核心/接入网"></a>互联网包括：网络边缘/网络核心/接入网</h3><h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><p>网络边缘:</p>
<ul>
<li>主机</li>
<li>应用程序</li>
</ul>
<h3 id="1-3-Core（用于数据交换）"><a href="#1-3-Core（用于数据交换）" class="headerlink" title="1.3 Core（用于数据交换）"></a>1.3 Core（用于数据交换）</h3><ul>
<li>相互连接的路由器</li>
<li>网络的网络</li>
</ul>
<h3 id="1-4-Access"><a href="#1-4-Access" class="headerlink" title="1.4 Access"></a>1.4 Access</h3><ul>
<li>有线或者无线通信链路</li>
</ul>
<p>边缘接入核心-&gt;核心连接所有边缘节点-&gt;边缘可以和任意边缘节点交换</p>
<p>网络核心：相当于全球范围内的切换开关（如果需要交换，就打开）</p>
<h4 id="应用进程交互模式："><a href="#应用进程交互模式：" class="headerlink" title="应用进程交互模式："></a>应用进程交互模式：</h4><ul>
<li><p>Client/Server模式：</p>
<ul>
<li>Client后运行起来，向Server发出请求，资源来自于Server</li>
<li>问题：如果Client特别多，需要准备很多Server，到达一定程度时性能断崖式下跌</li>
</ul>
</li>
<li><p>Peer-Peer 模式：</p>
<ul>
<li>没有专门的服务器</li>
<li>每个节点既是Client也是Server</li>
<li>分布式通信，下载文件的时候，相当于多路下载片段</li>
</ul>
</li>
</ul>
<h4 id="基础设施为网络应用提供的服务："><a href="#基础设施为网络应用提供的服务：" class="headerlink" title="基础设施为网络应用提供的服务："></a>基础设施为网络应用提供的服务：</h4><ul>
<li>TCP（面向连接（端系统知道/路径节点不知道）的通信方式）：Shake Hand方式（数据传输前做好准备）<ul>
<li>可靠：不重复、不丢、不乱序</li>
<li>Flow Control:发送方不会淹没接收方</li>
<li>阻塞控制(Congestion Control)</li>
<li>要考虑网络+设备</li>
</ul>
</li>
<li>UDP(connectless，直接发送，不需要提前连接)<ul>
<li>不可靠</li>
<li>没有流量控制</li>
<li>没有阻塞控制</li>
<li>适合实时多媒体应用</li>
<li>事务性很强的应用（）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>thread and process</title>
    <url>/2021/10/08/thread%20and%20process/</url>
    <content><![CDATA[<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>smallest sequence of programmed instructions that can be managed independently by a scheduler.</li>
<li>Has its own registers, PC. SP.</li>
</ul>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><ul>
<li>Instance of a computer program that is being executed</li>
<li>A process can have one or more threads</li>
</ul>
<h3 id="Parallel-Computing"><a href="#Parallel-Computing" class="headerlink" title="Parallel Computing"></a>Parallel Computing</h3><ul>
<li>Run programs on one or more CPUs</li>
<li>Multi-threading (shared memory)</li>
<li>Multi-processing (Independent-memory)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; a += <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(run)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(run)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread1.<span class="built_in">join</span>(); <span class="comment">//only return after the thread1 finish</span></span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only main thread will execute</span></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading:"></a>Multithreading:</h3><p><img src="https://i.loli.net/2021/10/08/43roIiyfq6DAgS7.png" alt="image-20211008194305920"></p>
<p>Shared memory, so variable can be accessed by both threads.</p>
<p>However, <strong>when multithreads write (non-atomic instruction) a shared variable, inconsistency could happen.</strong></p>
<h3 id="Problem-Access-shared-resources"><a href="#Problem-Access-shared-resources" class="headerlink" title="Problem:Access shared resources:"></a>Problem:Access shared resources:</h3><p>CPU may process instructions randomly.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a += <span class="number">1</span>;<span class="comment">//non-atomic</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r</span><br><span class="line">INC r</span><br><span class="line">STORE r,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">INC r2,</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">// this is sequential</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r2</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>



<h4 id="To-fix"><a href="#To-fix" class="headerlink" title="To fix:"></a>To fix:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//thread blocking</span></span><br><span class="line">	l.<span class="built_in">lock</span>();</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    l.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: only use lock when going to the critical section, becuase multithreading is much faster.</p>
<h4 id="Communicate"><a href="#Communicate" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared variable</li>
<li>semaphore, mutex, lock</li>
</ul>
<h3 id="Multiprocessing"><a href="#Multiprocessing" class="headerlink" title="Multiprocessing:"></a>Multiprocessing:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">bool</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=child?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();<span class="comment">//create a parallel universe</span></span><br><span class="line">    <span class="comment">// all processes will execute this</span></span><br><span class="line">    <span class="built_in">run</span>(pid==<span class="number">0</span>);</span><br><span class="line">    cour&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/08/lxveEnH8zRh6TqB.png" alt="image-20211008195339005"></p>
<p>The pid returned by the fork() will not be 0 (0 as child process)</p>
<p>pid is the child process, should be 2+2;</p>
<p>pid is the parent process, should be 2+1;</p>
<h4 id="Communicate-1"><a href="#Communicate-1" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared memory</li>
<li>pipe</li>
<li>socket</li>
<li>RPC</li>
</ul>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd-shortest Path</title>
    <url>/2021/10/21/Second%20Shortest%20Path%20in%20Graph/</url>
    <content><![CDATA[<h4 id="Date-11-19-2021"><a href="#Date-11-19-2021" class="headerlink" title="Date:11.19.2021"></a>Date:11.19.2021</h4><blockquote>
<h3 id="Update-Log-11-25-2021"><a href="#Update-Log-11-25-2021" class="headerlink" title="Update Log 11.25.2021:"></a>Update Log 11.25.2021:</h3><h4 id="Comptability："><a href="#Comptability：" class="headerlink" title="Comptability："></a>Comptability：</h4><p>Known issue has been included in README.md</p>
<p>Recommend to compile with clang++，or Visual Studio 2019 CE.<br>Lab Files has been compiled and reviewed under MacOS 12.0.1，and Windows 10 + CMake 3.19 + Visual Studio Community 2019.</p>
<p>Set CMake minimum requirement to 3.14</p>
<h4 id="Performance-Improvement："><a href="#Performance-Improvement：" class="headerlink" title="Performance Improvement："></a>Performance Improvement：</h4><p>Using C++ 11 rvalue reference/move semantics to mitigate the copy construction overhead, 5% speed improvement under large case<br>Using C++11 std::future, std::async for async function calls, with 5% improvement in speed.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __THREADING__ </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><p>Given M vertices, indexed from 1 to M, and N edges to represent a <strong>Directional Graph.</strong> </p>
<p>(In my implementation, both directional and undirectional graph works fine.)</p>
<p>To simplify the problem, the starting point is vertex 1 and the destination is vertex M.</p>
<h4 id="Task-Find-Out-the-Second-Shortest-Path"><a href="#Task-Find-Out-the-Second-Shortest-Path" class="headerlink" title="Task: Find Out the Second Shortest Path"></a>Task: Find Out the Second Shortest Path</h4><ul>
<li><strong>Allow Backtracking:</strong> means each vertex can be presented in the path more than once.<ul>
<li>e.g. Path: 1-&gt;2-&gt;1-&gt;3 is valid</li>
</ul>
</li>
<li><strong>Multiple Shortest Path:</strong> if multiple shortest path exists, the second shortest path is the one whose length is longer than those but no longer than any other path.<ul>
<li>e.g. The length of all possible paths are <strong>100,100,105,110.</strong> The second shortest path length is 105.</li>
<li>If two or more second shortest paths exist, any second shortest path would be accepted.</li>
</ul>
</li>
</ul>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>In the first line specifies the <strong>number of vertices M and number of edges N of a digraph</strong>.</p>
<p>Then the rest N lines, each line is consisted of a edge, given by:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sourceVertex destVertex pathLength</span><br></pre></td></tr></table></figure>

<ul>
<li>Vertex is numbered from 1 to M</li>
<li>Only positive path length are considered</li>
</ul>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul>
<li>$1\le M\le1000$</li>
<li>$1\le N\le5000$</li>
<li>$1\le pathLength\le1000$</li>
</ul>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h3><ul>
<li>If(InputSize = 1000~10^6), a tolerable upper bound of an algorithm would be $O(nlog(n))$ </li>
<li>If(InputSize = 10^7), a tolerable upper bound of an algorithm would be $O(n)$</li>
<li>For this problem, if the <strong>input size is roughly $10^6&lt;$M*N</strong> $&lt;10^7$, the algorithm should be at least bounded by </li>
<li> $O(M<em>N log(M</em>N))$ .</li>
</ul>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Output the second shortest path in the form below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cost: cost</span><br><span class="line">Path: 1 ... m (exactly one space between each vertex, but no extra space at last)</span><br></pre></td></tr></table></figure>

<p>If there’s no second shortest path exist:</p>
<ul>
<li>Print a prompt to indicate there’s no second shortest path</li>
<li>Print the shortest path in the form below:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;But, the shortest path is&quot;</span><br><span class="line">Cost: cost</span><br><span class="line">Path: 1 ... m (exactly one space between each vertex, but no extra space at last)</span><br></pre></td></tr></table></figure>

<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h3><ul>
<li>Input</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">50</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">150</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">130</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">70</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">40</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">240</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<h3 id="Related-Problems-and-Algorithms"><a href="#Related-Problems-and-Algorithms" class="headerlink" title="Related Problems and Algorithms:"></a>Related Problems and Algorithms:</h3><p>In general, this is an specialization of <strong>single source K Shortest Path Problem</strong> , where K=2.</p>
<p>Many different methods have been proposed to solve this problem, and there are two main variants of this problem:</p>
<blockquote>
<p>For DiGraph with M edges and N vertices:</p>
</blockquote>
<ul>
<li><strong>Loopy Variant, which means backtrack is allowed.</strong><ul>
<li>A solution was proposed by <strong>B. L. Fox in 1975</strong><ul>
<li>$O(m + kn*log (n))$ </li>
<li>Fox, B. L. (1975). “<em>K</em>th shortest paths and applications to the probabilistic networks”. <em><a href="https://en.wikipedia.org/wiki/Institute_for_Operations_Research_and_the_Management_Sciences">ORSA/TIMS Joint National Meeting</a></em>. <strong>23</strong>: B263. <a href="https://en.wikipedia.org/wiki/CiNii">CiNii National Article ID</a>: 10012857200.</li>
</ul>
</li>
<li>A faster approach was proposed by <a href="https://en.wikipedia.org/wiki/David_Eppstein">David Eppstein</a><ul>
<li>$O(m + n*log (n)+k)$ </li>
<li> <a href="https://en.wikipedia.org/wiki/David_Eppstein">Eppstein, David</a> (1998). <a href="https://www.ics.uci.edu/~eppstein/pubs/Epp-SJC-98.pdf">“Finding the <em>k</em> Shortest Paths”</a> (PDF). <em><a href="https://en.wikipedia.org/wiki/SIAM_J._Comput.">SIAM J. Comput.</a></em> <strong>28</strong> (2): 652–673. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1137%2FS0097539795290477">10.1137/S0097539795290477</a></li>
<li>In this paper, he proposed that  if the shortest path tree (in the form of heap) is given, we can find the k-th shortest path in $O(m+n+k)$.</li>
</ul>
</li>
</ul>
</li>
<li>Loopless Variant, which means backtrack is not allowed.<ul>
<li>A well-known solution is called Yen’s algorithm<ul>
<li>$O(kn(m +n log (n)))$ </li>
<li> Yen, J. Y. (1971). “Finding the <em>k</em>-Shortest Loopless Paths in a Network”. <em><a href="https://en.wikipedia.org/wiki/Management_Science_(journal)">Management Science</a></em>. <strong>1 7</strong> (11): 712–716. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1287%2Fmnsc.17.11.712">10.1287/mnsc.17.11.712</a>..</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This problem, is the Loopy variant, which means an optimal time complexity can be achieved at  $O(n*log (n))$, which has a desirable run time with given constraints.</p>
<h3 id="Build-Environment-amp-To-Run"><a href="#Build-Environment-amp-To-Run" class="headerlink" title="Build Environment &amp; To Run:"></a>Build Environment &amp; To Run:</h3><h3 id="Building-Environment"><a href="#Building-Environment" class="headerlink" title="Building Environment:"></a>Building Environment:</h3><ul>
<li>MacOS 12.0.1</li>
<li>VSCode</li>
<li>Compiler: Clang ++ 13.0</li>
<li>C++ Standard = C++ 11</li>
<li>ARM64 Platform (Apple Silicon)</li>
</ul>
<h2 id="Approach-1-Recommended"><a href="#Approach-1-Recommended" class="headerlink" title="Approach 1(Recommended)"></a>Approach 1(Recommended)</h2><p>Using cmake for crossplatform compile</p>
<h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h3><p>Download and install cmake</p>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h3><p>The Cmake instructions (CMakeLists.txt) has been provided. You can modify it yourself.</p>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h3><p>Open terminal/Powershell</p>
<p>Type in command as below</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./main #under macOS or Unix-like OS</span><br></pre></td></tr></table></figure>

<p>Now you’re running the program.</p>
<p>The program will output result carries out by each algorithm and their total runtime, in order of decreasing time complexity.</p>
<h2 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach 2"></a>Approach 2</h2><p>Using VSCode C/C++ Extensions</p>
<h3 id="1-Modify-tasks-json-file"><a href="#1-Modify-tasks-json-file" class="headerlink" title="1.Modify tasks.json file:"></a>1.Modify tasks.json file:</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<h3 id="2-Click-the-button-on-Run-and-Debug-panel"><a href="#2-Click-the-button-on-Run-and-Debug-panel" class="headerlink" title="2.Click the button on Run and Debug panel"></a>2.Click the button on Run and Debug panel</h3><h2 id="Other-IDE"><a href="#Other-IDE" class="headerlink" title="Other IDE:"></a>Other IDE:</h2><p>Import the source files, and set the C++ standard to C++11, better compile with Visual Studio 2019, or using Clang++.</p>
<h2 id="Known-Issue"><a href="#Known-Issue" class="headerlink" title="Known Issue:"></a>Known Issue:</h2><ul>
<li>GCC doesn’t support some C++ 11 features as of on Clang++, so if possible using clang++ instead.</li>
<li>When using Visual Studio 2019 for compiling, a largest case of 5000 edges would throw error of std::vector memory limit. However, this won’t happen when compile with clang++.</li>
</ul>
<h3 id="INPUT-MODE"><a href="#INPUT-MODE" class="headerlink" title="INPUT MODE:"></a>INPUT MODE:</h3><p>By default we set to <strong>__FILE_<em>INPUT</em>_</strong> And <strong>Looptime to 1.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FILE__INPUT__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">change your loopTime here</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> loop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>USAGE ON MACROS:</p>
<ul>
<li>_SAMPLE_CASE_: The sample given by OJ.</li>
<li><em>FILE_INPUT</em>_: Get input from files.<ul>
<li>1 file case is provided to test the largest possible input.</li>
<li>of size M=1000, N=5000</li>
</ul>
</li>
<li>_USER_INPUT_: Get input from command line</li>
<li>Available Cases:<ul>
<li> _SAMPLE_CASE_1~6</li>
</ul>
</li>
<li>Available Graph Type:<ul>
<li>class DiGraph for directional graph</li>
<li>class UGraph for undirectional graph</li>
</ul>
</li>
</ul>
<h2 id="Chapter-2-Algorithm-Specification-Description"><a href="#Chapter-2-Algorithm-Specification-Description" class="headerlink" title="Chapter 2:    Algorithm Specification Description"></a>Chapter 2:    Algorithm Specification Description</h2><h3 id="Graph-Representation"><a href="#Graph-Representation" class="headerlink" title="Graph Representation:"></a>Graph Representation:</h3><p>We use the multiList representation of graph, meaning the multiList[i] indicates all the edges which starts from vertex i.</p>
<ul>
<li><p>Vertices on user interface level are numbered from 1 to n</p>
</li>
<li><p>Vertices in the multiList are numbered from 0 to n-1</p>
</li>
<li><p>Since variable sized array is available in C++, we don’t need linked list for the multiList implementation, using <strong>vector&lt;vector&lt;std::pair&lt;int,int&gt;&gt;&gt;</strong> instead. </p>
</li>
<li><p>In the std::pair, <strong>the first one indicates the destination vertex and the second indicates the path length (or cost).</strong></p>
</li>
<li><p>Type of the elements in the multiList:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(multiList) == vector&lt;vector&lt;std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt;&gt; <span class="comment"># this full multiList</span></span><br><span class="line"><span class="built_in">type</span>(multiList[<span class="number">0</span>]) == vector&lt;std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt; <span class="comment"># this is all edges starting from a certain vertex</span></span><br><span class="line"><span class="built_in">type</span>(multiList[<span class="number">0</span>][<span class="number">0</span>]) == std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; <span class="comment"># this is the single edge</span></span><br><span class="line">pair.first <span class="comment"># this is edge&#x27;s destination</span></span><br><span class="line">pair.second <span class="comment"># this is edge&#x27;s path length</span></span><br></pre></td></tr></table></figure></li>
<li><p>We implemented two types of graph, undirected graph and directed graph.</p>
<ul>
<li>They differs quite little in this implementation. A undirected graph, in this case, is a specialization of the directed graph.</li>
</ul>
</li>
<li><p>An API <strong>insertEdge()</strong> is implemented for edge insertion.</p>
</li>
</ul>
<h3 id="Check-Connection"><a href="#Check-Connection" class="headerlink" title="Check Connection:"></a>Check Connection:</h3><p>Before we start to find the second shortest path, we have to firstly check if there’s a possible path from <strong>vertex 1 to vertex m.</strong> We implemented this by Breadth-First-Search.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//keep a queue to store the vertices to be visited</span><br><span class="line">queue&lt;vertexNum&gt; adjVertices</span><br><span class="line">//keep a array to represent each vertices is visted or not</span><br><span class="line">visited&lt;bool&gt; isVisited</span><br><span class="line"></span><br><span class="line">enqueue the first vertex</span><br><span class="line"></span><br><span class="line">while(queue is not empty)</span><br><span class="line">    currentNode = dequeue()</span><br><span class="line">    if(currentNode is visited) </span><br><span class="line">    	continue;</span><br><span class="line">    mark the currentNode as visited;</span><br><span class="line">    enqueue the adjacent nodes of currentNode;</span><br></pre></td></tr></table></figure>

<p>After above process, we check if vertex m has been visited, if not, means there’s no possible path from vertex 1 to vertex m, abort.</p>
<blockquote>
<p>If vertex m has been visited, means there’s at least one path from vertex 1 to vertex m.</p>
<p>In this case, ShortestPath from 1 to m must exist.</p>
</blockquote>
<h3 id="Second-Shortest-Path"><a href="#Second-Shortest-Path" class="headerlink" title="Second Shortest Path:"></a>Second Shortest Path:</h3><p>In the Dijkstra’s algorithm, we find the shortest path by steps below:</p>
<ul>
<li><p>We keep an table, keeps track of each vertex’s <strong>shortest Path Length from Start</strong> and its direct predecessor of in shortest path.</p>
<ul>
<li><p>Each vertex is initialized as cost to infinity and predecessor to -1 as “Unmarked”</p>
</li>
<li><p>Each time visit the <strong>Unvisited Vertex Which Has The <mark>Shortest</mark> Path Length from Start</strong></p>
</li>
<li><p>Compute its neighbors’ cumulative Path Length, </p>
<pre><code>check if it’s shorter than the table’s records
if it&#39;s shorter, update table with the **path length and predecessor**
</code></pre>
</li>
<li><p>After compute, Mark the Vertex as visited.</p>
</li>
</ul>
</li>
<li><p>Dijkstra’s algorithm is an Greedy Algorithm, using local minimum to get global minimum.</p>
<ul>
<li>It’s possible to only record the direct predecessor of each vertex and be able to get the path from the table.<ul>
<li>The shortest path from vertex 1 to m is the global minimum, and each edge along this path is also the global minimum from vertex 1 to that vertex.</li>
</ul>
</li>
<li>An table may look like this</li>
</ul>
<img src="https://i.loli.net/2021/11/20/V2U9aNBSbvxOqH5.png" alt="image-20211120011014800" style="zoom: 33%;" /></li>
</ul>
<blockquote>
<p>Note that each step we have to find the <strong>Unvisited Vertex Which Has The <mark>Shortest</mark> Path Length from Start</strong>, If we do linear scan, the time complexity would be O(V^2). But if we keep a min heap, the time complexity would be O((V+E)log(E)).</p>
</blockquote>
<h3 id="Make-Some-Extension"><a href="#Make-Some-Extension" class="headerlink" title="Make Some Extension"></a>Make Some Extension</h3><p>To find the second shortest path, we simply keep another table, record the second shortest path from vertex 1 to vertex i. And we have to keep track of all of its predecessors <strong>(in implementation, a string)</strong>, instead of a single direct predecessor, since a second shortest path isn’t necessarily made up by multiple second shortest sub-paths.</p>
<p>We made some modification in the update part of the Dijkstra’s algorithm.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for v in adj(u):</span><br><span class="line">    if shortest[u] + cost(u, v) &lt; shortest[v]:</span><br><span class="line">        second_shortest[v] = shortest[v]</span><br><span class="line">        shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line">    else if shortest[u] + cost(u, v) &lt; sec_shortest[v] and shortest[u]+cost(u,v)!=shortest[v]: //in case there are multiple shortest paths.</span><br><span class="line">            second_shortest[v] = shortest[u] + cost(u, v)</span><br></pre></td></tr></table></figure>

<p>Also, to allow backtracking, each node can be pushed on to min heap multiple times. But for the second shortest path, <strong>the node in such path can appear at most twice.</strong> </p>
<blockquote>
<p> This is obvious, if a path 1-&gt;3-&gt;1-&gt;2-&gt;1-&gt;4 contains a node appears more than twice  (1 appears 3 times), there must exist 2 shorter paths where vertex <strong>1 appear 1 and 2 times</strong> and reach 4, and thus it’s not a second shortest path.</p>
</blockquote>
<p>The overall pseudocode looks like below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minHeap.push(vertex1)</span><br><span class="line"></span><br><span class="line">//break the loop if the heap is empty or the second shortest path has been calculated</span><br><span class="line">while(minHeap!=empty and second_shortest[vertexLast].cost == infinity)</span><br><span class="line">&#123;</span><br><span class="line">for v in adj(u):</span><br><span class="line">	if(v has been visited twice)</span><br><span class="line">		continue;</span><br><span class="line">    if shortest[u] + cost(u, v) &lt; shortest[v]:</span><br><span class="line">        second_shortest[v] = shortest[v]</span><br><span class="line">        shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line">    else if shortest[u] + cost(u, v) &lt; sec_shortest[v] and shortest[u]+cost(u,v)!=shortest[v]: //in case there are multiple shortest paths.</span><br><span class="line">            second_shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>If the second_shortest[vertexLast].cost=infinity, means there’s no second shortest path from vertex 1 to last vertex.</strong> In this case, we output the shortest path. A shortest path is ensured since we’ve done the BFS in advance.</p>
<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><h4 id="Case-1-Sample-Case"><a href="#Case-1-Sample-Case" class="headerlink" title="Case 1: Sample Case"></a>Case 1: Sample Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">150</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">130</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">70</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct"><a href="#Result-Correct" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/6bxgvMzEqNriWGX.png" alt="image-20211120014336249" style="zoom:67%;" />

<h4 id="Case-2-An-Undirectional-Graph"><a href="#Case-2-An-Undirectional-Graph" class="headerlink" title="Case 2: An Undirectional Graph"></a>Case 2: An Undirectional Graph</h4><img src="/Users/naoyuki/Library/Application%20Support/typora-user-images/image-20211120014537752.png" alt="image-20211120014537752" style="zoom: 50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">7</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-1"><a href="#Result-Correct-1" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/pXcBYEsFmk8xKGl.png" alt="image-20211120014515770" style="zoom:67%;" />



<h4 id="Case-3-Two-shortest-paths-exists-second-shortest-path-requires-backtracking"><a href="#Case-3-Two-shortest-paths-exists-second-shortest-path-requires-backtracking" class="headerlink" title="Case 3: Two shortest paths exists, second shortest path requires backtracking"></a>Case 3: Two shortest paths exists, second shortest path requires backtracking</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-2"><a href="#Result-Correct-2" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/DefKAg2FdGR3LZo.png" alt="image-20211120014753271" style="zoom:67%;" />



<h4 id="Case-4-No-second-shortest-path-but-exist-two-shortest-path-of-same-length"><a href="#Case-4-No-second-shortest-path-but-exist-two-shortest-path-of-same-length" class="headerlink" title="Case 4: No second shortest path, but exist two shortest path of same length."></a>Case 4: No second shortest path, but exist two shortest path of same length.</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-3"><a href="#Result-Correct-3" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/PusOXbo5avM1pzN.png" alt="image-20211120014957572" style="zoom:67%;" />



<h4 id="Case-5-No-valid-path-from-1-to-m"><a href="#Case-5-No-valid-path-from-1-to-m" class="headerlink" title="Case 5: No valid path from 1 to m"></a>Case 5: No valid path from 1 to m</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-4"><a href="#Result-Correct-4" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><p><img src="https://i.loli.net/2021/11/20/EncuRtsxgbwQ3dL.png" alt="image-20211120015142150"></p>
<h4 id="Case-6-Minimum-Case"><a href="#Case-6-Minimum-Case" class="headerlink" title="Case 6: Minimum Case"></a>Case 6: Minimum Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Minimum case, 2 vertices and 1 edge (since self loop is not allowed)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-5"><a href="#Result-Correct-5" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/elAFNhX43WD8HJV.png" alt="image-20211120132214734" style="zoom:67%;" />



<h4 id="Case-7-Maximum-Case"><a href="#Case-7-Maximum-Case" class="headerlink" title="Case 7: Maximum Case"></a>Case 7: Maximum Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Get input from largestCase.in</span></span><br><span class="line"><span class="comment">Use macro __FILE__INPUT__</span></span><br><span class="line"><span class="comment">m=1000,n=5000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/11/20/BOb8Rk12uQCMTKg.png" alt="image-20211120015529523"  />



<blockquote>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ul>
<li>The result seems acceptable so far, need some complex test cases for validation.</li>
</ul>
</blockquote>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4:    Analysis and Comments"></a>Chapter 4:    Analysis and Comments</h2><ul>
<li>M = number of Vertices</li>
<li>N = number of Edges</li>
</ul>
<h3 id="1-Build-Graph"><a href="#1-Build-Graph" class="headerlink" title="1.Build Graph:"></a>1.Build Graph:</h3><p>We keep an multiList by inserting all edges into the vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;</p>
<ul>
<li>Each insertion takes $O(1)$, the overall time complexity would be $O(N)$</li>
</ul>
<h4 id="Overall-Time-Complexity-O-N"><a href="#Overall-Time-Complexity-O-N" class="headerlink" title="Overall Time Complexity: $O(N)$"></a>Overall Time Complexity: $O(N)$</h4><p>We keep an multiList, each element is consist of destination and cost, which is $O(1)$</p>
<p> the overall time complexity would be $O(N)$</p>
<h4 id="Overall-Space-Complexity-O-N"><a href="#Overall-Space-Complexity-O-N" class="headerlink" title="Overall Space Complexity: $O(N)$"></a>Overall Space Complexity: $O(N)$</h4><blockquote>
<p>For Undirectional Graph, the only difference is that the insertion time and space taken by undirectional graph is twice as the directional one. But both are O(N) after all.</p>
</blockquote>
<h3 id="2-Check-Connection"><a href="#2-Check-Connection" class="headerlink" title="2.Check Connection:"></a>2.Check Connection:</h3><ol>
<li>In this step each edge is visited at most once, each node is visited at most once.</li>
<li>The enqueue and dequeue takes $O(1)$ time.</li>
</ol>
<p> the overall time complexity would be $O(N)$</p>
<h4 id="Overall-Time-Complexity-O-M-N"><a href="#Overall-Time-Complexity-O-M-N" class="headerlink" title="Overall Time Complexity: $O(M+N)$"></a>Overall Time Complexity: $O(M+N)$</h4><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity :"></a>Space Complexity :</h4><p>A queue of $O(N)$ (at most contains all edges) is needed in this step.</p>
<h4 id="Overall-Space-Complexity-O-N-1"><a href="#Overall-Space-Complexity-O-N-1" class="headerlink" title="Overall Space Complexity: $O(N)$"></a>Overall Space Complexity: $O(N)$</h4><h3 id="3-Second-Shortest-Path"><a href="#3-Second-Shortest-Path" class="headerlink" title="3.Second Shortest Path"></a>3.Second Shortest Path</h3><ul>
<li><p>We push each node to min heap at most twice (2M)</p>
<ul>
<li><p>Each time a edge is popped</p>
<ul>
<li>We update table, which takes $O(1)$ time</li>
</ul>
</li>
<li><p>Each pop or push takes $O(log(M))$ time</p>
</li>
</ul>
</li>
</ul>
<h4 id="Overall-Time-Complexity-O-Mlog-M"><a href="#Overall-Time-Complexity-O-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(Mlog(M))$"></a>Overall Time Complexity: $O(Mlog(M))$</h4><ul>
<li><p>We keep two tables, each tables takes M elements, each elements contains a string (contains all predecessors, at most length O(N)) and a int (cumulative cost).</p>
<ul>
<li>Two tables occupies $O(2M*N)$ Space.</li>
</ul>
</li>
<li><p>We also keeps an heap of max size $O(N)$, each node occupies $O(1)$ Space.</p>
</li>
</ul>
<h4 id="Overall-Space-Complexity-O-M-N"><a href="#Overall-Space-Complexity-O-M-N" class="headerlink" title="Overall Space Complexity:  $O(M*N)$"></a>Overall Space Complexity:  $O(M*N)$</h4><h3 id="OVERALL"><a href="#OVERALL" class="headerlink" title="OVERALL:"></a>OVERALL:</h3><h4 id="Overall-Time-Complexity-O-N-Mlog-M"><a href="#Overall-Time-Complexity-O-N-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(N+Mlog(M))$"></a>Overall Time Complexity: $O(N+Mlog(M))$</h4><h4 id="Overall-Space-Complexity-O-M-N-1"><a href="#Overall-Space-Complexity-O-M-N-1" class="headerlink" title="Overall Space Complexity:  $O(M*N)$"></a>Overall Space Complexity:  $O(M*N)$</h4><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments:"></a>Comments:</h3><blockquote>
<p>In the actual implementation of the constraint “each node is visited at most twice”, we use a slightly different approach based on the cumulative length, but they should have the same effect.</p>
<p>Although no hacking cases founded now, if things go wrong in some cases, the logic there needs a rewrite to be more accurate.</p>
</blockquote>
<h3 id="Extra-K-Shortest-Path"><a href="#Extra-K-Shortest-Path" class="headerlink" title="Extra: K-Shortest Path"></a>Extra: K-Shortest Path</h3><p>If we extend the same technique to  the K shortest path, we have to keep K table, which takes up $O(K<em>M</em>N)$ Space.</p>
<p>Each node can be pushed to heap at most K times, Which takes overall $O(N + K<em>M</em>log (M))$ time.</p>
<h4 id="Overall-Time-Complexity-O-N-K-Mlog-M"><a href="#Overall-Time-Complexity-O-N-K-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(N+K*Mlog(M))$"></a>Overall Time Complexity: $O(N+K*Mlog(M))$</h4><h4 id="Overall-Space-Complexity-O-KMN"><a href="#Overall-Space-Complexity-O-KMN" class="headerlink" title="Overall Space Complexity:  $$O(KMN)$$"></a>Overall Space Complexity:  $$O(K<em>M</em>N)$$</h4><h2 id="Appendix-Source-Code-in-C-11"><a href="#Appendix-Source-Code-in-C-11" class="headerlink" title="Appendix:    Source Code (in C++11)"></a>Appendix:    Source Code (in C++11)</h2><h4 id="Djikstra-hpp"><a href="#Djikstra-hpp" class="headerlink" title="Djikstra.hpp"></a>Djikstra.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">anscestors are numbered from 0~n-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    string ancestors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">heap node is numbered from 1~n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string ancestors;</span><br><span class="line">    <span class="keyword">int</span> src;</span><br><span class="line">    <span class="keyword">int</span> dst;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HeapNode</span>(string&amp;&amp; ancestors, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> cost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ancestors = ancestors;</span><br><span class="line">        <span class="keyword">this</span>-&gt;src = src;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dst = dst;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Order minHeap by cost</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> HeapNode &amp;a, <span class="keyword">const</span> HeapNode &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Allowing for both digraph and undirectional graphs.</span></span><br><span class="line"><span class="comment">finding the second shortest path using extended dijkstra algorithm</span></span><br><span class="line"><span class="comment">graph: the graph to be searched</span></span><br><span class="line"><span class="comment">verbose: print out result, by default set to true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(T &amp;graph, <span class="keyword">bool</span> verbose = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type check</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">bool</span> isGraph = std::is_same&lt;T, UGraph&gt;::value || std::is_same&lt;T, DiGraph&gt;::value;</span><br><span class="line">    <span class="keyword">if</span> (!isGraph)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Input is not compatible graph&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    initialize the table,</span></span><br><span class="line"><span class="comment">    with the total path cost to inifinity,</span></span><br><span class="line"><span class="comment">    parent to - 1 as null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   record the shortest path cost</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function">vector&lt;CostTable&gt; <span class="title">costTable</span><span class="params">(graph.getVertexNum(), &#123;INT32_MAX, &#123;<span class="string">&quot;-1&quot;</span>&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   record the second shortest path cost</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function">vector&lt;CostTable&gt; <span class="title">secondCostTable</span><span class="params">(graph.getVertexNum(), &#123;INT32_MAX, &#123;<span class="string">&quot;-1&quot;</span>&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize priority_queue as minHeap. STL implementation by default is maxHeap</span></span><br><span class="line">    priority_queue&lt;HeapNode, vector&lt;HeapNode&gt;, compare&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set starting point</span></span><br><span class="line">    costTable[<span class="number">0</span>].ancestors = <span class="string">&quot;-2&quot;</span>;</span><br><span class="line">    costTable[<span class="number">0</span>].cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    priority_queue doesn&#x27;t offer a iterator</span></span><br><span class="line"><span class="comment">    each node contains source, destination and cumulative cost</span></span><br><span class="line"><span class="comment">    order by cumulative cost</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//push the adjacent nodes of the starting node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph.multiList[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmpNode = <span class="built_in">HeapNode</span>(<span class="string">&quot;1 &quot;</span> + <span class="built_in">to_string</span>(edge.first + <span class="number">1</span>), <span class="number">1</span>, edge.first + <span class="number">1</span>, edge.second);</span><br><span class="line">        minHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while the second shortest path of the given vertex is not determined</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>() &amp;&amp; secondCostTable.<span class="built_in">back</span>().cost == INT32_MAX)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> node = minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalCost = node.cost;</span><br><span class="line">        <span class="keyword">int</span> srcIndex = node.src;</span><br><span class="line">        <span class="keyword">int</span> destIndex = node.dst;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the current node&#x27;s total cost is less than the cost in shortest table</span></span><br><span class="line"><span class="comment">    update the shortest path, and the second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (totalCost &lt; costTable[destIndex - <span class="number">1</span>].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].cost = costTable[destIndex - <span class="number">1</span>].cost;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].ancestors = costTable[destIndex - <span class="number">1</span>].ancestors;</span><br><span class="line">            costTable[destIndex - <span class="number">1</span>].cost = totalCost;</span><br><span class="line">            costTable[destIndex - <span class="number">1</span>].ancestors = node.ancestors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the current node&#x27;s total cost is larger than the shortest</span></span><br><span class="line"><span class="comment">    and less than the cost in second shortest </span></span><br><span class="line"><span class="comment">    update the second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (totalCost &lt; secondCostTable[destIndex - <span class="number">1</span>].cost &amp;&amp; totalCost != costTable[destIndex - <span class="number">1</span>].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].cost = totalCost;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].ancestors = node.ancestors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//to find the 2nd shortest path</span></span><br><span class="line">            <span class="comment">// there&#x27;s no need to push the child of 3rd or 4th shortest path to heap</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    push the adjacent nodes, we don&#x27;t check if the node is visited or not</span></span><br><span class="line"><span class="comment">    since we allow backtracking</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph.multiList[destIndex - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            each node is ensured to be visited twice at most</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (secondCostTable[edge.first].cost &lt; totalCost + edge.second)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//push the node to the priority queue</span></span><br><span class="line">            <span class="keyword">auto</span> tmpNode = <span class="built_in">HeapNode</span>(node.ancestors + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(edge.first + <span class="number">1</span>), destIndex, edge.first + <span class="number">1</span>, totalCost + edge.second);</span><br><span class="line">            minHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the ancestors is &quot;-1&quot;, means the second cost table of the last vertex</span></span><br><span class="line"><span class="comment">    haven&#x27;t been visited yet, Which means there&#x27;s no second shortest path, but at least one path</span></span><br><span class="line"><span class="comment">    from start to end is ensured through previous checkConnection().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (secondCostTable.<span class="built_in">back</span>().ancestors == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Doesn&#x27;t exist second shortest path.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;But, the shortest path is&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost = costTable.<span class="built_in">back</span>().cost;</span><br><span class="line">        <span class="keyword">auto</span> path = costTable.<span class="built_in">back</span>().ancestors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cost: &quot;</span> &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">            cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return the second shortest path with given cost table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The second shortest path is&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost = secondCostTable.<span class="built_in">back</span>().cost;</span><br><span class="line">    <span class="keyword">auto</span> path = secondCostTable.<span class="built_in">back</span>().ancestors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cost: &quot;</span> &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">        cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Graph-hpp"><a href="#Graph-hpp" class="headerlink" title="Graph.hpp"></a>Graph.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Base Class</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//multiList Representation, using vector</span></span><br><span class="line">    <span class="comment">//each element contains destination and cost</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; multiList;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize</span></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> vertexNum, <span class="keyword">int</span> edgeNum)</span><br><span class="line">    &#123;</span><br><span class="line">        vNum = vertexNum;</span><br><span class="line">        eNum = edgeNum;</span><br><span class="line">        multiList.<span class="built_in">resize</span>(vertexNum);</span><br><span class="line">        inDegree.<span class="built_in">resize</span>(vertexNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get number of vertices</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get number of vertices</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    insert an edge from src to dst</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check if the graph contains a certain edge, using lambda expression</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_if</span>(multiList[src].<span class="built_in">begin</span>(), multiList[src].<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;elem)</span><br><span class="line">                    &#123; <span class="keyword">return</span> elem.first == dst; &#125;) != multiList[src].<span class="built_in">end</span>())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; multiList.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; multiList[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; multiList[i][j].first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; multiList[i][j].second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">    <span class="comment">//number of edges and vertices</span></span><br><span class="line">    <span class="keyword">int</span> vNum;</span><br><span class="line">    <span class="keyword">int</span> eNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a class for undirectional graphs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UGraph</span> :</span> <span class="keyword">public</span> Graph</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UGraph</span>(<span class="keyword">int</span> vNum, <span class="keyword">int</span> eNum) : <span class="built_in">Graph</span>(vNum, eNum)&#123;&#125;;</span><br><span class="line">    <span class="comment">//insert an edge from src to dst</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// minus one, make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update parameters</span></span><br><span class="line">        multiList[src].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dst, cost));</span><br><span class="line">        multiList[dst].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(src, cost));</span><br><span class="line">        inDegree[dst]++;</span><br><span class="line">        inDegree[src]++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a class for Directional graphs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span> :</span> <span class="keyword">public</span> Graph</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DiGraph</span>(<span class="keyword">int</span> vNum, <span class="keyword">int</span> eNum) : <span class="built_in">Graph</span>(vNum, eNum)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert an edge from src to dst</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// minus one, make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update parameters</span></span><br><span class="line">        multiList[src].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dst, cost));</span><br><span class="line">        inDegree[dst]++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS algorithm to check if there&#x27;s a path from the first node to the last node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkConnection</span><span class="params">(T &amp;graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type check</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">bool</span> isGraph = std::is_same&lt;T, UGraph&gt;::value || std::is_same&lt;T, DiGraph&gt;::value;</span><br><span class="line">    <span class="keyword">if</span> (!isGraph)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Input is not compatible graph&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isVisited</span><span class="params">(graph.getVertexNum(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    push in the first node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    each round:</span></span><br><span class="line"><span class="comment">    1.currentNode = dequeue(), if(currentNode is visited) continue;</span></span><br><span class="line"><span class="comment">    2.mark the currentNode as visited.</span></span><br><span class="line"><span class="comment">    3.enqueue the adjacent nodes of currentNode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> currentNode;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        currentNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isVisited[currentNode])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        isVisited[currentNode] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;adjNode : graph.multiList[currentNode])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(adjNode.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if there&#x27;s no path from the first node to the last node</span></span><br><span class="line"><span class="comment">    means there&#x27;s no possible second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!isVisited[graph.<span class="built_in">getVertexNum</span>() - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: No Path to Destination&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lab3-cpp"><a href="#lab3-cpp" class="headerlink" title="lab3.cpp"></a>lab3.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Dijkstra.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="comment">// #define __SAMPLE__CASE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CASE__2__</span></span><br><span class="line"><span class="comment">// #define __USER__INPUT__</span></span><br><span class="line"><span class="comment">// #define __FILE__INPUT__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THREADING__</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">change your loopTime here</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> loop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SAMPLE__CASE__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">150</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">130</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">70</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">40</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a bidirectional (undirected graph) case</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__1__</span></span><br><span class="line">    <span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">7</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">there exist two shortest path between 1-3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__2__</span></span><br><span class="line">    <span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Only one shortest path between 1 and 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__3__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Vertex 4 is isolated, no valid path</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__4__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Minimum case, 2 vertices and 1 edge (since self loop is not allowed)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__5__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DiGraph with cycle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__6__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __FILE__INPUT__</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a large input case</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;largestCase.in&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vNum, eNum;</span><br><span class="line">    inputFile &gt;&gt; vNum &gt;&gt; eNum;</span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(vNum, eNum)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src, dst, cost;</span><br><span class="line">    <span class="keyword">while</span> (eNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inputFile &gt;&gt; src &gt;&gt; dst &gt;&gt; cost;</span><br><span class="line">        graph.<span class="built_in">insertEdge</span>(src, dst, cost);</span><br><span class="line">        eNum--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get input from user, by default directional graph</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USER__INPUT__</span></span><br><span class="line">    <span class="keyword">int</span> vNum, eNum;</span><br><span class="line">    cin &gt;&gt; vNum &gt;&gt; eNum;</span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(vNum, eNum)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src, dst, cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">getEdgeNum</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; src &gt;&gt; dst &gt;&gt; cost;</span><br><span class="line">        graph.<span class="built_in">insertEdge</span>(src, dst, cost);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop::loopTime; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//using async function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __THREADING__</span></span><br><span class="line">        std::future&lt;<span class="keyword">bool</span>&gt; fp = <span class="built_in">async</span>(</span><br><span class="line">            launch::async, checkConnection&lt;<span class="keyword">decltype</span>(graph)&gt;,</span><br><span class="line">            std::<span class="built_in">ref</span>(graph));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THREADING__</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkConnection</span>(graph))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>(graph, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __THREADING__</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isConnected = fp.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (!isConnected)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;e)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: threading failed:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="comment">//print time it takes</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program Completed in: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    test code for graph functionality</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; graph.containsEdge(1, 2) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// graph.print();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Portfolio Site</title>
    <url>/2022/01/20/Portfolio%20Site%20Online/</url>
    <content><![CDATA[<p>Recently I began my Master application for 2022 Fall, and some of the universities, require the applicants to submit their portfolio in the form of personal website. I was intended to submit this site, however, this site only contains daily logs and technical topic posts. So I would rather create another website for my portfolio works.</p>
<p>After one afternoon’s work, new Portfolio Website was online, powering by Wix. Actually I found the Wix tool quite easy to use, only drags and drops are needed, just like what they’ve shown in the Youtube ads. The problem is, it’s not suitable for me to contantly update the contents since it tooks a lot more to render a single site in Wix. You have to drag and drop each paragraph yourself. However, it’s pretty easy to publish a post in Hexo. I can just use Typora and markdown to upload a post in seconds. Also, Wix doesn’t have good support for code snippets as the Markdown does. So I‘m just gonna post most of my daily thoughts and progresses here. And major works on the portfolio site.</p>
<p>I actually want to merge these two sites, this site and the portfolio site, into one. However, I find the two sites’ styles are quite different and I’m not interested in writing pieces of CSS code anyway. Maybe I will merge them someday.</p>
<p>Finally, if you are interested in my portfolio, check  <a href = "https://zhaonzh.wixsite.com/mysite-1">Portfolio Site</a>.</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>About Me</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender 3.1 Alpha Render Test on M1 Max</title>
    <url>/2021/12/11/Blender%203.1%20Render%20Test/</url>
    <content><![CDATA[<h2 id="All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P"><a href="#All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P" class="headerlink" title="All Scenes are rendered using cycles using GPU Compute 1080P"></a>All Scenes are rendered using cycles using GPU Compute 1080P</h2><h3 id="1-Classroom-300-Samplings"><a href="#1-Classroom-300-Samplings" class="headerlink" title="1.Classroom 300 Samplings"></a>1.Classroom 300 Samplings</h3><ul>
<li><p>Result: 1min 47.32s = 107.32s </p>
</li>
<li><p>Boost compared to CPU: 8*60/107.32 = 4.47x</p>
</li>
<li><p>Roughly equivalent to CUDA 3060Ti @Blender 2.9x </p>
</li>
<li><p>Roughtly equivalent to Optix 2080 @Blender 2.8x and Optix 3060 @Blender 2.9x</p>
</li>
<li><p>According to Rob Williams@<a href="https://techgage.com/article/blender-3-0-gpu-performance/">https://techgage.com/article/blender-3-0-gpu-performance/</a>, the performance of M1 Max is half of the 3060 with Optix 3060 @Blender 3.00. If we assume there is a performance boost of 2 times in Cycles from 2.9x to 3.00, a rough equivalent will be 2060 Max-Q (206s Optix 2.93).</p>
<p><img src="https://s2.loli.net/2022/01/01/WiZIz8rKlXEcOYM.png" alt="image-20220101235753865"></p>
</li>
</ul>
<h3 id="2-BMW27-GPU-Compute-1225-Samplings"><a href="#2-BMW27-GPU-Compute-1225-Samplings" class="headerlink" title="2.BMW27 (GPU Compute) 1225 Samplings"></a>2.BMW27 (GPU Compute) 1225 Samplings</h3><ul>
<li>Result: 43.59s</li>
<li>Boost Compared to CPU: 210/43.59 = 4.82x</li>
<li>Roughly equivalent to CUDA 3060~3060Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2060 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/wZ35lDaBkiJ7mWQ.png" alt="image-20211219164344829" style="zoom:50%;" /></li>
</ul>
<h3 id="3-Barcelona-Pavilion-1000-Samplings"><a href="#3-Barcelona-Pavilion-1000-Samplings" class="headerlink" title="3.Barcelona Pavilion 1000 Samplings"></a>3.Barcelona Pavilion 1000 Samplings</h3><ul>
<li>Result: 176.51s</li>
<li>Boost Compared to CPU: 640/176.51 = 3.62x</li>
<li>Roughly equivalent to CUDA 3070~3070Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2070 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/oBTbOQra1Dp8nZd.png" alt="image-20211219171113341" style="zoom:33%;" /></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
      <tags>
        <tag>Redering</tag>
        <tag>Blender</tag>
      </tags>
  </entry>
  <entry>
    <title>折叠表达式(Fold Expression)，低速下脚现代C++ Chapter 2 Exercise</title>
    <url>/2021/10/15/%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F(Fold%20Expression)%EF%BC%9A%E4%BD%8E%E9%80%9F%E4%B8%8B%E8%84%9A%E7%8E%B0%E4%BB%A3C++%20Chapter%202%20Exercise/</url>
    <content><![CDATA[<h3 id="折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise"><a href="#折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise" class="headerlink" title="折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise"></a>折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise</h3><p>最近在看高速上手现代C++，这是一本很不错的书，作者用仅80余页的长度介绍了C++自C++11以来至C++20带来的许多特性。这些特性给C++带来了语言可用性上的强化，运行期的强化 etc. 以及使得这门语言本身更好地支持例如函数式编程的范式。</p>
<p>每一章的结尾作者都会提供一些简单的小题目，其中第二章的小题目cover了折叠表达式(Fold Expression, since C++17)和结构化绑定（Structured Binding, since C++17）。在自己闲着摸索的时候发现了一个有意思的小事情，于是稍微写点东西记录一下。</p>
<blockquote>
<p>感觉光看这本书和课后的题的话，内容还是不太能掌握，可能跟着其他博客看一看会比较好。</p>
</blockquote>
<h3 id="为什么需要Fold-Expression"><a href="#为什么需要Fold-Expression" class="headerlink" title="为什么需要Fold Expression?"></a>为什么需要Fold Expression?</h3><p>模版是C++比较重要的一个板块之一，但是C++11之前，模版的参数数量是固定的。自从C++11之后，新引入的表示方法允许声明时引入任意数量的参数，即如下形式:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br></pre></td></tr></table></figure>

<p>有了可变长模版，我们就可以写一个允许任意长度参数的函数模版了。一个显而易见的好处是，我们可用这样的语法实现以下函数功能，并且只要写一个函数模版。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个函数模版 mean_val，接受任意长度的参数，返回平均值</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// return 2</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// return 3.5</span></span><br></pre></td></tr></table></figure>

<p>不过在C++17之前，这样的函数模版在解包(unpack)的时候会比较麻烦，因为我们在写函数模版的时候并不知道究竟会传几个参数进来，而参数包又不像是std::vector之类的容器有简单的方式进行遍历，因此我们对于函数参数的实际操作就变得比较麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如说我想实现max_val，但是我并没有直观的方式遍历args的内容</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//我该怎么获得args的内容呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过目前来说，我们可以通过sizeof… 来计算参数的个数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;std::endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// cout:3</span></span><br></pre></td></tr></table></figure>

<h4 id="一个比较常见的做法是利用递归来进行参数解包"><a href="#一个比较常见的做法是利用递归来进行参数解包" class="headerlink" title="一个比较常见的做法是利用递归来进行参数解包:"></a>一个比较常见的做法是利用递归来进行参数解包:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//书中的案例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt; <span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;<span class="comment">//每次取出一个T，然后递归再取出一个T</span></span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>); <span class="comment">//输出所有参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的确比较繁琐，而C++17中引入了一种比较简洁的方式来实现这种功能需求，这就是标题里的折叠表达式。</p>
<ul>
<li>考虑下面的代码，下面的函数模版可以实现任意长度立即数的求和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> <span class="comment">//C++14，函数返回值自动推断</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> (t + ...); <span class="comment">//折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过书中没有仔细讲这个折叠表达式的内容，因此原理上就有些不清晰，这里做一些补充。</p>
<h3 id="折叠表达式的语法："><a href="#折叠表达式的语法：" class="headerlink" title="折叠表达式的语法："></a>折叠表达式的语法：</h3><ul>
<li><code>pack op ...</code> (一元右折叠 / unary right fold)</li>
<li><code>... op pack</code> (一元左折叠 / unary right fold)</li>
<li><code>pack op ... op init</code> (二元右折叠 / binary right fold)</li>
<li><code>init op ... op pack</code> (二元左折叠 / binary left fold)</li>
</ul>
<p>其中，<code>pack</code>是参数包，即上述代码中的t，op即operator，支持32种二元运算符，例如<code>+,-,*,/</code> , <code>init</code>表示最后一层展开时二元运算符的另一个操作数。 其中在二元折叠中两个operator要保持一致。</p>
<h3 id="以上四个表达式和以下内容等价："><a href="#以上四个表达式和以下内容等价：" class="headerlink" title="以上四个表达式和以下内容等价："></a>以上四个表达式和以下内容等价：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(args op ...) &lt;-&gt; (arg1 op (arg2 op (arg3 op (... op (arg_n-1 op arg_n)))))</span><br><span class="line">(... op args) &lt;-&gt; (((arg1 op arg2) op ...) op arg_n)</span><br><span class="line">(args op ... op init) &lt;-&gt; (arg1 op (... op (arg_n−1 op (arg_n op init))))</span><br><span class="line">(init args op ... op ) &lt;-&gt; ((((init op arg1) op arg2) op ...) op arg_n)</span><br></pre></td></tr></table></figure>

<p>这么写可能还是有点晕，举两个例子可能更好:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">(args - ...) &lt;-&gt; (<span class="number">1</span> - (<span class="number">2</span> - <span class="number">3</span>))</span><br><span class="line">(<span class="number">3</span> - ... - args) &lt;-&gt; (((<span class="number">3</span><span class="number">-1</span>)<span class="number">-2</span>)<span class="number">-3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a></p>
</blockquote>
<p>下面是一个注意点，由于运算符优先级问题，第一种备注是掉的写法并不被接受，需要写成第二种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  return (args + ... + 1 * 2);   // Error: operator with precedence below cast</span></span><br><span class="line">    <span class="keyword">return</span> (args + ... + (<span class="number">1</span> * <span class="number">2</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作业题："><a href="#作业题：" class="headerlink" title="作业题："></a>作业题：</h3><p>利用折叠表达式写一个计算求均值的函数模版:</p>
<p>答案如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mean</span><span class="params">(T... t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mean</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure>

<h3 id="但是…"><a href="#但是…" class="headerlink" title="但是…"></a>但是…</h3><p>不知道为什么我突然想试着把 <code>+</code> 改成 <code>-</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t - ...)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; (<span class="number">1</span>-(<span class="number">2</span>-(<span class="number">3</span>-(<span class="number">4</span><span class="number">-5</span>)))) = (<span class="keyword">int</span>)<span class="number">3</span>/<span class="number">5</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个例子倒是没有问题，如果我改成左折叠:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">return</span> (... - t) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//output: 3689348814741910320</span></span><br></pre></td></tr></table></figure>

<p>这个一长串数字并不是随机数，运行了好几次都是同一个结果。但是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(... - t)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; ((((<span class="number">1</span><span class="number">-2</span>)<span class="number">-3</span>)<span class="number">-4</span>)<span class="number">-5</span>)/<span class="number">5</span> = <span class="number">-13</span>/<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>本应该输出-2才对，那么究竟是哪里出问题了呢？</p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>首先我查看了折叠表达式和<code>sizeof…(t)</code>的返回值，用lldb调试后发现数值没有问题，那么应该是除法这一步出了问题。</p>
<p><img src="https://s2.loli.net/2022/01/01/v2aCilBbDmuOLEj.png" alt="image-20220101230639043"></p>
<p>当我将p的类型从auto改为int之后，返回值就变成-2了：</p>
<p><img src="https://s2.loli.net/2022/01/01/16UWplfXmMLCNTv.png" alt="image-20220101230834880"></p>
<p>那么看来应该是<code>sizeof…</code>返回值的问题。</p>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>询问学长之后发现，<code>sizeof...</code>返回的是一个<code>size_t</code>类型的值，在64-bit操作系统中类型是<code>uint64_t</code>，即64位无符号整型。然后折叠表达式自动推断返回为int（<code>int32_t</code>), 二者做除法的时候int被提升到<code>uint64_t</code>，然后又因为负数的符号位在最高位，被转换成unsigned的时候，数值就变得非常大了。</p>
<p>可以具体算一下这个<code>3689348814741910320</code>的由来，结果是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-13 = (hex) FFFFFFFFFFFFFFF3 -&gt; 18,446,744,073,709,551,603</span><br><span class="line">int(18,446,744,073,709,551,603 / 5) = 3689348814741910320</span><br></pre></td></tr></table></figure>

<p>所以需要注意的是，一行的表达式，其实包含了一次类型推断和一次隐式类型转换，所以使用的时候需要比较小心一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//equivalent as below</span></span><br><span class="line"><span class="keyword">auto</span> p = (t + ...);</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="keyword">return</span> p/i;</span><br></pre></td></tr></table></figure>

<p>等我看完Chapter 4的时候可能会再来写一点内容，感觉还是得一边看一边跟着例子写一点才好。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>382. Linked List Random Node</title>
    <url>/2021/11/16/382.%20Linked%20List%20Random%20Node/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>Implement the <code>Solution</code> class:</p>
<ul>
<li><code>Solution(ListNode head)</code> Initializes the object with the integer array nums.</li>
<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg" alt="getrand-linked-list"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 3, 2, 2, 3]</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li>The number of nodes in the linked list will be in the range <code>[1, 104]</code>.</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
<li>At most <code>10^4</code> calls will be made to <code>getRandom</code>.</li>
</ul>
<blockquote>
<p>Since at most 10k calls will be made, the overall time complexity of each random call is expected to be bounded by O(nlogn).</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><p>A simple approach would be converting the linked list into an array, and then random generate a number and random access the array. This would cost extra <code>O(n)</code> space for keeping an array, and <code>O(1)</code> to random access the array.</p>
<blockquote>
<p>Actually, another implementation is that, we could traverse the list to get the length, and then random generate a number, and then take O(n) step to get the number.</p>
<p>This implementation would take O(1) extra space, and O(n) for traversing and accessing.</p>
</blockquote>
<h3 id="What-if…-just-visit-each-node-only-once-and-use-O-1-space"><a href="#What-if…-just-visit-each-node-only-once-and-use-O-1-space" class="headerlink" title="What if… just visit each node only once and use O(1) space?"></a>What if… just visit each node only once and use O(1) space?</h3><blockquote>
<p>The key is, Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>So to ensure the same probability, it is not necessary to use the built-in random function.</p>
</blockquote>
<h3 id="Introducing-Reservoir-Sampling"><a href="#Introducing-Reservoir-Sampling" class="headerlink" title="Introducing Reservoir Sampling:"></a>Introducing Reservoir Sampling:</h3><p>I found a video on YouTube, explaining this idea in an interesting and great way.</p>
<ul>
<li><h4 id="Scenario-A-man-picking-a-hat"><a href="#Scenario-A-man-picking-a-hat" class="headerlink" title="Scenario: A man picking a hat"></a>Scenario: A man picking a hat</h4><ul>
<li><h4 id="each-round-replace-the-old-hat-or-wear-new-hat"><a href="#each-round-replace-the-old-hat-or-wear-new-hat" class="headerlink" title="each round replace the old hat or wear new hat"></a>each round replace the old hat or wear new hat</h4></li>
<li><p>Each round probability of wearing new hat: 1/n</p>
</li>
<li><p>The first hat has a chance of 1/1, so he 100% wear the hat</p>
</li>
<li><p>The second hat has a chance of 1/2, so he 50% wear the 2nd hat, 50% keep the first hat</p>
</li>
<li><p>The third hat has a chance of 1/3, 1/3 wear the 3nd hat, 2/3 keep the original hat</p>
</li>
<li><p>So on and so forth…</p>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/01/08/F9ehzSj1Ovrx6Tq.png" alt="image-20220108005314005" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/01/08/OA8nIcDtopjaB7x.png" alt="image-20220108005616966" style="zoom:50%;" />

<h3 id="The-Good-Side"><a href="#The-Good-Side" class="headerlink" title="The Good Side:"></a>The Good Side:</h3><p>Reservoir sampling doesn’t need to know the length of the list in advance, it’s an online random algorithm.</p>
<h3 id="Proof-on-Equal-Probability"><a href="#Proof-on-Equal-Probability" class="headerlink" title="Proof on Equal Probability:"></a>Proof on Equal Probability:</h3><p>The $i_{th}$ hat has a probability of $\frac{1}{i}$ of being chosen in its round. The probability of  $i_{th}$ hat being chosen after $n$ times can be given as:</p>
<img src="https://s2.loli.net/2022/01/08/XFk2Rr3On7gaKpM.png" alt="image-20220108005314005" style="zoom: 100%;" />

<p>Which is the multiplication of $i_{th}$ hat being chosen, and all the hats after $i_{th}$ hat not being chosen.</p>
<p>And this RHS equals to $\frac{1}n$, which means every hat has the same probability of being chosen.</p>
<ul>
<li>Link: <a href="https://www.youtube.com/watch?v=A1iwzSew5QY">https://www.youtube.com/watch?v=A1iwzSew5QY</a></li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h3><p>Now let’s implement the Reservoir Sampling into our code, note that we still have to simulate the process of spinning the wheel, using the random function to implement. And it’s generally slower to perform floating point division, use integer instead.</p>
<ul>
<li>Instead of <code>1/i</code>, we have <code>1,2,3…i</code>, but only the <code>1</code> means being chosen</li>
<li><code>i</code> start from <code>1</code>, because it’s not valid to divide by 0.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reservoir sampling</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> ListNode *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// we are not allowed to modify the head pointer itself</span></span><br><span class="line">        <span class="comment">// each round we create a new node to do the trick</span></span><br><span class="line">        <span class="keyword">auto</span> node = head;</span><br><span class="line">        <span class="keyword">int</span> res = head-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// random generate 1~i, only 1 means being selected</span></span><br><span class="line">            <span class="comment">// i should start from 1, or there would be divide by 0 issue</span></span><br><span class="line">            <span class="keyword">bool</span> replace = (<span class="built_in">rand</span>() % (i - <span class="number">1</span> + <span class="number">1</span>)) + <span class="number">1</span> == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (replace)</span><br><span class="line">                res = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1463. Cherry Pickup II</title>
    <url>/2022/01/08/1463.%20Cherry%20Pickup%20II/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>You are given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries where <code>grid[i][j]</code> represents the number of cherries that you can collect from the <code>(i, j)</code> cell.</p>
<p>You have two robots that can collect cherries for you:</p>
<ul>
<li><strong>Robot #1</strong> is located at the <strong>top-left corner</strong> <code>(0, 0)</code>, and</li>
<li><strong>Robot #2</strong> is located at the <strong>top-right corner</strong> <code>(0, cols - 1)</code>.</li>
</ul>
<p>Return <em>the maximum number of cherries collection using both robots by following the rules below</em>:</p>
<ul>
<li>From a cell <code>(i, j)</code>, robots can move to cell <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code>.</li>
<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.</li>
<li>When both robots stay in the same cell, only one takes the cherries.</li>
<li>Both robots cannot move outside of the grid at any moment.</li>
<li>Both robots should reach the bottom row in <code>grid</code>.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png" alt="sample_1_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.</span><br><span class="line">Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.</span><br><span class="line">Total of cherries: 12 + 12 = 24.</span><br></pre></td></tr></table></figure>



<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png" alt="sample_2_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.</span><br><span class="line">Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.</span><br><span class="line">Total of cherries: 17 + 11 = 28.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<blockquote>
<p>We have a maximum input size of 70*70 = 4900, a loose limit would be $O((mn)^2)$.</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><ul>
<li>Each round, each robot would go exactly one step down. And they will always move forward until reaching the end.<ul>
<li>In this way, we can describe the status of two robots by a 3-element tuple <code>(y,x1,x2)</code>. Since <code>#y: row #x: col</code>, there are $O(r*c^2)$ combinations</li>
</ul>
</li>
<li><code>dp[y][x1][x2]</code> means the maximum cherries collected at this combination</li>
<li>Base Case: <code>y&gt;=r, x&lt;0 or x&gt;c</code> (out of bounary), return 0</li>
<li><strong>Transition Equation:</strong> <code>dp[y+1][x1][x2] =&#123;max[y][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0&#125;</code></li>
<li>Time Complexity: $O(r<em>c^2</em>9)$</li>
<li>Space Complexity: $O(r*c^2)$</li>
<li><strong>To get the answer:</strong> find the maximum value in <code>dp[r-1][x1][x2]</code> (traverse)</li>
</ul>
<h3 id="A-Reverse-Solution"><a href="#A-Reverse-Solution" class="headerlink" title="A Reverse Solution:"></a>A Reverse Solution:</h3><p>Robots start at any grid in the last level, and then they go up until one goes to the left corner, the other go to the right corner.</p>
<ul>
<li><p><strong>Transition Equation:</strong> <code>dp[y][x1][x2] =&#123;max[y+1][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0</code>}</p>
</li>
<li><p><strong>To get the answer</strong>: <code>dp[0][0][c-1]</code></p>
</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> triArr = vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">triArr <span class="title">dp</span><span class="params">(r, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(c, vector&lt;<span class="keyword">int</span>&gt;(c, <span class="number">-1</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(<span class="number">0</span>, <span class="number">0</span>, c - <span class="number">1</span>, grid, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// used for recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, triArr &amp;dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; <span class="number">0</span> || x1 &gt;= c || x2 &lt; <span class="number">0</span> || x2 &gt;= c || y &gt;= r || y &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[y][x1][x2];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//if visited return</span></span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = x1 == x2;</span><br><span class="line">        <span class="keyword">int</span> cur = grid[y][x1] + (isSame ? <span class="number">0</span> : grid[y][x2]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d1 = <span class="number">-1</span>; d1 &lt;= <span class="number">1</span>; d1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">-1</span>; d2 &lt;= <span class="number">1</span>; d2++)</span><br><span class="line">            &#123; <span class="comment">// each round find the max one from 9 combinations</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur + <span class="built_in">helper</span>(y + <span class="number">1</span>, x1 + d1, x2 + d2, grid, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//update the answer</span></span><br><span class="line">        dp[y][x1][x2] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>Dynamic Programming</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1345. Jump Game IV</title>
    <url>/2022/01/15/1345.%20Jump%20Game%20IV/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of integers <code>arr</code>, you are initially positioned at the first index of the array.</p>
<p>In one step you can jump from index <code>i</code> to index:</p>
<ul>
<li><code>i + 1</code> where: <code>i + 1 &lt; arr.length</code>.</li>
<li><code>i - 1</code> where: <code>i - 1 &gt;= 0</code>.</li>
<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>
</ul>
<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>
<p>Notice that you can not jump outside of the array at any time.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You do not need to jump.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>-10^8 &lt;= arr[i] &lt;= 10^8</code></li>
</ul>
<blockquote>
<p>The length of the array is up to 10^4, the algorithm is expected to be bounded by ==O(nlogn)==</p>
</blockquote>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Each round, you can jump front or back one step, or jump to the place with the same value.</p>
<ul>
<li>Traverse all possibilities that start from index 0, with <code>#step = 0</code>, <code>minStep = INT_MAX</code><ul>
<li>Each time, try out 3 possibilities, <code>#step++</code><ul>
<li>When reaching the end, update the <code>minStep = min(minStep,#step)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>It’s obvious that this method has a factorial time complexity. We can make a little modification, that is, each place can only be visited at most once, or it can’t be the <code>minimum number of steps</code>.</p>
</blockquote>
<h3 id="An-Graph-like-Intuition"><a href="#An-Graph-like-Intuition" class="headerlink" title="An Graph-like Intuition:"></a>An Graph-like Intuition:</h3><ul>
<li><p>Each place is a node on the graph, nodes are sequentially linked according to their order in the array.</p>
</li>
<li><p>If there are nodes with the same value, link them with an edge.</p>
</li>
<li><p>Since we can move forward and backward at each place, the graph is a undirected graph.</p>
</li>
<li><p>Use BFS for solution (Use queue)</p>
</li>
</ul>
<blockquote>
<p>In actual implementation, a graph is not necessary, we can just keep. a hash map, where key is the value, value is the position of these values.</p>
</blockquote>
<h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity:"></a>Complexity:</h3><p>Vertices = N, Edges at max, all nodes have same value, $O(N^2)$, at min, 0.</p>
<ul>
<li><p>Time Complexity: O(V+E)</p>
</li>
<li><p>Space Complexity: O(V+E) (Use Graph), O(V) (Not using extra graph)</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h3><p>In the implementation, our time complexity depends on the number of edges. In cases of the same value, there could be edges at $O(N^2)$. (All nodes have the same value), which is obviously gonna give us a TLE.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In the BFS Step, after we enqueue nodes with the same value, we can clear the entry in the hash map.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//same value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//core step, this will get us away from redundant search</span></span><br><span class="line">    <span class="comment">//this step ensures nodes of the same value won&#x27;t get enqueued overly</span></span><br><span class="line">    <span class="comment">//actually, enqueue nodes of the same value once is enough</span></span><br><span class="line">    <span class="comment">//so we clear out the entry </span></span><br><span class="line">    sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;value,position&gt;</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; sameValueSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sameValueSet[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shortestPath</span><span class="params">(arr.size(), INT32_MAX)</span></span>;</span><br><span class="line">        shortestPath[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : sameValueSet[arr[<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">            &#125;</span><br><span class="line">            sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortestPath[arr.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">100</span>, <span class="number">-23</span>, <span class="number">-23</span>, <span class="number">404</span>, <span class="number">100</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">404</span>&#125;;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">minJumps</span>(arr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Point Matching - Voting Tree</title>
    <url>/2022/01/17/Point%20Matching%20-%20A%20Voting%20Tree%20Method/</url>
    <content><![CDATA[<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><h3 id="Point-Matching-Problem"><a href="#Point-Matching-Problem" class="headerlink" title="Point Matching Problem:"></a><strong>Point Matching Problem:</strong></h3><p>Given two polygons (each is defined by set of points), return the <strong>best point matching</strong> between the polygons.</p>
<p>To give you a better idea of what a point matching may be look like, here’s an example:</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<p>You can tell that, the match  (a,p), (b,r), (c,q) is not a good match, because $\angle A \ll \angle P$.</p>
<p>In this case, since $ \triangle ABC \sim \triangle QRP$, so we get a good match <code>(c,p),(b,r),(a,q)</code></p>
<p>But you may ask, <strong>Is that match the best match? What is a best matching mathematically?  What if there’s no mathematically similar polygons?</strong>  Well, these problems can be solved by giving our definition of “Good Match”. Through this case, you may get a sense of what is a good match, that is,  <strong>we can define the how well a match is by the similarity between matching points.</strong></p>
<p>A mathematic description is given as below.</p>
<h3 id="Good-Matching"><a href="#Good-Matching" class="headerlink" title="Good Matching:"></a>Good Matching:</h3><h4 id="Similarity-Function"><a href="#Similarity-Function" class="headerlink" title="Similarity Function:"></a>Similarity Function:</h4><p>Follow the principle that: <strong>Define how well a match is by the similarity between matching points.</strong> We have to firstly define a similarity function between two sets of points.</p>
<p>Referencing the similarity function from: <a href="https://ieeexplore.ieee.org/abstract/document/511850"><strong>Zhang Yuefeng. A fuzzy approach to digital image warping. IEEE Computer Graphics and Applications, 1996, 16(6):34~41</strong></a></p>
<p><img src="https://i.loli.net/2021/10/21/vt9GwTJgcPCzl8u.png" alt="image-20211021221008037"></p>
<p>Let’s take a look at the similarity function.</p>
<p>Suppose we have two triangles, edges and angles are denoted as above. The Similarity between these two triangles are defined as above. Note that the Similarity Function has two terms:</p>
<ul>
<li><strong>The Edge similarity term:</strong> measures the similarity with respect to length of edges</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/kqYUpSzE3cO9iBj.png" alt="image-20211021225903082" style="zoom:50%;" />

<ul>
<li><strong>The Angle similarity term:</strong> measures the similarity with respect to angle</li>
</ul>
<img src="https://s2.loli.net/2022/01/17/oBhWea6fQLSIHGq.png" alt="image-20211021230014758" style="zoom:50%;" />

<p>The similarity value is the weighted sum of the two similarity term, by default, we set both weight to 0.5, i.e. $w_1 = 0.5,w_2 = 0.5$.</p>
<p>It’s pretty obvious that, the higher the value is, the higher the similarity is.</p>
<p>$Similarity(T_1,T_2) ==1 \iff T1\triangleq T2$</p>
<h4 id="What-is-a-best-matching"><a href="#What-is-a-best-matching" class="headerlink" title="What is a best matching?"></a>What is a best matching?</h4><p>Now we know that, what means a good matching between two triangles.</p>
<p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y)), where\ X.size== Y.size==3)$</p>
<p><strong>Note that, the higher the similarity function value, the better the matching is.</strong>  In this way, to find out the best triangle matching, we only have to find out two ordered sets of point pairs (with a size of 3), which have the highest similarity function value. And such pair is the best matching by our definition.</p>
<p>Actually, we can extend this Similarity Function to polygons with more than 3 edges.</p>
<h4 id="Best-matching-mathematically"><a href="#Best-matching-mathematically" class="headerlink" title="Best matching, mathematically"></a>Best matching, mathematically</h4><p>$best_{match}(set(A),set(B)) = max(Similarity(set(X),set(Y))$</p>
<p>$where\ X.size== Y.size==min(A.size(),B.size())$</p>
<p>The Similarity of between 2 size n sets match is defined as below:</p>
<img src="https://i.loli.net/2021/10/22/nuXArDg2wFjoEYT.png" alt="image-20211022000404251" style="zoom:50%;" />

<p>Which is simply the <mark>average of all correspoding triangles’ similarity.</mark> (T means Triangle)</p>
<h4 id="Match-Representation-Tree"><a href="#Match-Representation-Tree" class="headerlink" title="Match Representation: Tree"></a>Match Representation: Tree</h4><p>To find out the best possible match, we have to traverse all possible match sequence, but how do we represent an ordered match between two sets of points?  The answer is tree.</p>
<p>We use a tree node, formed by a point pair to denote a possible match. So a possible node is <code>(a,p)</code>, and there’s <code>m*n</code> (<code>m = setA.size()</code>, <code>n = setB.size()</code>) possible nodes in total. And the children of node <code>(a,p)</code> should be next possible match, in this case, if we only take clockwise move into account, the next possible match is either <code>(c,r)</code> or <code>(c,o)</code>.</p>
<img src="https://i.loli.net/2021/10/21/hmfLre1kR9W3Ewj.png" alt="image-20211021214429442" style="zoom:50%;" />

<h5 id="You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule"><a href="#You-may-ask-why-not-c-q-be-the-next-possible-match-This-is-because-we-have-to-follow-another-rule" class="headerlink" title="You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule."></a>You may ask, why not (c,q) be the next possible match?  This is because we have to follow another rule.</h5><h4 id="Yet-another-important-rule-Monotonous"><a href="#Yet-another-important-rule-Monotonous" class="headerlink" title="Yet another important rule: Monotonous"></a>Yet another important rule: Monotonous</h4><p>The word <strong>monotonus</strong>, in this context, meaning moving in the same direction from begining to the end. This means that, you can’t go from r to q (clockwise), and then go from q to o (counter-clockwise). Think about it, a matching subsequence <code>(c,r)(b,q)(a,o)</code> breaks the rule of monotonicity. If you connect $RQ$ and $QO$, you will find that $RQ$ overlaps with $QO$.</p>
<p>In fact, you will find out that generally, if a set of points is not connected in a monotonous order (in the same direction), overlapping and crossing edge could happen.</p>
<img src="https://s2.loli.net/2022/01/17/2YjmF46IlrqugKx.png" alt="PNG图像" style="zoom:50%;" />

<p>So inorder to conform to the monotonous rule, the point matching should be move in a certain and unchanged direction, either clock-wise or counter clockwise.<mark> For simplicity, we assume both of the polygons moves clockwise.</mark> <strong>( This leaves a problem in the case of mirrored polygon matching, because in mirrored polygons, two polygons are connected in different direction )</strong> </p>
<p>Although we can simply don’t take mirrored polygons into account, an intuitive concept solution is given at the end of the report.</p>
<p>Since we only allow clockwise moves, <code>(a,p)(c,q)</code> is not a valid match sequence. </p>
<h4 id="How-many-starting-node"><a href="#How-many-starting-node" class="headerlink" title="How many starting node?"></a>How many starting node?</h4><p>On first thought, you may assume that there’s <code>m*n</code> (<code>m = setA.size(), n = setB.size()</code>)  starting point. However, <strong>the nodes in the triangle are logically equivalent.</strong> In the example, setA has a fewer size of 3, which means in next possible match, the first polygon can only move one step clockwise. And you may already find that, once the starting point of polygon A is fixed, the possible match sequence of A is fixed. However, there’s 4 different possibilities of polygon B with a fixed starting point.</p>
<p>So in this case, <strong>we actually have max(m,n) staring nodes</strong>. And for simplicity, we assume that the polygon A always starts at point A.</p>
<h4 id="Sample-Case-Tree"><a href="#Sample-Case-Tree" class="headerlink" title="Sample Case Tree:"></a>Sample Case Tree:</h4><p>With all that being said, all possible match sequences in the sample case are show as tree below.</p>
<p><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2"></p>
<p>Now we may came up with different methods to find out the best matching, in this representation, <mark><strong>the highest average (or cumulative) similarity path from root to leaf</strong>. </mark>But firstly let me simply introduce some other related works.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Firstly give the number of indicies in each polygon, m and n. Then for next m+n line, each line is consist of x and y coordinate of the index (m first then n) . <strong>The points in each polygon are given in clockwise order, and indexed as 1、2、3…n</strong>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Return the best match in the form of (index1,index2) for m lines (suppose m&lt;n)</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#still the same sample, where line 1-4 are m1~m3, line 5-8 are n1~n4.</span></span><br><span class="line"><span class="comment">#the output (1,2)(2,3)(3,4) means m1 matches n2, m2 matches n3, m3 matches n4</span></span><br><span class="line"><span class="built_in">input</span>:</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">4.25</span> <span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line">output:</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Related-Problems-and-Algorithms"><a href="#Related-Problems-and-Algorithms" class="headerlink" title="Related Problems and Algorithms:"></a>Related Problems and Algorithms:</h3><p>In general, this is a 2D point set registration problem,  is the process of finding a spatial <a href="https://en.wikipedia.org/wiki/Mathematical_transformation">transformation</a> (<em>e.g.,</em> <a href="https://en.wikipedia.org/wiki/Scaling_(geometry)">scaling</a>, <a href="https://en.wikipedia.org/wiki/Rotation">rotation</a> and <a href="https://en.wikipedia.org/wiki/Translation_(geometry)">translation</a>) that aligns two <a href="https://en.wikipedia.org/wiki/Point_cloud">point clouds</a>. </p>
<p>Many different methods have been proposed to solve this problem, from Graph theory, machine learning, and each of them have a different cost function to achieve, in this case, the similarity function.</p>
<h4 id="For-other-algorithms-on-this-problem-Click-for-more"><a href="#For-other-algorithms-on-this-problem-Click-for-more" class="headerlink" title="For other algorithms on this problem (Click for more):"></a><a href="https://en.wikipedia.org/wiki/Point_set_registration#Correspondence-based_registration">For other algorithms on this problem (Click for more):</a></h4><ul>
<li>Iterative Closet Point</li>
<li>RANSAC</li>
<li>Fuzzy Graph Matching</li>
</ul>
<h3 id="Build-Environment-amp-To-Run"><a href="#Build-Environment-amp-To-Run" class="headerlink" title="Build Environment &amp; To Run:"></a>Build Environment &amp; To Run:</h3><p>See <a href="./code/README.md">./code/README.md</a><br>Recommend to open with Typora.</p>
<h3 id="Brief-Description-On-STL-Used"><a href="#Brief-Description-On-STL-Used" class="headerlink" title="Brief Description On STL Used"></a>Brief Description On STL Used</h3><ul>
<li>std::vector<ul>
<li>std::vector is a sequence container for <mark>dynamic size array</mark>.</li>
<li>Elements in vector can be accessed by [] operator, iterators, and offsets to pointers to elements.</li>
<li>The storage of vector is handled automatically, and usually extra memory is allocated for the growth of the vector.</li>
<li>Each time we insert a element to the vector, as long as the extra memory isn’t exhausted, we don’t need to reallocate memory (memory reallocation is expensive).</li>
<li>Time Complexity:<ul>
<li>Random Access: $O(1)$</li>
<li>Insertion or Remove at the end:$O(1)$</li>
<li>Insertion or Remove at the front: $O(n)$</li>
</ul>
</li>
</ul>
</li>
<li><code>std::function</code><ul>
<li><code>std::function</code> is a general wrapper for function, it can store any copyconstructible callable object.</li>
<li>Can be used to store lambda expressions, member functions etc.</li>
<li>One usage is to pass function to function (Like function pointers).<ul>
<li>It has no call overhead</li>
<li>It can capture context variables</li>
</ul>
</li>
</ul>
</li>
<li><code>std::pair</code><ul>
<li>This is used to store 2 different objects in a single unit.</li>
<li>Can be replaced by struct, but std::pair offers a easier way to do so.</li>
<li>To assign value a and b to a <code>pair&lt;int,int&gt;</code><ul>
<li><code>Pair = make_pair(a,b)</code>;</li>
</ul>
</li>
</ul>
</li>
<li><code>std::map</code> (Actually can be replaced by set or vector)<ul>
<li><p>This structure is used to store a key-&gt;value pair</p>
</li>
<li><p>The implementation of Red-Black tree ensures a key-sorted traversal order.</p>
</li>
<li><p>It is implemented by <strong>Red-black tree</strong></p>
<ul>
<li>Search:$O(log(n))$</li>
<li>Insert:$O(log(n))$</li>
<li>Space Complexity:$(O(n))$</li>
</ul>
</li>
<li><p>The basic properties of a red black tree</p>
<ul>
<li>It’s a <strong>self-balanced binary search tree</strong></li>
<li>Each node is either red or black</li>
<li>Root is black</li>
<li>external nodes are black</li>
<li>the children of a red node is black</li>
<li>Any path from external node to root, the number of black nodes along the path are the same.</li>
</ul>
<h4 id="A-sample-red-black-tree"><a href="#A-sample-red-black-tree" class="headerlink" title="A sample red-black tree"></a>A sample red-black tree</h4><img src="https://s2.loli.net/2022/01/17/mrOg85bEWHSvKIN.png" alt="image-20211028155810975" style="zoom:50%;" /></li>
</ul>
</li>
<li><code>std::chrono</code><ul>
<li>This library is used for tracking time with different type of precision.</li>
<li>An massive extension to the time.h</li>
<li><strong>system_clock</strong> offers a wall clock</li>
<li><strong>high_resolution_clock</strong> offers a clock with shortest tick period.</li>
<li><strong>duration</strong> to represent a interval of time.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-2-Algorithm-Specification-Description"><a href="#Chapter-2-Algorithm-Specification-Description" class="headerlink" title="Chapter 2:    Algorithm Specification Description"></a>Chapter 2:    Algorithm Specification Description</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h3><h4 id="Voting-Tree-Idea"><a href="#Voting-Tree-Idea" class="headerlink" title="Voting Tree Idea:"></a>Voting Tree Idea:</h4><img src="https://i.loli.net/2021/10/22/YDSy9XgwINpMKbq.png" alt="PNG图像 2" style="zoom:50%;" />

<p>Now we can introduce the idea of voting tree. Basically a voting tree is <strong>for each unique path from root to the leaf, if the node is present in the path, the point match presented by this node gets a vote</strong>. The higher votes a match get, the more likely this match could be true. For the tree above, $AP$  have 3 votes, $AR$ have 3 votes too, so does $AO$ …</p>
<p>Soon you will find that for this tree, each match have exactly 3 votes. We can’t get any information out of the tree. This is obvious becuase we haven’t use the point pair information stored at each node. We’re just doing arrangement and combinations now.</p>
<h4 id="Why-Pruning"><a href="#Why-Pruning" class="headerlink" title="Why Pruning?"></a>Why Pruning?</h4><p>If we don’t prune the tree (cut off some branches), the voting process can’t give us any useful information. So we have to prune the tree in advance, based on our similarity function. My prune idea is simple, compute the similarity between two triangles, formed by node, node-&gt;parent, node-&gt;child. If the similarity is above a certain threshold, meaning this tree extension could be valid, else, this tree extension is invalid.</p>
<h4 id="Prune-First-Round"><a href="#Prune-First-Round" class="headerlink" title="Prune: First Round"></a>Prune: First Round</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse from root to leaf</span><br><span class="line">    for each node(node.depth&gt;=2)</span><br><span class="line">		for each node.child</span><br><span class="line">		//means not similar enough</span><br><span class="line">    		if(similar(node.parent,node,node.children)&lt;threshold)</span><br><span class="line">    			invalidate(node.children)</span><br><span class="line">    			go deeper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>First round pruning under a high threshold, we only invalidate those nodes(depth&gt;=2)’ children.</p>
<p>In the best case, all nodes(depth&gt;=3) except the best matching has been invalidated.</p>
</blockquote>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%203.png" alt="PNG图像 3" style="zoom:50%;" />

<p><strong>Note that this is actually a greedy algorithm pruning, for each time we only consider the local similarity. And we only leave those branches with high similarity.</strong></p>
<h4 id="Prune-Second-Round"><a href="#Prune-Second-Round" class="headerlink" title="Prune: Second Round"></a>Prune: Second Round</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse from depth 2 leaves to root:</span><br><span class="line">	if(node has no valid children)</span><br><span class="line">		invalidate(node)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This is intuitive since if a node(non-leaf) doesn’t have valid children, meaning the match itself is also invalid. In best case, there is only one valid path from root to leaf.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/nDSgJsMRoz5TZaI.png" alt="PNG图像 4" style="zoom:50%;" />

<p>After the pruning, it’s obvious that, the path present yields a higher chance of best matching, so the tree can be used to vote. <strong>However, this algorithm relies heavily on the threshold, if the threshold is set low, it could produce wrong result, if set overly high, there could be no possible match.</strong> (Test on Part 3)</p>
<h4 id="Trivia"><a href="#Trivia" class="headerlink" title="Trivia:"></a>Trivia:</h4><p>We have 2 similar but slightly different ways to determine the best match after voting to get the 2  bonus points.</p>
<h3 id="How-to-Vote"><a href="#How-to-Vote" class="headerlink" title="How to Vote?"></a>How to Vote?</h3><p>The vote process is a little bit tricky, different nodes have different vote counts. Some of the nodes may appear many times in different unique paths, but many nodes (mostly leaf nodes) only appear once in unique path. If we implement the idea of “unique path”, we have to visit some node many times, this requires backtracking technique. <strong>If we calculate the vote counts of node in advance, we only need to visit each node once,</strong> and that is simple to achieve by level order traversal.</p>
<blockquote>
<p>Leaf node has exactly one vote count, and a non-leaf node.voteCount = sum(children.voteCount)</p>
<p>We have to compute from leaf to root.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/V4ocwS36LkT8dZj.png" alt="PNG图像 6" style="zoom:50%;" />

<blockquote>
<p>After computing vote counts, we just traverse the tree, and vote for the matching, we keep a voting table. Table[node]+=node.voteCount</p>
<p>A Voting Table corresponding to the unpruned tree above.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/22/zWFoClXGudq4Q6L.png" alt="PNG图像 7" style="zoom: 50%;" />



<h3 id="How-to-decide-the-match-out-of-Voting-Table"><a href="#How-to-decide-the-match-out-of-Voting-Table" class="headerlink" title="How to decide the match out of Voting Table?"></a>How to decide the match out of Voting Table?</h3><p><strong>(Bonus is to have 2 different method determine the match)</strong></p>
<h4 id="Simple-Idea-Get-the-first-m-most-votes"><a href="#Simple-Idea-Get-the-first-m-most-votes" class="headerlink" title="Simple Idea:  Get the first m-most votes"></a>Simple Idea:  Get the first m-most votes</h4><blockquote>
<p>To use this method, #define _VOTE_ORDER</p>
</blockquote>
<p>Suppose we have a voting table like this, we have to decide the best match out of the table, we just order them by votes. The result would be <code>(a,q)(c,o)(c,r)</code>.</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%205.png" alt="PNG图像 5" style="zoom:50%;" />

<p>c appears twice in a matching sequence, so this simple idea is sometimes problematic for collision<code>(c,o)</code>and <code>(c,r)</code>, although this isn’t very likely to happen with a properly set threshold.</p>
<h4 id="An-Improved-Idea-for-anti-collision-Vote-By-Row"><a href="#An-Improved-Idea-for-anti-collision-Vote-By-Row" class="headerlink" title="An Improved Idea for anti-collision: Vote By Row"></a>An Improved Idea for anti-collision: Vote By Row</h4><blockquote>
<p>To use this method, #define _ROW_ORDER</p>
</blockquote>
<p>Instead of finding the global max votes, we find out most vote in each row, and in order to avoid collision on a column, after finding the most vote in the row, we set all votes in that column to 0.</p>
<img src="https://i.loli.net/2021/10/22/pZxH7veXsnEOjb9.png" alt="PNG图像 8" style="zoom:50%;" />

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h2><h3 id="Tree-Design"><a href="#Tree-Design" class="headerlink" title="Tree Design:"></a>Tree Design:</h3><p>Now we have to design our tree for implementation. Let’s think about what we need to keep in our tree.</p>
<ul>
<li><p>PointPairs (Storing 2 points’ coordinates)</p>
</li>
<li><p>Indices (2 points’ indices in their polygon)</p>
</li>
<li><p>Depth (In pruning, we have to check whether if a node is of depth 2 or deeper )</p>
</li>
<li><p>Count (Storing the vote count)</p>
</li>
<li><p>isValid (Check if this node need to be pruned or not, check if it is a valid match)</p>
</li>
<li><p>Children (Storing all of it’s children’s address)</p>
</li>
<li><p>Parent (When doing similarity function, we have to pass 3 adjacent nodes, it comes handy if we just pass node, node-&gt;parent, node-&gt;children)</p>
</li>
<li><p>Credit (How many possibilities this node can move, further explanation below)</p>
<blockquote>
<p>Credit indicates how many possibilities a node can move, if a node’s children moves one step, it cost no credit, if more than one step, it cost n-1 credits. The number of credits also indicates the number of children a node can have. </p>
<p>If a node has no credit, it can only move one step further thus have one child. Otherwise, it can move 1<del>n+1 steps, costing 0</del>n credits, thus having n+1 children.</p>
<p>An illustration is below to show the idea of credit.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/wVucOXPY7WM5vek.png" alt="PNG图像 9" style="zoom:50%;" /></li>
</ul>
<p>With credit, you can easily figure out how many children each node can have.</p>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode:"></a>TreeNode:</h3><p>This is all information tree node CR, contains (before pruning).</p>
<img src="/Users/naoyuki/Library/Mobile%20Documents/com~apple~CloudDocs/PNG%E5%9B%BE%E5%83%8F%2010.png" alt="PNG图像 10" style="zoom:50%;" />

<h3 id="Build-Tree-with-pruning"><a href="#Build-Tree-with-pruning" class="headerlink" title="Build Tree with pruning"></a>Build Tree with pruning</h3><p>Now we know that what a tree node is, we have to build the tree.</p>
<p>To get cut down time complexity, we can do pruning while building the tree.</p>
<blockquote>
<p>Assume m&lt;n, if not, swap them.</p>
</blockquote>
<ol>
<li><p>Firstly, we build the depth 1 nodes (initial match), given with n-m credits each.</p>
</li>
<li><p>For each depth 1 nodes we recursively build subtree by using helper function.</p>
</li>
<li><p>In the helper function, we pass in a node</p>
<ol>
<li>if the node reaches depth m, means a full match, return</li>
<li>if the node has no credit, means it can only move 1 step further, move, check similarity, if valid then extend and return, if not, don’t extend and return.</li>
<li>if the node has some credits, means it can have credits+1 children, for each children, check similarity, if valid, extend, and pass children to the helper function for recursive call. if not valid, don’t extend, check the next children.</li>
</ol>
</li>
</ol>
<h3 id="Futher-Pruning-Second-Round"><a href="#Futher-Pruning-Second-Round" class="headerlink" title="Futher Pruning (Second Round)"></a>Futher Pruning (Second Round)</h3><p>A top-down approach.</p>
<ol>
<li>Pass the node, if it has a valid children, it is valid. If not, set node.isValid to false, return.</li>
<li>For each children of the node, if it has a valid children, it’s valid. If it doesn’t have children and is depth&lt;m , meaning its children have been pruned while build tree, set node.isValid to false, return.</li>
<li>Recursively call this function step 1~2</li>
</ol>
<h3 id="Level-Order-Traversal"><a href="#Level-Order-Traversal" class="headerlink" title="Level Order Traversal"></a>Level Order Traversal</h3><p>To compute vote count bottom up, it would be convenient if we do level order traversal first.</p>
<p>We implement level order by 2 vectors, curr and next, indicating the nodes to process in this level and next level. We store the result in res vector. (<code>vector&lt;vector&lt;TreeNode*&gt;&gt;</code>)</p>
<ol>
<li>Push root node into curr</li>
<li>While(curr is not empty), push curr to res, traverse all nodes in curr, for each node, we push all its children to next, finally swap(curr,next).</li>
</ol>
<h3 id="Compute-Vote-Count"><a href="#Compute-Vote-Count" class="headerlink" title="Compute Vote Count"></a>Compute Vote Count</h3><ol>
<li>get level order traversal result</li>
<li>start from the last level if it’s valid it has 1 vote count.</li>
<li>For each level, it’s vote count equals to sum of its valid children’s vote count. Iteration ends at depth 1 (Don’t consider root)</li>
</ol>
<h3 id="Voting"><a href="#Voting" class="headerlink" title="Voting:"></a>Voting:</h3><ol>
<li>traverse the tree by level order</li>
<li>The corresponding <code>term +=voteCount</code><ol>
<li>RowOrder: For each row in the table, find the max, set column of max to zero</li>
<li>SimpleIdea: Find the m-most votes in the table.</li>
</ol>
</li>
</ol>
<h2 id="Solution-2-Non-Voting"><a href="#Solution-2-Non-Voting" class="headerlink" title="Solution 2: Non-Voting"></a>Solution 2: Non-Voting</h2><p>Because we apply greedy pruning to our tree, sometimes we may only get the local best match instead of global best. Remeber that, in chapter 1, our goal is to find a path from root to leaf,<mark> with a largest average similarity of corresponding triangles.</mark></p>
<p>In this method, we simply don’t prune, and while we building tree, we keep track of the cumulative similarities of corresponding triangles. <mark>And we get the global best by simply find out the leaf node which havethe largest cumulative similarity.</mark></p>
<p><strong>This method is not reliant on parameters, and ensures a global best match under our definition.</strong></p>
<h4 id="TreeNode-add-a-cumulativeSim-member"><a href="#TreeNode-add-a-cumulativeSim-member" class="headerlink" title="TreeNode: add a cumulativeSim member"></a>TreeNode: add a cumulativeSim member</h4><h4 id="BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity"><a href="#BuildTree-Almost-the-same-without-pruning-keep-track-of-cumulative-similarity" class="headerlink" title="BuildTree: Almost the same, without pruning, keep track of cumulative similarity"></a>BuildTree: Almost the same, without pruning, keep track of cumulative similarity</h4><h4 id="Further-Pruning-No-need"><a href="#Further-Pruning-No-need" class="headerlink" title="Further Pruning: No need"></a>Further Pruning: No need</h4><h4 id="Level-Order-Traversal-Same"><a href="#Level-Order-Traversal-Same" class="headerlink" title="Level Order Traversal: Same"></a>Level Order Traversal: Same</h4><h4 id="Get-Result"><a href="#Get-Result" class="headerlink" title="Get Result:"></a>Get Result:</h4><ol>
<li>For the last level of the level order traversal (which is actually all the leaf nodes):</li>
<li>Get the node with max cumulative similarity</li>
<li>Trace back this node until root.</li>
</ol>
<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><h3 id="Correctness-Validation-With-A-Strict-Threshold-0-9"><a href="#Correctness-Validation-With-A-Strict-Threshold-0-9" class="headerlink" title="Correctness Validation: With A Strict Threshold = 0.9"></a>Correctness Validation: With A Strict Threshold = 0.9</h3><h4 id="Case-1-Sample-Case"><a href="#Case-1-Sample-Case" class="headerlink" title="Case 1: Sample Case"></a>Case 1: Sample Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct"><a href="#ROW-ORDER-Correct" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/Wf4mdv6nYpXGLij.png" alt="image-20211023011656249"></p>
<h4 id="SIMPLE-IDEA-Correct"><a href="#SIMPLE-IDEA-Correct" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/hA8qgKXZjfJe27M.png" alt="image-20211023011856088"></p>
<h4 id="NON-VOTING-Correct"><a href="#NON-VOTING-Correct" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/yMLWOv2CGYBoT3w.png" alt="image-20211023011927482"></p>
<h4 id="Case-2-A-1x1-square-and-a-2x2-square"><a href="#Case-2-A-1x1-square-and-a-2x2-square" class="headerlink" title="Case 2: A 1x1 square and a 2x2 square"></a>Case 2: A 1x1 square and a 2x2 square</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-1"><a href="#ROW-ORDER-Correct-1" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="https://i.loli.net/2021/10/23/mw7N2y5vsAK4eXc.png" alt="image-20211023012132695"></p>
<h4 id="SIMPLE-IDEA-Wrong"><a href="#SIMPLE-IDEA-Wrong" class="headerlink" title="SIMPLE_IDEA: Wrong"></a>SIMPLE_IDEA: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/wVcTFonM4X6j3qC.png" alt="image-20211023012203375"></p>
<h4 id="NON-VOTING-Correct-1"><a href="#NON-VOTING-Correct-1" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/3YBdRvUhf8HNZe4.png" alt="image-20211023012224618"></p>
<h4 id="Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon"><a href="#Case-3-A-small-triangle-and-a-pentagon-the-triangle-is-a-subset-of-pentagon" class="headerlink" title="Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon"></a>Case 3:A small triangle and a pentagon, the triangle is a subset of pentagon</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Correct-2"><a href="#ROW-ORDER-Correct-2" class="headerlink" title="ROW_ORDER: Correct"></a>ROW_ORDER: Correct</h4><p><img src="/Users/naoyuki/Library/Application%20Support/typora-user-images/image-20211023012422694.png" alt="image-20211023012422694"></p>
<h4 id="SIMPLE-IDEA-Correct-1"><a href="#SIMPLE-IDEA-Correct-1" class="headerlink" title="SIMPLE_IDEA: Correct"></a>SIMPLE_IDEA: Correct</h4><p><img src="https://i.loli.net/2021/10/23/msa17Due6tYdSJC.png" alt="image-20211023012443966"></p>
<h4 id="NON-VOTING-Correct-2"><a href="#NON-VOTING-Correct-2" class="headerlink" title="NON_VOTING: Correct"></a>NON_VOTING: Correct</h4><p><img src="https://i.loli.net/2021/10/23/ydZE2seXj1QNM9g.png" alt="image-20211023012508740"></p>
<h4 id="Case-4-Large-Number-M-21-N-28-performance-test"><a href="#Case-4-Large-Number-M-21-N-28-performance-test" class="headerlink" title="Case 4: Large Number(M=21,N=28), performance test"></a>Case 4: Large Number(M=21,N=28), performance test</h4><h4 id="ROW-ORDER-0-005-sec"><a href="#ROW-ORDER-0-005-sec" class="headerlink" title="ROW_ORDER: 0.005 sec"></a>ROW_ORDER: 0.005 sec</h4><h4 id="SIMPLE-IDEA-0-005-sec"><a href="#SIMPLE-IDEA-0-005-sec" class="headerlink" title="SIMPLE_IDEA: 0.005 sec"></a>SIMPLE_IDEA: 0.005 sec</h4><h4 id="NON-VOTING-7-81-sec"><a href="#NON-VOTING-7-81-sec" class="headerlink" title="NON_VOTING: 7.81 sec"></a>NON_VOTING: 7.81 sec</h4><h4 id="Case-5-Mirror-case"><a href="#Case-5-Mirror-case" class="headerlink" title="Case 5: Mirror case"></a>Case 5: Mirror case</h4><p>Test if the algorithm can get the best match if two polygons are mirrored to each other.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ROW-ORDER-Not-Found"><a href="#ROW-ORDER-Not-Found" class="headerlink" title="ROW_ORDER: Not Found"></a>ROW_ORDER: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013827652"></p>
<h4 id="SIMPLE-IDEA-Not-Found"><a href="#SIMPLE-IDEA-Not-Found" class="headerlink" title="SIMPLE_IDEA: Not Found"></a>SIMPLE_IDEA: Not Found</h4><p><img src="https://i.loli.net/2021/10/23/LH2Ne68XWdapUsO.png" alt="image-20211023013829051"></p>
<h4 id="NON-VOTING-Wrong"><a href="#NON-VOTING-Wrong" class="headerlink" title="NON_VOTING: Wrong"></a>NON_VOTING: Wrong</h4><p><img src="https://i.loli.net/2021/10/23/JzEHr6eXlLbQok7.png" alt="image-20211023013749859"></p>
<p>A solution will be proposed in chapter 4.</p>
<h4 id="Correctness-Table-For-5-test-cases"><a href="#Correctness-Table-For-5-test-cases" class="headerlink" title="Correctness Table (For 5 test cases)"></a>Correctness Table (For 5 test cases)</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
<td>NOT APPLICABLE</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<h3 id="Hacking-Cases-During-Peer-Review"><a href="#Hacking-Cases-During-Peer-Review" class="headerlink" title="Hacking Cases During Peer Review"></a>Hacking Cases During Peer Review</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 11</span><br><span class="line">A:(-4,2)(-2,2)(-2,4)(-4,4)</span><br><span class="line">B:(-2 -2)(-1 -2)(-1 -1)(2 2)(4 1)(5 3)(3 4)(3 6)(1 6)(1 4)(-2 -1)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">(2 -4) (4 -4)(6 -2)(4 0)(2 0)</span><br><span class="line">(-5 5)(-8 2)(-8 -1)(-6 -1)(-6 -4)(-4 -4)(-4 -1)(-2 -1)(-2 2)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<blockquote>
<h3 id="Major-Problem"><a href="#Major-Problem" class="headerlink" title="Major Problem:"></a>Major Problem:</h3><ul>
<li>The NON_VOTING Method has a comparatively high correctness rate, but the problem is that, it has a high time complexity, which makes it very hard to handle large cases（Acceptable M,N&lt;25）.</li>
<li>The other 2 solutions has a somewhat simple and fast performance, but not that good in the correctness.</li>
</ul>
</blockquote>
<h3 id="Parameters-Test"><a href="#Parameters-Test" class="headerlink" title="Parameters Test:"></a>Parameters Test:</h3><p>Only run sample cases, set threshold differently.</p>
<ul>
<li>Threshold: 0.1<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.3<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.5<ul>
<li>ROW_ORDER: Wrong</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.75<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Wrong</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
<li>Threshold: 0.9<ul>
<li>ROW_ORDER: Correct</li>
<li>SIMPLE IDEA: Correct</li>
<li>NON_VOTING: Correct</li>
</ul>
</li>
</ul>
<p>A good general threshold would be around 0.8~0.9.</p>
<h4 id="Correctness-Table-For-5-thresholds"><a href="#Correctness-Table-For-5-thresholds" class="headerlink" title="Correctness Table: For 5 thresholds"></a>Correctness Table: For 5 thresholds</h4><table>
<thead>
<tr>
<th>SIMPLE_IDEA</th>
<th>ROW_ORDER</th>
<th>NON_VOTING</th>
<th>Threshold</th>
</tr>
</thead>
<tbody><tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.1</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.3</td>
</tr>
<tr>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>0.5</td>
</tr>
<tr>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>0.75</td>
</tr>
<tr>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>0.9</td>
</tr>
</tbody></table>
<h3 id="Extra-Comparison-with-Iterative-Closet-Points"><a href="#Extra-Comparison-with-Iterative-Closet-Points" class="headerlink" title="Extra Comparison with Iterative Closet Points:"></a>Extra Comparison with Iterative Closet Points:</h3><p>I tried with Python, using sklearn package to run this method. Using a 2 sets of 30 points. Find one number of pair. Feed the same data with voting tree, it can’t find a full match and thus return.</p>
<blockquote>
<p>The voting tree assumes a good matching with average similarity&gt;=threshold because our pruning.</p>
<p>The non_voting method, on the other hand, returns the best matching possible, though it can be lower than the threshold.</p>
</blockquote>
<img src="https://i.loli.net/2021/10/23/eTJsu3D2RjxgPdm.png" alt="image-20211023014901237" style="zoom:50%;" />

<p>On a small set of data (e.g. the sample case), the ICP solution can’t converge due to small amount of set size. However, if provided with a reasonable similar point set with a medium size (say, over 30). ICP method is reliable.</p>
<p>Besides, ICP has another strength is that, it can return partial matching, when there’s not a full match, it will return a partial match instead.</p>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4:    Analysis and Comments"></a>Chapter 4:    Analysis and Comments</h2><h3 id="1-Build-Tree"><a href="#1-Build-Tree" class="headerlink" title="1.Build Tree:"></a>1.Build Tree:</h3><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ol>
<li>Build depth 1 children takes O(n) time, there are n nodes at depth 1.</li>
<li>Using build helper to recursively build subtree takes $ O(n*T_{helper}(X))$</li>
</ol>
<p>Since each node only takes O(1) to insert, the overall build tree time complexity equals to the number of nodes.</p>
<h4 id="The-number-of-nodes-are"><a href="#The-number-of-nodes-are" class="headerlink" title="The number of nodes are:"></a>The number of nodes are:</h4><p>$n<em>A^m_m = n</em>m!$</p>
<h4 id="Overall-Time-Complexity-Without-Pruning-O-n-m"><a href="#Overall-Time-Complexity-Without-Pruning-O-n-m" class="headerlink" title="Overall Time Complexity (Without Pruning): $O(n*m!)$"></a>Overall Time Complexity (Without Pruning): $O(n*m!)$</h4><blockquote>
<p>Actually <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The time complexity can be reduced to $O(n^2)$ , since there are  n*(n-m+1) nodes at depth 2 without pruning.</mark></p>
</blockquote>
<h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><p>The Space Complexity = RecursionDepth*Recursion_assisted_space + size of tree.</p>
<ul>
<li>Recursion Term: Recursion Depth = m (match at most m times)</li>
<li>$tree_size= n<em>m!</em>(node_size) = n*m!<em>O(n-m) = O(n^2</em>m!)$</li>
</ul>
<h4 id="Overall-Space-Complexity-Without-Pruning-O-n-2-m"><a href="#Overall-Space-Complexity-Without-Pruning-O-n-2-m" class="headerlink" title="Overall Space Complexity (Without Pruning): $O(n^2*m!)$"></a>Overall Space Complexity (Without Pruning): $O(n^2*m!)$</h4><blockquote>
<p>Samely <strong>if we apply a rigorous threshold, and do pruning while building tree,</strong> we will only keep nodes at level 2 or shallower, and only one possible match down to the leaf.  <mark>The space complexity can be reduced to $O(n^3)$ , since there are $ n*(n-m+1)$ nodes at depth 2 without pruning. And each takes up to $O(n-m)$ space since it stores its children.</mark></p>
</blockquote>
<h3 id="2-Futher-Pruning"><a href="#2-Futher-Pruning" class="headerlink" title="2.Futher Pruning:"></a>2.Futher Pruning:</h3><h4 id="Time-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Time-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Time Complexity (With rigorous pruning while build tree):"></a>Time Complexity (With rigorous pruning while build tree):</h4><ol>
<li>In this step, we at most prune almost all nodes at depth 2 and some at depth 1, since if we use build-time pruning at step 1, most of nodes will not grow deeper than depth 2.</li>
<li>For each node, we check its children (n-m at most)  if its valid or not. And set isValid accordingly. </li>
</ol>
<ul>
<li>Number of check &lt;=$ (depth 1 +depth 2)<em>(n-m) = (n+n</em>(n-m+1))*(n-m) = $O(n^3)$</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-3"><a href="#Overall-Time-Complexity-O-n-3" class="headerlink" title="Overall Time Complexity: $O(n^3)$"></a>Overall Time Complexity: $O(n^3)$</h4><blockquote>
<p>If not doing a rigorous pruning step while building, it takes nearly <strong>O(n*m!)</strong> to do the pruning</p>
</blockquote>
<h4 id="Space-Complexity-With-rigorous-pruning-while-build-tree"><a href="#Space-Complexity-With-rigorous-pruning-while-build-tree" class="headerlink" title="Space Complexity (With rigorous pruning while build tree):"></a>Space Complexity (With rigorous pruning while build tree):</h4><ul>
<li>This step doesn’t need extra space for memoization. However, it takes space for recursion. The space complexity equals to the max depth of the recursion, which is $O(m)$, since we the most depth is no deeper than 2 because of build-time pruning, except the best match path, takes $O(m)$ space for recursion.</li>
</ul>
<blockquote>
<p>If not doing a rigorous pruning step while building, it still takes <strong>O(m)</strong> to do the pruning, since the max depth is still $O(m)$</p>
</blockquote>
<h4 id="Overall-Space-Complexity-O-m"><a href="#Overall-Space-Complexity-O-m" class="headerlink" title="Overall Space Complexity: $O(m)$"></a>Overall Space Complexity: $O(m)$</h4><h3 id="3-Level-Order-Traversal"><a href="#3-Level-Order-Traversal" class="headerlink" title="3.Level Order Traversal"></a>3.Level Order Traversal</h3><h4 id="Time-Complexity-With-rigorous-pruning"><a href="#Time-Complexity-With-rigorous-pruning" class="headerlink" title="Time Complexity (With rigorous pruning):"></a>Time Complexity (With rigorous pruning):</h4><ul>
<li>Level Order traversal visit each node only once, which takes O(1) time, there are O(n^2) nodes if pruned rigorously.</li>
<li>If not pruned rigorously, in worst case, it could produce a result of O(n*m!)</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m"><a href="#Overall-Time-Complexity-Depend-On-Pruning-O-n-2-O-n-m" class="headerlink" title="Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$"></a>Overall Time Complexity (Depend On Pruning): $(O(n^2),O(n*m!))$</h4><h4 id="Space-Complexity-With-rigorous-pruning"><a href="#Space-Complexity-With-rigorous-pruning" class="headerlink" title="Space Complexity (With rigorous pruning):"></a>Space Complexity (With rigorous pruning):</h4><ul>
<li>Level Order Traversal stores each node, each takes up to O(n) space.</li>
</ul>
<h4 id="Overall-Space-Complexity-O-n-2-O-n-m"><a href="#Overall-Space-Complexity-O-n-2-O-n-m" class="headerlink" title="Overall Space Complexity:  $(O(n^2),O(n*m!))$"></a>Overall Space Complexity:  $(O(n^2),O(n*m!))$</h4><h3 id="4-Compute-Vote-Count"><a href="#4-Compute-Vote-Count" class="headerlink" title="4.Compute Vote Count"></a>4.Compute Vote Count</h3><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>This is similar to pruning step. We only compute those valid nodes, and check their children.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-n-3-O-n-2-m" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$"></a>Overall Time Complexity (Depends On Pruning): $(O(n^3),O(n^2*m!))$</h4><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>Space takes for recursion is the same as pruning step</li>
</ul>
<h4 id="Overall-Space-Complexity-O-m-1"><a href="#Overall-Space-Complexity-O-m-1" class="headerlink" title="Overall Space Complexity : $O(m)$"></a>Overall Space Complexity : $O(m)$</h4><h3 id="5-Voting"><a href="#5-Voting" class="headerlink" title="5.Voting"></a>5.Voting</h3><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>Once again, we traverse the tree, and each time we vote to either a map or 2D array.</li>
<li>There are up to $O(n*m!)$ nodes if not well pruned, but at least O(m) nodes.</li>
<li>If we uses a <code>std::map</code> for voting, this takes $O(log(n))$ time for insert, while 2D array only takes $O(1)$</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n"><a href="#Overall-Time-Complexity-Depends-On-Pruning-O-m-O-n-m-log-n" class="headerlink" title="Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$"></a>Overall Time Complexity (Depends On Pruning): $(O(m),O(n*m!*log(n)))$</h4><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>We keeps either a map or 2D array, the overall space is up to all possible pairs, which is <strong>n*m</strong>, <strong>but at least m</strong>, which means only one valid path after pruning.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m"><a href="#Overall-Time-Complexity-Depend-on-table-structure-O-m-O-n-m" class="headerlink" title="Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$"></a>Overall Time Complexity (Depend on table structure) : $(O(m),O(n*m))$</h4><h3 id="6-Decide-Match-Voting"><a href="#6-Decide-Match-Voting" class="headerlink" title="6.Decide Match (Voting)"></a>6.Decide Match (Voting)</h3><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>SIMPLE_IDEA searches the largest m element in the table, if use sorting, this could takes, O(nlogn) times where n is the number of nodes.</li>
<li>ROW_ORDER searches the largest element in each line, which takes O(n*m) times, since there’re n rows and m columns.</li>
</ul>
<h4 id="Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m"><a href="#Overall-Time-Complexity-Depends-Table-Structure-O-nlogn-O-n-m" class="headerlink" title="Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$"></a>Overall Time Complexity (Depends Table Structure): $(O(nlogn),O(n*m))$</h4><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps we use a vector to assist our 2D sorting. Which takes up to O(m) space.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-m"><a href="#Overall-Time-Complexity-O-m" class="headerlink" title="Overall Time Complexity : $O(m)$"></a>Overall Time Complexity : $O(m)$</h4><h3 id="7-Decide-Match-Non-Voting"><a href="#7-Decide-Match-Non-Voting" class="headerlink" title="7.Decide Match (Non Voting)"></a>7.Decide Match (Non Voting)</h3><h4 id="Time-Complexity-4"><a href="#Time-Complexity-4" class="headerlink" title="Time Complexity:"></a>Time Complexity:</h4><ul>
<li>We only visit leaf nodes and find out the node with maximum cumulative similarity.</li>
<li>And then we trace back to root from that node.</li>
<li>There are at most $(n*m!)$ leaf nodes at depth m, since we don’t prune in a non-voting method. Trace back only takes O(m) time.</li>
</ul>
<h4 id="Overall-Time-Complexity-O-n-m"><a href="#Overall-Time-Complexity-O-n-m" class="headerlink" title="Overall Time Complexity: $O(n*m!)$"></a>Overall Time Complexity: $O(n*m!)$</h4><h4 id="Space-Complexity-4"><a href="#Space-Complexity-4" class="headerlink" title="Space Complexity:"></a>Space Complexity:</h4><ul>
<li>This steps only takes constant space for storing the maximum cumulative similarity and its node..</li>
</ul>
<h4 id="Overall-Time-Complexity-O-1"><a href="#Overall-Time-Complexity-O-1" class="headerlink" title="Overall Time Complexity : $O(1)$"></a>Overall Time Complexity : $O(1)$</h4><h3 id="OVERALL"><a href="#OVERALL" class="headerlink" title="OVERALL"></a>OVERALL</h3><table>
<thead>
<tr>
<th align="left">SIMPLE_IDEA (USE MAP AND VECTOR)</th>
<th>ROW_ORDER(USE 2D VECTOR)</th>
<th>NON_VOTING</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n^2*m!)$ (Not pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n^3)$ (Pruning well)</td>
<td>Time Complexity: $O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$ (Not Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left">Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n^3)$ ( Pruning Well)</td>
<td>Space Complexity:$O(n*m!)$</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>It’s pretty obvious that, if we apply set up a good threshold, the ROW_ORDER and SIMPLE_IDEA both can have great time complexity performance. While the NON_VOTING method is an exponential method although it ensures correctness.</p>
</blockquote>
<h3 id="Extra-How-to-solve-the-problem-of-Mirrored-Case"><a href="#Extra-How-to-solve-the-problem-of-Mirrored-Case" class="headerlink" title="Extra: How to solve the problem of Mirrored Case"></a>Extra: How to solve the problem of Mirrored Case</h3><p>The reason we don’t get a good match when facing the mirrored case is that, we assume both polygons move in the same direction. And the solution is simple. </p>
<p>We add another n nodes at depth one, assume those point pairs moves in opposite direction, assume the first move clockwise and the second move counterclockwise. In this way, we can fix the problem.</p>
<img src="https://i.loli.net/2021/10/23/dswPBx9S4plfatK.png" alt="PNG图像 11" style="zoom:67%;" />

<p>Nodes in red colors are indicating two polygons move in opposite direction, while the blue color ones move in the same direction. This address the mirror problem.</p>
<h2 id="Appendix-Source-Code-in-C-11"><a href="#Appendix-Source-Code-in-C-11" class="headerlink" title="Appendix:    Source Code (in C++11)"></a>Appendix:    Source Code (in C++11)</h2><h4 id="tree-hpp"><a href="#tree-hpp" class="headerlink" title="tree.hpp"></a>tree.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">structure of the treenode</span></span><br><span class="line"><span class="comment">@memebers:</span></span><br><span class="line"><span class="comment">pointPair(contains the pair of points)</span></span><br><span class="line"><span class="comment">indices(contains the indices of points)</span></span><br><span class="line"><span class="comment">count(how many votes this node have)</span></span><br><span class="line"><span class="comment">isValid(if this node is a valid match, used for pruning)</span></span><br><span class="line"><span class="comment">depth(depth of the node)</span></span><br><span class="line"><span class="comment">credits(how many credits this node can spend, see report for details.</span></span><br><span class="line"><span class="comment">basically, a node with n credits can have n+1 child)</span></span><br><span class="line"><span class="comment">parent(the parent of the node)</span></span><br><span class="line"><span class="comment">children(the children of the node,indexing by the number of children)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//default constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pointPair.first = <span class="built_in">Point</span>();</span><br><span class="line">        pointPair.second = <span class="built_in">Point</span>();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        isValid = <span class="literal">true</span>;</span><br><span class="line">        parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(Point &amp;a, Point &amp;b, TreeNode *parent, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, <span class="keyword">int</span> depth, <span class="keyword">int</span> credit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pointPair = std::<span class="built_in">make_pair</span>(a, b);</span><br><span class="line">        <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">        <span class="keyword">this</span>-&gt;depth = depth;</span><br><span class="line">        <span class="keyword">this</span>-&gt;credits = credit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//corresponding points&#x27; coordinates</span></span><br><span class="line">    std::pair&lt;Point, Point&gt; pointPair;</span><br><span class="line">    <span class="comment">//points&#x27; index respectively</span></span><br><span class="line">    std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="comment">//how many votes it has, valid leaf node has 1 vote</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//check if the match is valid</span></span><br><span class="line">    <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//the depth of current node</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//how many credits it can use</span></span><br><span class="line">    <span class="keyword">int</span> credits = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cumulative similarity along the path</span></span><br><span class="line">    <span class="keyword">float</span> cumulativeSim = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//parent node</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="comment">//we use points pairs&#x27; indices as key to get the TreeNode*</span></span><br><span class="line">    <span class="comment">//e.g. children[pair(1,2)] means get a children with pointsA[1] and pointsB[2]</span></span><br><span class="line">    std::map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, TreeNode *&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the structure of the tree</span></span><br><span class="line"><span class="comment">@members:</span></span><br><span class="line"><span class="comment">root (root of the tree)</span></span><br><span class="line"><span class="comment">m,n (the size of point sets)</span></span><br><span class="line"><span class="comment">buildTree (build tree of point sets, with some pruning)</span></span><br><span class="line"><span class="comment">printTree (print all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">invalidate (pruning step, see report for details)</span></span><br><span class="line"><span class="comment">levelOrder (get all valid nodes in the tree, by level order)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Tree</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees,but this time we don&#x27;t pruning, used for non-voting method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelperWithoutPruning</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// the children&#x27;s index, only move one step</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            <span class="comment">// ready to calculate similarity</span></span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">// set new child, and assign similarity</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            node-&gt;children[idx]-&gt;cumulativeSim = node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children, node with k credits can have k+1 children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">// first index only move one step</span></span><br><span class="line">                <span class="comment">// second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//generate new child</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//only nodes with depth&gt;2 have valid parent and child</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123; <span class="comment">//compute and assign similarity</span></span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    node-&gt;children[idx]-&gt;cumulativeSim += node-&gt;cumulativeSim + Geo::<span class="built_in">similarity</span>(a, b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given a node and its indices, build its subtrees</span></span><br><span class="line">    <span class="comment">//this is with build time pruning</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildHelper</span><span class="params">(TreeNode *node, std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if it reaches the max depth, don&#x27;t extend further</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;depth == m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has no credits, it can only have one child</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;credits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//check if the child is valid by comparing the triangle formed by point sets</span></span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + <span class="number">1</span>) % n);</span><br><span class="line">            vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">            vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">            <span class="comment">//if similarity is below the threshold, don&#x27;t extend, set the node to invalid</span></span><br><span class="line">            <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if it has no children, this node itself is also not possible</span></span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if similarity is above the threshold, extend it with the last node</span></span><br><span class="line">            node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, m, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if it still have credits, node can have credies+1 children</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//generate new children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; node-&gt;credits + <span class="number">2</span>; i++)</span><br><span class="line">            &#123; <span class="comment">//second index can move 1~credits+1 steps</span></span><br><span class="line">                <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(indices.first + <span class="number">1</span>, (indices.second + i) % n);</span><br><span class="line">                <span class="comment">//pruning step, if the depth of node is same of greater than 2</span></span><br><span class="line">                <span class="comment">//check 2 triangles form by its parent and child and itself are similar</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;depth &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;Point&gt; a&#123;node-&gt;parent-&gt;pointPair.first, node-&gt;pointPair.first, pointsA[idx.first]&#125;;</span><br><span class="line">                    vector&lt;Point&gt; b&#123;node-&gt;parent-&gt;pointPair.second, node-&gt;pointPair.second, pointsB[idx.second]&#125;;</span><br><span class="line">                    <span class="comment">//if not similar, don&#x27;t extend</span></span><br><span class="line">                    <span class="keyword">if</span> (Geo::<span class="built_in">similarity</span>(a, b) &lt; Geo::threshold)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it&#x27;s shallower or is similar, extend</span></span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], node, idx, node-&gt;depth + <span class="number">1</span>, node-&gt;credits - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//check after the generate step, if the node have children</span></span><br><span class="line">            <span class="comment">//if it have no children, meaning the current match is invalid</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//build subtrees for each child of current node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, with build time pruning.</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelper</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buildTree from two lists of points, but no pruning this time;</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTreeWithoutPruning</span><span class="params">(TreeNode *root, vector&lt;Point&gt; &amp;pointsA, vector&lt;Point&gt; &amp;pointsB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//always keep pointsA having less or same points</span></span><br><span class="line">        <span class="keyword">int</span> m = pointsA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = pointsB.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line">            std::<span class="built_in">swap</span>(m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root node has n children, each children has n-m credits and depth 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> idx = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, i);</span><br><span class="line">            root-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pointsA[idx.first], pointsB[idx.second], root, idx, <span class="number">1</span>, n - m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for the rest nodes, using helper(without pruning) function to build the subtree</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buildHelperWithoutPruning</span>(kv.second, kv.first, pointsA, pointsB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invalidate the node if it has no children, or all of its children are invalid</span></span><br><span class="line">    <span class="comment">//top-down</span></span><br><span class="line">    <span class="comment">//FURTHER PRUNING IN THE REPORT</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if the node has no children and it&#x27;s not a leaf</span></span><br><span class="line">        <span class="comment">//meaning that the node is invalid</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; node-&gt;depth &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it has children</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;isValid = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//if some of its children are valid, the node should be valid</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;isValid = node-&gt;isValid || kv.second-&gt;isValid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this means the node has no valid children</span></span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;isValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invalidate the children of the node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">invalidate</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print tree node indices by level order, but only print those valid</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nodes = <span class="built_in">levelOrder</span>(root);</span><br><span class="line">        <span class="comment">//skip the dummy root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.first &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="number">1</span> + nodes[i][j]-&gt;indices.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the nodes of trees by level order</span></span><br><span class="line">    vector&lt;vector&lt;TreeNode *&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;TreeNode *&gt;&gt; ans;</span><br><span class="line">        vector&lt;TreeNode *&gt; cur, next;</span><br><span class="line">        <span class="comment">//the nodes to process in current/next step;</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">push_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!cur.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : node-&gt;children)</span><br><span class="line">                    <span class="comment">//only process valid nodes</span></span><br><span class="line">                    <span class="keyword">if</span> (kv.second-&gt;isValid)</span><br><span class="line">                        next.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(cur, next);</span><br><span class="line">            next.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="geometry-hpp"><a href="#geometry-hpp" class="headerlink" title="geometry.hpp"></a>geometry.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">store the coordinate of a 2D point</span></span><br><span class="line"><span class="comment">With some computing method</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// format the point</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="keyword">this</span>-&gt;y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Some utility functions of Geometric computation</span></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threshold of similarity between two polygons</span></span><br><span class="line">    <span class="comment">// a good threshold is 0.7~0.9 in simple case</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> threshold = <span class="number">0.9f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    convert radians to degrees</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">toDegree</span><span class="params">(<span class="keyword">float</span> rad)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rad * <span class="number">180.f</span> / pi;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get length of the edge between two points;</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">(Point &amp;a, Point &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> dx = <span class="built_in">abs</span>(a.x - b.x);</span><br><span class="line">        <span class="keyword">float</span> dy = <span class="built_in">abs</span>(a.y - b.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrtf</span>(dx * dx + dy * dy);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @description: a is in the middle of b and c</span></span><br><span class="line"><span class="comment">    this functions returns the angle CAB or simply angle A</span></span><br><span class="line"><span class="comment">    @assumption: assume convex polygon, only return non-reflex angle</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getAngle</span><span class="params">(Point &amp;a, Point &amp;b, Point &amp;c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> AB = <span class="built_in">getLength</span>(a, b);</span><br><span class="line">        <span class="keyword">float</span> BC = <span class="built_in">getLength</span>(b, c);</span><br><span class="line">        <span class="keyword">float</span> AC = <span class="built_in">getLength</span>(a, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> cosA = (AB * AB + AC * AC - BC * BC) / (<span class="number">2</span> * AB * AC);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">toDegree</span>(<span class="built_in">acos</span>(cosA));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    compute similarity between two sets of points(2 polygons)</span></span><br><span class="line"><span class="comment">    the sets should have the same size.</span></span><br><span class="line"><span class="comment">    For details, see report.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">similarity</span><span class="params">(vector&lt;Point&gt; &amp;a, vector&lt;Point&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        don&#x27;t take similarity between lines into account</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between edges</span></span><br><span class="line">        <span class="keyword">float</span> simLenUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> simLenLower = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[i], b[i + <span class="number">1</span>]);</span><br><span class="line">            simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">            simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//the last edge between the first and the last point</span></span><br><span class="line">        <span class="keyword">float</span> edgeA = <span class="built_in">getLength</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> edgeB = <span class="built_in">getLength</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>]);</span><br><span class="line">        simLenLower += <span class="built_in">abs</span>(edgeA + edgeB);</span><br><span class="line">        simLenUpper += <span class="built_in">abs</span>(edgeA - edgeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edge coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simLenUpper / simLenLower);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//similarity between angles</span></span><br><span class="line">        <span class="keyword">float</span> simAngUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[i], a[i + <span class="number">1</span>], a[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[i], b[i + <span class="number">1</span>], b[i - <span class="number">1</span>]);</span><br><span class="line">            simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//last 2 angles</span></span><br><span class="line">        <span class="keyword">float</span> angA = <span class="built_in">getAngle</span>(a[<span class="number">0</span>], a[n - <span class="number">1</span>], a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">float</span> angB = <span class="built_in">getAngle</span>(b[<span class="number">0</span>], b[n - <span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line">        angA = <span class="built_in">getAngle</span>(a[n - <span class="number">1</span>], a[n - <span class="number">2</span>], a[<span class="number">0</span>]);</span><br><span class="line">        angB = <span class="built_in">getAngle</span>(b[n - <span class="number">1</span>], b[n - <span class="number">2</span>], b[<span class="number">0</span>]);</span><br><span class="line">        simAngUpper += <span class="built_in">abs</span>(angA - angB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//angle coefficient 0.5 by default</span></span><br><span class="line">        res += <span class="number">0.5</span> * (<span class="number">1</span> - simAngUpper / <span class="number">180.f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;geometry.hpp&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">USAGE ON MACROS:</span></span><br><span class="line"><span class="comment">_ROW_ORDER: VOTING TABLE ROW_ORDERED METHOD</span></span><br><span class="line"><span class="comment">_NON_VOTING: NON VOTING METHOD</span></span><br><span class="line"><span class="comment">_VOTE_ORDER: SIMPLE IDEA METHOD</span></span><br><span class="line"><span class="comment">_USER_INPUT: GET INPUT FROM USER</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AVAIABLE CASES:</span></span><br><span class="line"><span class="comment">    _SAMPLE_CASE1~4</span></span><br><span class="line"><span class="comment">    MIRROR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define _ROW_ORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAMPLE_CASE1</span></span><br><span class="line"><span class="comment">// #define _NON_VOTING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _VOTE_ORDER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TO USE: set C++ standard to C++11 or later</span></span><br><span class="line"><span class="comment">Read &quot;README.md&quot; first.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@params:levelOrder,votingTable,maxDepth</span></span><br><span class="line"><span class="comment">@return:isFullMatch</span></span><br><span class="line"><span class="comment">@description:1.compute how many votes each nodes has 2. visit each valid node, and vote</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">voting</span><span class="params">(vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;levelOrder, map&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;table, <span class="keyword">int</span> maxDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//this means no path can be length m, meaning no full match</span></span><br><span class="line">    <span class="keyword">if</span> (levelOrder.<span class="built_in">size</span>() &lt; maxDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No Full Match Under Such Similarity Setting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check the degree of each node, and only visit each node once</span></span><br><span class="line">    <span class="comment">// leaf as one count</span></span><br><span class="line">    <span class="comment">// node.count = node-&gt;left.count+node-&gt;right.count;</span></span><br><span class="line">    <span class="comment">// compute from bottom up</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//compute each node has how many votes,skip the dummy root</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = levelOrder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//leaf nodes has one vote</span></span><br><span class="line">            <span class="keyword">if</span> (levelOrder[i][j]-&gt;depth == maxDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                levelOrder[i][j]-&gt;count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//non-leaf nodes have vote equals to its all valid children</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : levelOrder[i][j]-&gt;children)</span><br><span class="line">                levelOrder[i][j]-&gt;count += kv.second-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after computing how many votes each node has, we need to calculate the final vote count</span></span><br><span class="line">    <span class="comment">//voting process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; levelOrder.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; levelOrder[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            table[levelOrder[i][j]-&gt;indices] += levelOrder[i][j]-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two vectors to store input</span></span><br><span class="line">    vector&lt;Point&gt; pointsA;</span><br><span class="line">    vector&lt;Point&gt; pointsB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size of pointsA and pointsB</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compute answer from user input</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USER_INPUT</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE1</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">4.25</span>, <span class="number">6</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small square and a 2x square</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE2</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a small triangle and a pentagon</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE3</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a large case to test speed performance (M=21,N=28)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SAMPLE_CASE4</span></span><br><span class="line">    <span class="comment">// Sample Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this actually got problems, but if we got a match, the overall polygon matching is actually correct,</span></span><br><span class="line"><span class="comment">//we only have to reorder the indices order</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIRROR</span></span><br><span class="line">    <span class="comment">// MIRROR Case</span></span><br><span class="line">    pointsA.<span class="built_in">clear</span>();</span><br><span class="line">    pointsB.<span class="built_in">clear</span>();</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsA.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">-3</span>, <span class="number">0</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    pointsB.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">8</span>, <span class="number">6</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureing pointsA always have smaller size</span></span><br><span class="line">    <span class="keyword">if</span> (pointsA.<span class="built_in">size</span>() &gt; pointsB.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">swap</span>(pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    using map for voting table, where key is the point pair indicies</span></span><br><span class="line"><span class="comment">    here we have to use map instead of unordered_map</span></span><br><span class="line"><span class="comment">    because type(pair&lt;int,int&gt;) in C++ STL is not hashable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; votingTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Initialize Tree with given points array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Tree <span class="title">tree</span><span class="params">(pointsA.size(), pointsB.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in non voting method, we didn&#x27;t prune the tree</span></span><br><span class="line"><span class="comment">we calculate the the cumulative Similarity of all the leaf nodes</span></span><br><span class="line"><span class="comment">finding out the one with cumulative largest similarity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree without pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTreeWithoutPruning</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line">    <span class="comment">//leaf nodes are at the last level</span></span><br><span class="line">    <span class="keyword">auto</span> leaves = nodes[nodes.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compare and find out the node with largest cumulative similarity</span></span><br><span class="line">    <span class="keyword">float</span> maxSum = <span class="number">0.f</span>;</span><br><span class="line">    TreeNode *maxNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> leaf : leaves)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaf-&gt;cumulativeSim &gt; maxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = leaf-&gt;cumulativeSim;</span><br><span class="line">            maxNode = leaf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after finding the max cumulativeSimilarity</span></span><br><span class="line">    <span class="comment">//trace back bottom up, push the path to result</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (maxNode-&gt;parent != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(maxNode-&gt;indices);</span><br><span class="line">        maxNode = maxNode-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print out the path</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + res[i].first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + res[i].second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="comment">//print time it takes</span></span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this contains build/prune/level order/vote 4 steps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NON_VOTING</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build tree with build time pruning</span></span><br><span class="line">    <span class="keyword">auto</span> root = tree.<span class="built_in">buildTree</span>(tree.root, pointsA, pointsB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// further pruning step</span></span><br><span class="line">    tree.<span class="built_in">invalidate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the valid nodes in the tree, for test</span></span><br><span class="line">    <span class="comment">// tree.printTree();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //get valid tree nodes by level order traversal</span></span><br><span class="line">    <span class="keyword">auto</span> nodes = tree.<span class="built_in">levelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check if there&#x27;s a full match, also doing the voting</span></span><br><span class="line">    <span class="keyword">bool</span> isFullMatch = <span class="built_in">voting</span>(nodes, votingTable, pointsA.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if no full match, return with -1</span></span><br><span class="line">    <span class="keyword">if</span> (!isFullMatch)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a method ensuring no collision match, with possibility of wrong-matching but no collision</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _ROW_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; row_order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// we use a 2D matrix to represent the table</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            <span class="built_in">res</span>(pointsA.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(pointsB.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert the std::map into 2D vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : votingTable)</span><br><span class="line">        &#123;</span><br><span class="line">            res[kv.first.first][kv.first.second] = kv.second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse each row, find out the max element</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &lt; res[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the element has the most votes in the row</span></span><br><span class="line">                <span class="keyword">if</span> (res[i][j] == *<span class="built_in">max_element</span>(res[i].<span class="built_in">begin</span>(), res[i].<span class="built_in">end</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (verbose)</span><br><span class="line">                        <span class="comment">//print out the indicies</span></span><br><span class="line">                        cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + j &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//disable the column, in case next row matches the same column</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop for k times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">row_order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//calculate the time performance</span></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this is the SIMPLE_IDEA in the report</span></span><br><span class="line"><span class="comment">//print m matches with top most votes, collision could happen with a low threshold</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _VOTE_ORDER</span></span><br><span class="line">    <span class="keyword">int</span> loop_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//verbose means if print the result or not</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">bool</span>)&gt; order = [&amp;](<span class="keyword">bool</span> verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getting matches with order of votes, using with restrict threshold of similarity</span></span><br><span class="line">        vector&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt;</span><br><span class="line">            pairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert map to vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itr = votingTable.<span class="built_in">begin</span>(); itr != votingTable.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">            pairs.<span class="built_in">push_back</span>(*itr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sort voting table by its vote count</span></span><br><span class="line">        <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), [](pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;a, pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the first m highest votes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointsA.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="number">1</span> + pairs[i].first.second &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop for loop_count times</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">order</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST UTILITY FUNCTIONS</span></span><br><span class="line">    <span class="comment">// auto pp = root-&gt;children[make_pair(0, 0)]-&gt;children[make_pair(1, 1)]-&gt;pointPair;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pp.first.print();</span></span><br><span class="line">    <span class="comment">// pp.second.print();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::similarity(pointsA, pointsB) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; Geo::getAngle(pointsA[0], pointsA[1], pointsA[2]) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOME TEST CODES TO TEST INPUT</span></span><br><span class="line">    <span class="comment">// for (const auto &amp;point : pointsA)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     point.print();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DataStructure</tag>
        <tag>Point Matching</tag>
      </tags>
  </entry>
  <entry>
    <title>最近半年的生活状态（上）</title>
    <url>/2022/06/19/%E4%B8%80%E4%BA%9B%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<h3 id="最近半年的生活状态（上）"><a href="#最近半年的生活状态（上）" class="headerlink" title="最近半年的生活状态（上）"></a>最近半年的生活状态（上）</h3><p>​    说起来，自从大四之后就很久很久没有为自己写一些东西，也许是太忙？但也有可能是“我没有把这当作是最重要的事情”，所以一直搁置了。不过临近毕业，总算是稍微有点机会写点什么了，就稍微写一点吧。我想先写一些关于大四上学期的内容，不然就太长了。</p>
<h3 id="大四上"><a href="#大四上" class="headerlink" title="大四上"></a>大四上</h3><p>​    整个大四上发生了很多事情，分手，上课，作品集，申请学校。一直非常焦头烂额，不过好在我在作品集的机构认识了一些朋友，后来11月的时候，还因为疫情的原因在校外酒店住了一个多月。我的整个大四上学期是在忙碌和焦虑中度过的，不过我猜大家都是这样。</p>
<ul>
<li>分手</li>
</ul>
<p>​    学期的一开始，前任就和我提了分手，不过我太想再回忆这些。分手的时候他撒了一个谎，后来找我复合，我拒绝了。既然已经过去这么久，就这样吧。</p>
<ul>
<li>数据结构基础</li>
</ul>
<p>​    大四上才上数据结构确实挺晚了，甚至申请的时候都不一定会出现在成绩单上，但就当是学知识吧—我是这么想的。学校的数据结构课一开始要分班考，基础还行的同学可以选择困难模式，也就是平时的3个实验课作业题目会变难，好处是评分最多可以比其他同学高5分。我选择了困难模式，当然也为此花了一些时间，现在想想，却也不是那么有必要，尽管确实从一些题目中获得了更深的思考。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0gq6kzmj21yq0tsgrj.jpg" alt="image-20220620001929249" style="zoom:33%;" />

<blockquote>
<p>当时为了练手，日常还会做一些LeetCode补充一下，传到GitHub记录一下？</p>
</blockquote>
<p>​    这门课臭名昭著的地方在于实验课作业的互评制度，也就是大家要互相给代码和实验报告打分。大部分选课的同学应该都是刚上大二，仅校内课程来说，是没有接触过较为现代的Editor或者LaTex/Markdown之类的工具的，于是相当多的同学（至少在我互评的范围内）用Dev C++（大一的时候学校推荐大家使用）写代码，用Word写文档。我觉得他们之中的很多人应该是在这些方面吃了亏，而我可能也只是因为在这些方面（指使用VSCode / Typora）有点接触，在互评上稍微多了点美观分—这其实还挺不公平的…</p>
<p>​    印象比较深的有几件事，一件是期中考试好像只考了69分，还没有到班级平均线。一件是第二个实验课题目比较困难，当时写了有800行代码，较为头疼。不过比较开心的是，那次我实现了一个类似Trie的结构，还是用了比较基础的multithreading和rvalue reference，尽管最后效率非常低…</p>
<p>​    至于这门课的结果还不错，期末考试的800个人里面考了130几名，算是给期中考试挽回了一点颜面吧。</p>
<ul>
<li>作品集</li>
</ul>
<p>​    老实说提起作品集挺汗颜的，只要一想起它我就会非常紧张，但它又是我申请设计/游戏类学校必不可少的一环。暑假因为忙着谈恋爱，浪费（？）了许多时间。我是一个挺恋爱脑的人，所以一旦进入一段关系，效率就会很低下。导致开学的时候，还没有完成多少作品集的内容。从这个意义上来说，幸好分手了，不然以我之前的效率，作品集应该是做不完了吧。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0ekdizkj21750u00wp.jpg" alt="image-20220620001722163" style="zoom:33%;" />

<blockquote>
<p>一张产品渲染图，Blender水平提高了许多</p>
</blockquote>
<p>​    我在作品集机构完成了自己的第一个游戏的Demo，也因此认识了几个好朋友，后来做产品渲染的时候提高了自己的Blender技巧，这些都是我实实在在的收获。果然还是和游戏相关的事情最容易让人获得快乐啊！</p>
<ul>
<li>申请学校</li>
</ul>
<p>​    我这个人申请学校的策略完全就是个超级大海王，或许是怕没有书读，我一共申请了23个项目，光是送分加上申请费用就花了差不多2万块。一开始还会反复检查信息是否有误，到后来麻木了，就不太检查了。而选校的事情本身也不甚严谨，当时甚至是昨天刚听说一个项目，今天就决定申请这个项目。实际上我最终决定去的项目，也是我申请结束前10天听说的。不过，反正多申请一个学校也不会缺斤少两，多申请总不会后悔！</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0kqwfmcj214y0ti41g.jpg" alt="image-20220620002158278" style="zoom:33%;" />

<blockquote>
<p>最后打算去这里了，加州见！</p>
</blockquote>
<ul>
<li>关于日常生活</li>
</ul>
<p>​    上个学期最喜欢的事情是因为临时封校，在外面的酒店住了一个多月。一个多月里我能够每天吃麦当劳，每天喝喜茶。每天都只需要步行去机构，坐在人体工学椅上。晚上洗澡，躺在酒店超级软的床上面。真幸福啊…</p>
<p>​    考GRE那天是万圣节，我当时上午没吃饭就去考试，结果一直到14:30才吃上饭。考完试后去机构继续做作品集，而后回到学校换上我的万圣节costume，扮成迈尔斯来吓人！</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3e0kp8ijpj20sm12s43z.jpg" alt="image-20220620002245778" style="zoom:33%;" />

<blockquote>
<p>Happy Halloween~</p>
</blockquote>
<p>​    12月的时候我去吃了一个人均500的日料自助。值得一提的是，套餐里有一只大虾，但是是生的。我不喜欢吃刺身，却又不敢说“能不能帮我烤一下”（这太不符合高级日料店的风格了！），于是就只能硬着头皮吃下去。一句题外话，日料的omakase（大概就是自助吧）似乎都挺贵的，好像人均会是4位数，那么看来我吃的这一家店还算比较实惠（？），也不能这么想啦！</p>
<p>​    最后一件事是关于生日，大学四年我过生日都还算比较有仪式感。唯独21岁这次生日，因为忙着做作品集，从早忙到了晚，就没有考虑过生日怎么过。后来，和舍友（他也要做作品集）一起在机构附近简单吃了个饭，就当是过了生日，希望明年一定要补上。还有一点是，虚幻4在我生日这天崩溃了4次，确实挺让我崩溃的。</p>
<p>​    我想这就是我对大四上生活的一些简单回顾吧。哦对了，还有一件事，在学期末找了一些同学组队参加了GameJam，还是挺开心的！大四上在一片忙碌中就这样结束了。</p>
]]></content>
      <categories>
        <category>Life, Journal</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>

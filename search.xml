<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>121.Buy And Sell Stock</title>
    <url>/2021/09/22/121.BuyAndSellStock/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>



<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Traverse all price pairs, ans = max(ans,pair[j]-pair[i]), where j &gt; i.</p>
<p>Steps:$n^2/2$ -&gt; TLE</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Define"><a href="#Define" class="headerlink" title="Define:"></a>Define:</h4><p>Max_profit = max{price[j]-price[i]}</p>
<p>0&lt;= i &lt; j &lt; n-1</p>
<h4 id="Finding"><a href="#Finding" class="headerlink" title="Finding:"></a>Finding:</h4><blockquote>
<p>Buy: price[i] = min{prices[:i]}</p>
<p>Sell: price[j] = max{prices[j:]}</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><h4 id="1-Keep-track-of-the-minimun-price-so-far"><a href="#1-Keep-track-of-the-minimun-price-so-far" class="headerlink" title="1.Keep track of the minimun price so far:"></a>1.Keep track of the minimun price so far:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traverse the price:</span><br><span class="line"></span><br><span class="line">​	L = the Lowest price up to day i</span><br><span class="line">	P = the max profit up to day i</span><br><span class="line">	</span><br><span class="line">	L.update</span><br><span class="line">	P.update</span><br><span class="line"></span><br><span class="line">//Buy at the lowest price, sell at day i.</span><br></pre></td></tr></table></figure>



<h4 id="2-Convert-the-priceList-to-the-gainList"><a href="#2-Convert-the-priceList-to-the-gainList" class="headerlink" title="2.Convert the priceList to the gainList"></a>2.Convert the priceList to the gainList</h4><blockquote>
<p>Example:</p>
<p>prices = [7,1,5,3,6,4]</p>
<p>Gains = [0,-6,4,-2,3,-2]</p>
</blockquote>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note:"></a>Note:</h3><p>The profit is the sum of a subarray in gains.</p>
<p>And the max_profit = the largest sum of subarray of an array(LeetCode 53).</p>
<h4 id="Using-Kadane’s-Algorithm"><a href="#Using-Kadane’s-Algorithm" class="headerlink" title="Using Kadane’s Algorithm"></a>Using Kadane’s Algorithm</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># Kadane&#x27;s Algorithm</span></span><br><span class="line">        maxCurrent = maxGlobal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># the maxCurrent is sum(maxCurrent+num)(the max subarray before this elem) or num</span></span><br><span class="line">            maxCurrent = <span class="built_in">max</span>(nums[i], maxCurrent + nums[i])</span><br><span class="line">            <span class="comment"># update maxGlobal = max(maxCurrent)</span></span><br><span class="line">            maxGlobal = <span class="built_in">max</span>(maxCurrent, maxGlobal)</span><br><span class="line">        <span class="keyword">return</span> maxGlobal</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>1239.Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2021/09/22/1239.Maximum%20Length%20of%20a%20Concatenated%20String%20with%20Unique%20Characters/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of strings <code>arr</code>. String <code>s</code> is a concatenation of a <mark>sub-sequence</mark> of <code>arr</code> which have <strong>unique characters</strong>.</p>
<p>Return <em>the maximum possible length</em> of <code>s</code>.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span><br><span class="line">Maximum length is 4.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">Output: 26</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 16</code></li>
<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>
<li><code>arr[i]</code> contains only lower case English letters.</li>
</ul>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><ul>
<li><p>A subsequence should preserve the order.</p>
<ul>
<li>For example, arr = [“un”,”iq”,”ue”], “iqun” is not a valid answer.</li>
<li>Corollary:<ul>
<li>However, we only want the length of the string, so the <strong>order</strong> of the strings are trivial.</li>
</ul>
</li>
</ul>
</li>
<li><p>The constraints has implied us that the algorithm could be exponential.</p>
</li>
<li><p>if arr[i] itself contains duplicate characters, it’s invalid.</p>
</li>
</ul>
<h3 id="BruteForce"><a href="#BruteForce" class="headerlink" title="BruteForce:"></a>BruteForce:</h3><p>Traverse all the string pair, find if the concantenated string has duplicate char.</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
</blockquote>
<h3 id="Technique"><a href="#Technique" class="headerlink" title="Technique:"></a>Technique:</h3><p>Since the arr[i].length&lt;=26&lt;32, we can use a 32bit int to do the char count</p>
<p>(How many times each character present in a string instead of map)</p>
<blockquote>
<p>Time Complexity $O(2^n)$ : each string can be cancatenated or not.</p>
<p>Space Complexity $O(n)$ : using DFS recursion, the space complexity equals to the depth of recursion.</p>
</blockquote>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h4><p><img src="https://i.loli.net/2021/09/22/xbP8JXEZH7VWzdl.png" alt="image-20210922201019533"></p>
<blockquote>
<p>Referenced from Hua Hua@Youtube</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span></span><br><span class="line"><span class="comment">Output: 4</span></span><br><span class="line"><span class="comment">Explanation: All possible concatenations are &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; and &quot;ique&quot;.</span></span><br><span class="line"><span class="comment">Maximum length is 4.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//valid string</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string &amp;x : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//bit representations</span></span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//bit representation</span></span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if the char used != the length of string, it contains duplicates.</span></span><br><span class="line">            <span class="comment">//ignore the string</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(mask) != x.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            a.<span class="built_in">push_back</span>(mask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//s is the index of string, mask is the present state</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> s, <span class="keyword">int</span> mask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//update the result</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, __builtin_popcount(mask));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if the result is valid</span></span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(mask &amp; a[i]) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//go to combine with next element</span></span><br><span class="line">                    <span class="built_in">dfs</span>(i + <span class="number">1</span>, mask | a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>98.Validate Binary Search Tree</title>
    <url>/2021/09/30/98.ValidateBST/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: root = [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#x27;s value is 5 but its right child&#x27;s value is 4.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><h4 id="Property-of-a-Binary-Search-Tree"><a href="#Property-of-a-Binary-Search-Tree" class="headerlink" title="Property of a Binary Search Tree:"></a>Property of a Binary Search Tree:</h4><p><img src="https://i.loli.net/2021/09/30/B4ygC6psULPtG5Z.png" alt="image-20210930171547076"></p>
<blockquote>
<p>Ref from Huahua@Youtube</p>
</blockquote>
<p>For each TreeNode</p>
<ul>
<li>cur-&gt;left-&gt;val &lt; cur-&gt;val</li>
<li>cur-&gt;right-&gt;val &gt; cur-&gt;val</li>
</ul>
<h4 id="Consider-the-range"><a href="#Consider-the-range" class="headerlink" title="Consider the range:"></a>Consider the range:</h4><p>The input value ranges from -2^31 &lt;= Node.val &lt;= 2^31 - 1, so the positive/negative infinity should be set to LLONG_MIN, LLONG_MAX. (64-bit)</p>
<h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if nulltree:</span><br><span class="line">	return true;</span><br><span class="line"></span><br><span class="line">//if the node val is beyond the range, it&#x27;s invalid.</span><br><span class="line">if node-&gt;val&lt;=min_val||node-&gt;val&gt;=max_val:</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">//check subtree of both sides</span><br><span class="line">return validate(cur-&gt;left,min,cur-&gt;val)&amp;&amp;validate(cur-&gt;right,cur-&gt;val,max)</span><br></pre></td></tr></table></figure>



<h3 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root, <span class="keyword">long</span> mn, <span class="keyword">long</span> mx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= mn || root-&gt;val &gt;= mx)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, mn, root-&gt;val) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root-&gt;val, mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="For-Your-Consider"><a href="#For-Your-Consider" class="headerlink" title="For Your Consider:"></a>For Your Consider:</h4><p>What if the range extends to -2^64 ~2^64-1?</p>
<p><strong>Hint</strong>: Use nullptr to represent infinity.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Why Tuple?</title>
    <url>/2021/09/21/WhyTuple?/</url>
    <content><![CDATA[<p>C++ 11 introduces a template Tuple, similar to the one in Python, allows you to store data of different types in a single entity. But you may ask, in C/C++,we already have some mechaism called struct allows us to do the same thing, then why do we need tuple?</p>
<h3 id="Case-1-One-Time-Structure-to-Transfer-Data"><a href="#Case-1-One-Time-Structure-to-Transfer-Data" class="headerlink" title="Case 1: One-Time Structure to Transfer Data"></a>Case 1: One-Time Structure to Transfer Data</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;string,<span class="keyword">int</span>&gt; <span class="title">getNameAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_tuple</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">34</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span>string name;<span class="keyword">int</span> age;&#125;p;</span><br><span class="line">    tuple&lt;string,<span class="keyword">int</span>&gt; t;</span><br><span class="line">    </span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">tie</span>(name,age) = <span class="built_in">getNameAge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we want to transfer a group of data for only one time, we may not want to define a struct, and using tuple get us away from these definitions.</p>
<h3 id="Case-2-Fast-Comparison-Using-Tuple-Operators"><a href="#Case-2-Fast-Comparison-Using-Tuple-Operators" class="headerlink" title="Case 2: Fast Comparison Using Tuple Operators"></a>Case 2: Fast Comparison Using Tuple Operators</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; time1,time2;</span><br><span class="line"><span class="keyword">if</span>(time1&gt;time2)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time1 is later&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Case-3-Multi-Index-Map-Unordered-Map"><a href="#Case-3-Multi-Index-Map-Unordered-Map" class="headerlink" title="Case 3: Multi-Index Map/Unordered Map"></a>Case 3: Multi-Index Map/Unordered Map</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define</span></span><br><span class="line">map&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">char</span>,<span class="keyword">float</span>&gt;,string&gt; m;</span><br><span class="line"><span class="comment">//indexing</span></span><br><span class="line">m[<span class="built_in">make_tuple</span>(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1.0</span>)] = <span class="string">&quot;Test&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Case-4-Fast-Swap"><a href="#Case-4-Fast-Swap" class="headerlink" title="Case 4: Fast Swap"></a>Case 4: Fast Swap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">tie</span>(b,c,a) = <span class="built_in">make_tuple</span>(a,b,c);</span><br></pre></td></tr></table></figure>



<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><p>Tuple is not recommended to be overused. If needed, use struct instead.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Data_Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>ノエルのテーマ 〜最後の旅〜</title>
    <url>/2021/09/27/%E3%83%8E%E3%82%A8%E3%83%AB%E3%81%AE%E3%83%86%E3%83%BC%E3%83%9E%E3%80%80%E3%80%9C%E6%9C%80%E5%BE%8C%E3%81%AE%E6%97%85%E3%80%9C/</url>
    <content><![CDATA[<h4 id="Original-Lyrics"><a href="#Original-Lyrics" class="headerlink" title="Original Lyrics:"></a>Original Lyrics:</h4><p>Long ago, when I was just a boy<br>So alone that last of my kind in the world<br>I believe futures could be reborn<br>I would go back in time<br>Change what’s to come</p>
<p>Hunting, searching for futures I’ve dreamed<br>Ever chasing, believing visions unseen<br>Hearing that hope is futile<br>Only inspires me not to give up</p>
<p>Valhalla is calling me to the end<br>I can hear now the beating hearts of lost friends<br>Urging me to not forget them<br>As the last hunter<br>I’ll find the key</p>
<h4 id="Translated-zh-cn"><a href="#Translated-zh-cn" class="headerlink" title="Translated(zh-cn):"></a>Translated(zh-cn):</h4><p>很久之前，当我还是孩童之时</p>
<p>作为族类的最后一人，孑然一身</p>
<p>如果未来可以改变</p>
<p>我将追溯过去，改变将来</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Lyrics</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-概览笔记</title>
    <url>/2021/09/06/Notes-Computer%20Networks/</url>
    <content><![CDATA[<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client/Server:"></a>Client/Server:</h3><p>应用层，最为抽象</p>
<h3 id="TCP-传输层"><a href="#TCP-传输层" class="headerlink" title="TCP:传输层"></a>TCP:传输层</h3><p>对可靠性要求高、检验错误</p>
<h3 id="UDP："><a href="#UDP：" class="headerlink" title="UDP："></a>UDP：</h3><p>对可靠性要求低、但是能够保证实时</p>
<ul>
<li>直播</li>
<li>事务性应用</li>
</ul>
<h3 id="IP-网络层-End-to-End"><a href="#IP-网络层-End-to-End" class="headerlink" title="IP:网络层 End to End"></a>IP:网络层 End to End</h3><p>从主机到主机</p>
<p>在Link Layer的点到点通讯基础上实现</p>
<h3 id="Link-Layer-点到点通讯"><a href="#Link-Layer-点到点通讯" class="headerlink" title="Link Layer:点到点通讯"></a>Link Layer:点到点通讯</h3><h3 id="Physical-Layer-物理信号-数字信号"><a href="#Physical-Layer-物理信号-数字信号" class="headerlink" title="Physical Layer:物理信号-数字信号"></a>Physical Layer:物理信号-数字信号</h3><p>通过media（介质）：</p>
<ul>
<li>Copper</li>
<li>Fibre</li>
</ul>
<h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><h4 id="传统工作方式：查表-转发"><a href="#传统工作方式：查表-转发" class="headerlink" title="传统工作方式：查表+转发"></a>传统工作方式：查表+转发</h4><ul>
<li>路由器交换信息</li>
<li>计算出路由表</li>
<li>IP协议收到分组后，根据IP查路由表，再根据表转发</li>
</ul>
<h4 id="SDN方式：数据平面-控制系统"><a href="#SDN方式：数据平面-控制系统" class="headerlink" title="SDN方式：数据平面+控制系统"></a>SDN方式：数据平面+控制系统</h4><p>交换机：多字段匹配-&gt;block/转发/flood</p>
<p>操作系统：计算flow table-下发给交换机</p>
<p>（programmable+new features could be added）</p>
<p>比如说要新增加负载均衡，只需要编程即可</p>
<h4 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h4><h3 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h3><p>在下层提供的服务上实现更高级的功能</p>
<h3 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node:"></a>Node:</h4><ul>
<li><p>主机以及主机上的应用程序</p>
</li>
<li><p>路由器、交换机等网络交换设备</p>
</li>
<li><p>方的节点：主要节点（Client/Server）</p>
<p>圆形节点：中转节点</p>
</li>
</ul>
<h4 id="Edge-通信链路"><a href="#Edge-通信链路" class="headerlink" title="Edge:通信链路"></a>Edge:通信链路</h4><ul>
<li>access：主机接入到（最近的交换机）互联网的链路（一方一圆）</li>
<li>backbone：路由器之间的链路（两个圆的）</li>
</ul>
<h4 id="Protocol-对等层实体交换数据所需要遵循的规范"><a href="#Protocol-对等层实体交换数据所需要遵循的规范" class="headerlink" title="Protocol:对等层实体交换数据所需要遵循的规范"></a>Protocol:对等层实体交换数据所需要遵循的规范</h4><p>Protocol Data Unit(PDU)</p>
<h3 id="互联网包括：网络边缘-网络核心-接入网"><a href="#互联网包括：网络边缘-网络核心-接入网" class="headerlink" title="互联网包括：网络边缘/网络核心/接入网"></a>互联网包括：网络边缘/网络核心/接入网</h3><h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><p>网络边缘:</p>
<ul>
<li>主机</li>
<li>应用程序</li>
</ul>
<h3 id="1-3-Core（用于数据交换）"><a href="#1-3-Core（用于数据交换）" class="headerlink" title="1.3 Core（用于数据交换）"></a>1.3 Core（用于数据交换）</h3><ul>
<li>相互连接的路由器</li>
<li>网络的网络</li>
</ul>
<h3 id="1-4-Access"><a href="#1-4-Access" class="headerlink" title="1.4 Access"></a>1.4 Access</h3><ul>
<li>有线或者无线通信链路</li>
</ul>
<p>边缘接入核心-&gt;核心连接所有边缘节点-&gt;边缘可以和任意边缘节点交换</p>
<p>网络核心：相当于全球范围内的切换开关（如果需要交换，就打开）</p>
<h4 id="应用进程交互模式："><a href="#应用进程交互模式：" class="headerlink" title="应用进程交互模式："></a>应用进程交互模式：</h4><ul>
<li><p>Client/Server模式：</p>
<ul>
<li>Client后运行起来，向Server发出请求，资源来自于Server</li>
<li>问题：如果Client特别多，需要准备很多Server，到达一定程度时性能断崖式下跌</li>
</ul>
</li>
<li><p>Peer-Peer 模式：</p>
<ul>
<li>没有专门的服务器</li>
<li>每个节点既是Client也是Server</li>
<li>分布式通信，下载文件的时候，相当于多路下载片段</li>
</ul>
</li>
</ul>
<h4 id="基础设施为网络应用提供的服务："><a href="#基础设施为网络应用提供的服务：" class="headerlink" title="基础设施为网络应用提供的服务："></a>基础设施为网络应用提供的服务：</h4><ul>
<li>TCP（面向连接（端系统知道/路径节点不知道）的通信方式）：Shake Hand方式（数据传输前做好准备）<ul>
<li>可靠：不重复、不丢、不乱序</li>
<li>Flow Control:发送方不会淹没接收方</li>
<li>阻塞控制(Congestion Control)</li>
<li>要考虑网络+设备</li>
</ul>
</li>
<li>UDP(connectless，直接发送，不需要提前连接)<ul>
<li>不可靠</li>
<li>没有流量控制</li>
<li>没有阻塞控制</li>
<li>适合实时多媒体应用</li>
<li>事务性很强的应用（）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>thread and process</title>
    <url>/2021/10/08/thread%20and%20process/</url>
    <content><![CDATA[<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>smallest sequence of programmed instructions that can be managed independently by a scheduler.</li>
<li>Has its own registers, PC. SP.</li>
</ul>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><ul>
<li>Instance of a computer program that is being executed</li>
<li>A process can have one or more threads</li>
</ul>
<h3 id="Parallel-Computing"><a href="#Parallel-Computing" class="headerlink" title="Parallel Computing"></a>Parallel Computing</h3><ul>
<li>Run programs on one or more CPUs</li>
<li>Multi-threading (shared memory)</li>
<li>Multi-processing (Independent-memory)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; a += <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(run)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(run)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread1.<span class="built_in">join</span>(); <span class="comment">//only return after the thread1 finish</span></span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only main thread will execute</span></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading:"></a>Multithreading:</h3><p><img src="https://i.loli.net/2021/10/08/43roIiyfq6DAgS7.png" alt="image-20211008194305920"></p>
<p>Shared memory, so variable can be accessed by both threads.</p>
<p>However, <strong>when multithreads write (non-atomic instruction) a shared variable, inconsistency could happen.</strong></p>
<h3 id="Problem-Access-shared-resources"><a href="#Problem-Access-shared-resources" class="headerlink" title="Problem:Access shared resources:"></a>Problem:Access shared resources:</h3><p>CPU may process instructions randomly.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a += <span class="number">1</span>;<span class="comment">//non-atomic</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r</span><br><span class="line">INC r</span><br><span class="line">STORE r,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">INC r2,</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD a,r1</span><br><span class="line">INC r1</span><br><span class="line">STORE r1,a</span><br><span class="line">// this is sequential</span><br><span class="line">LOAD a,r2</span><br><span class="line">INC r2</span><br><span class="line">STORE r2,a</span><br></pre></td></tr></table></figure>



<h4 id="To-fix"><a href="#To-fix" class="headerlink" title="To fix:"></a>To fix:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//thread blocking</span></span><br><span class="line">	l.<span class="built_in">lock</span>();</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    l.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: only use lock when going to the critical section, becuase multithreading is much faster.</p>
<h4 id="Communicate"><a href="#Communicate" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared variable</li>
<li>semaphore, mutex, lock</li>
</ul>
<h3 id="Multiprocessing"><a href="#Multiprocessing" class="headerlink" title="Multiprocessing:"></a>Multiprocessing:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">bool</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=child?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();<span class="comment">//create a parallel universe</span></span><br><span class="line">    <span class="comment">// all processes will execute this</span></span><br><span class="line">    <span class="built_in">run</span>(pid==<span class="number">0</span>);</span><br><span class="line">    cour&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/08/lxveEnH8zRh6TqB.png" alt="image-20211008195339005"></p>
<p>The pid returned by the fork() will not be 0 (0 as child process)</p>
<p>pid is the child process, should be 2+2;</p>
<p>pid is the parent process, should be 2+1;</p>
<h4 id="Communicate-1"><a href="#Communicate-1" class="headerlink" title="Communicate:"></a>Communicate:</h4><ul>
<li>shared memory</li>
<li>pipe</li>
<li>socket</li>
<li>RPC</li>
</ul>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd-shortest Path</title>
    <url>/2021/10/21/Second%20Shortest%20Path%20in%20Graph/</url>
    <content><![CDATA[<h4 id="Date-11-19-2021"><a href="#Date-11-19-2021" class="headerlink" title="Date:11.19.2021"></a>Date:11.19.2021</h4><blockquote>
<h3 id="Update-Log-11-25-2021"><a href="#Update-Log-11-25-2021" class="headerlink" title="Update Log 11.25.2021:"></a>Update Log 11.25.2021:</h3><h4 id="Comptability："><a href="#Comptability：" class="headerlink" title="Comptability："></a>Comptability：</h4><p>Known issue has been included in README.md</p>
<p>Recommend to compile with clang++，or Visual Studio 2019 CE.<br>Lab Files has been compiled and reviewed under MacOS 12.0.1，and Windows 10 + CMake 3.19 + Visual Studio Community 2019.</p>
<p>Set CMake minimum requirement to 3.14</p>
<h4 id="Performance-Improvement："><a href="#Performance-Improvement：" class="headerlink" title="Performance Improvement："></a>Performance Improvement：</h4><p>Using C++ 11 rvalue reference/move semantics to mitigate the copy construction overhead, 5% speed improvement under large case<br>Using C++11 std::future, std::async for async function calls, with 5% improvement in speed.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __THREADING__ </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h2><p>Given M vertices, indexed from 1 to M, and N edges to represent a <strong>Directional Graph.</strong> </p>
<p>(In my implementation, both directional and undirectional graph works fine.)</p>
<p>To simplify the problem, the starting point is vertex 1 and the destination is vertex M.</p>
<h4 id="Task-Find-Out-the-Second-Shortest-Path"><a href="#Task-Find-Out-the-Second-Shortest-Path" class="headerlink" title="Task: Find Out the Second Shortest Path"></a>Task: Find Out the Second Shortest Path</h4><ul>
<li><strong>Allow Backtracking:</strong> means each vertex can be presented in the path more than once.<ul>
<li>e.g. Path: 1-&gt;2-&gt;1-&gt;3 is valid</li>
</ul>
</li>
<li><strong>Multiple Shortest Path:</strong> if multiple shortest path exists, the second shortest path is the one whose length is longer than those but no longer than any other path.<ul>
<li>e.g. The length of all possible paths are <strong>100,100,105,110.</strong> The second shortest path length is 105.</li>
<li>If two or more second shortest paths exist, any second shortest path would be accepted.</li>
</ul>
</li>
</ul>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>In the first line specifies the <strong>number of vertices M and number of edges N of a digraph</strong>.</p>
<p>Then the rest N lines, each line is consisted of a edge, given by:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sourceVertex destVertex pathLength</span><br></pre></td></tr></table></figure>

<ul>
<li>Vertex is numbered from 1 to M</li>
<li>Only positive path length are considered</li>
</ul>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul>
<li>$1\le M\le1000$</li>
<li>$1\le N\le5000$</li>
<li>$1\le pathLength\le1000$</li>
</ul>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h3><ul>
<li>If(InputSize = 1000~10^6), a tolerable upper bound of an algorithm would be $O(nlog(n))$ </li>
<li>If(InputSize = 10^7), a tolerable upper bound of an algorithm would be $O(n)$</li>
<li>For this problem, if the <strong>input size is roughly $10^6&lt;$M*N</strong> $&lt;10^7$, the algorithm should be at least bounded by </li>
<li> $O(M<em>N log(M</em>N))$ .</li>
</ul>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Output the second shortest path in the form below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cost: cost</span><br><span class="line">Path: 1 ... m (exactly one space between each vertex, but no extra space at last)</span><br></pre></td></tr></table></figure>

<p>If there’s no second shortest path exist:</p>
<ul>
<li>Print a prompt to indicate there’s no second shortest path</li>
<li>Print the shortest path in the form below:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;But, the shortest path is&quot;</span><br><span class="line">Cost: cost</span><br><span class="line">Path: 1 ... m (exactly one space between each vertex, but no extra space at last)</span><br></pre></td></tr></table></figure>

<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample:"></a>Sample:</h3><ul>
<li>Input</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">50</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">150</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">130</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">70</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">40</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">240</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<h3 id="Related-Problems-and-Algorithms"><a href="#Related-Problems-and-Algorithms" class="headerlink" title="Related Problems and Algorithms:"></a>Related Problems and Algorithms:</h3><p>In general, this is an specialization of <strong>single source K Shortest Path Problem</strong> , where K=2.</p>
<p>Many different methods have been proposed to solve this problem, and there are two main variants of this problem:</p>
<blockquote>
<p>For DiGraph with M edges and N vertices:</p>
</blockquote>
<ul>
<li><strong>Loopy Variant, which means backtrack is allowed.</strong><ul>
<li>A solution was proposed by <strong>B. L. Fox in 1975</strong><ul>
<li>$O(m + kn*log (n))$ </li>
<li>Fox, B. L. (1975). “<em>K</em>th shortest paths and applications to the probabilistic networks”. <em><a href="https://en.wikipedia.org/wiki/Institute_for_Operations_Research_and_the_Management_Sciences">ORSA/TIMS Joint National Meeting</a></em>. <strong>23</strong>: B263. <a href="https://en.wikipedia.org/wiki/CiNii">CiNii National Article ID</a>: 10012857200.</li>
</ul>
</li>
<li>A faster approach was proposed by <a href="https://en.wikipedia.org/wiki/David_Eppstein">David Eppstein</a><ul>
<li>$O(m + n*log (n)+k)$ </li>
<li> <a href="https://en.wikipedia.org/wiki/David_Eppstein">Eppstein, David</a> (1998). <a href="https://www.ics.uci.edu/~eppstein/pubs/Epp-SJC-98.pdf">“Finding the <em>k</em> Shortest Paths”</a> (PDF). <em><a href="https://en.wikipedia.org/wiki/SIAM_J._Comput.">SIAM J. Comput.</a></em> <strong>28</strong> (2): 652–673. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1137%2FS0097539795290477">10.1137/S0097539795290477</a></li>
<li>In this paper, he proposed that  if the shortest path tree (in the form of heap) is given, we can find the k-th shortest path in $O(m+n+k)$.</li>
</ul>
</li>
</ul>
</li>
<li>Loopless Variant, which means backtrack is not allowed.<ul>
<li>A well-known solution is called Yen’s algorithm<ul>
<li>$O(kn(m +n log (n)))$ </li>
<li> Yen, J. Y. (1971). “Finding the <em>k</em>-Shortest Loopless Paths in a Network”. <em><a href="https://en.wikipedia.org/wiki/Management_Science_(journal)">Management Science</a></em>. <strong>1 7</strong> (11): 712–716. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1287%2Fmnsc.17.11.712">10.1287/mnsc.17.11.712</a>..</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This problem, is the Loopy variant, which means an optimal time complexity can be achieved at  $O(n*log (n))$, which has a desirable run time with given constraints.</p>
<h3 id="Build-Environment-amp-To-Run"><a href="#Build-Environment-amp-To-Run" class="headerlink" title="Build Environment &amp; To Run:"></a>Build Environment &amp; To Run:</h3><h3 id="Building-Environment"><a href="#Building-Environment" class="headerlink" title="Building Environment:"></a>Building Environment:</h3><ul>
<li>MacOS 12.0.1</li>
<li>VSCode</li>
<li>Compiler: Clang ++ 13.0</li>
<li>C++ Standard = C++ 11</li>
<li>ARM64 Platform (Apple Silicon)</li>
</ul>
<h2 id="Approach-1-Recommended"><a href="#Approach-1-Recommended" class="headerlink" title="Approach 1(Recommended)"></a>Approach 1(Recommended)</h2><p>Using cmake for crossplatform compile</p>
<h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h3><p>Download and install cmake</p>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h3><p>The Cmake instructions (CMakeLists.txt) has been provided. You can modify it yourself.</p>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h3><p>Open terminal/Powershell</p>
<p>Type in command as below</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./main #under macOS or Unix-like OS</span><br></pre></td></tr></table></figure>

<p>Now you’re running the program.</p>
<p>The program will output result carries out by each algorithm and their total runtime, in order of decreasing time complexity.</p>
<h2 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach 2"></a>Approach 2</h2><p>Using VSCode C/C++ Extensions</p>
<h3 id="1-Modify-tasks-json-file"><a href="#1-Modify-tasks-json-file" class="headerlink" title="1.Modify tasks.json file:"></a>1.Modify tasks.json file:</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<h3 id="2-Click-the-button-on-Run-and-Debug-panel"><a href="#2-Click-the-button-on-Run-and-Debug-panel" class="headerlink" title="2.Click the button on Run and Debug panel"></a>2.Click the button on Run and Debug panel</h3><h2 id="Other-IDE"><a href="#Other-IDE" class="headerlink" title="Other IDE:"></a>Other IDE:</h2><p>Import the source files, and set the C++ standard to C++11, better compile with Visual Studio 2019, or using Clang++.</p>
<h2 id="Known-Issue"><a href="#Known-Issue" class="headerlink" title="Known Issue:"></a>Known Issue:</h2><ul>
<li>GCC doesn’t support some C++ 11 features as of on Clang++, so if possible using clang++ instead.</li>
<li>When using Visual Studio 2019 for compiling, a largest case of 5000 edges would throw error of std::vector memory limit. However, this won’t happen when compile with clang++.</li>
</ul>
<h3 id="INPUT-MODE"><a href="#INPUT-MODE" class="headerlink" title="INPUT MODE:"></a>INPUT MODE:</h3><p>By default we set to <strong>__FILE_<em>INPUT</em>_</strong> And <strong>Looptime to 1.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FILE__INPUT__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">change your loopTime here</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> loop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>USAGE ON MACROS:</p>
<ul>
<li>_SAMPLE_CASE_: The sample given by OJ.</li>
<li><em>FILE_INPUT</em>_: Get input from files.<ul>
<li>1 file case is provided to test the largest possible input.</li>
<li>of size M=1000, N=5000</li>
</ul>
</li>
<li>_USER_INPUT_: Get input from command line</li>
<li>Available Cases:<ul>
<li> _SAMPLE_CASE_1~6</li>
</ul>
</li>
<li>Available Graph Type:<ul>
<li>class DiGraph for directional graph</li>
<li>class UGraph for undirectional graph</li>
</ul>
</li>
</ul>
<h2 id="Chapter-2-Algorithm-Specification-Description"><a href="#Chapter-2-Algorithm-Specification-Description" class="headerlink" title="Chapter 2:    Algorithm Specification Description"></a>Chapter 2:    Algorithm Specification Description</h2><h3 id="Graph-Representation"><a href="#Graph-Representation" class="headerlink" title="Graph Representation:"></a>Graph Representation:</h3><p>We use the multiList representation of graph, meaning the multiList[i] indicates all the edges which starts from vertex i.</p>
<ul>
<li><p>Vertices on user interface level are numbered from 1 to n</p>
</li>
<li><p>Vertices in the multiList are numbered from 0 to n-1</p>
</li>
<li><p>Since variable sized array is available in C++, we don’t need linked list for the multiList implementation, using <strong>vector&lt;vector&lt;std::pair&lt;int,int&gt;&gt;&gt;</strong> instead. </p>
</li>
<li><p>In the std::pair, <strong>the first one indicates the destination vertex and the second indicates the path length (or cost).</strong></p>
</li>
<li><p>Type of the elements in the multiList:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(multiList) == vector&lt;vector&lt;std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt;&gt; <span class="comment"># this full multiList</span></span><br><span class="line"><span class="built_in">type</span>(multiList[<span class="number">0</span>]) == vector&lt;std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt; <span class="comment"># this is all edges starting from a certain vertex</span></span><br><span class="line"><span class="built_in">type</span>(multiList[<span class="number">0</span>][<span class="number">0</span>]) == std::pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; <span class="comment"># this is the single edge</span></span><br><span class="line">pair.first <span class="comment"># this is edge&#x27;s destination</span></span><br><span class="line">pair.second <span class="comment"># this is edge&#x27;s path length</span></span><br></pre></td></tr></table></figure></li>
<li><p>We implemented two types of graph, undirected graph and directed graph.</p>
<ul>
<li>They differs quite little in this implementation. A undirected graph, in this case, is a specialization of the directed graph.</li>
</ul>
</li>
<li><p>An API <strong>insertEdge()</strong> is implemented for edge insertion.</p>
</li>
</ul>
<h3 id="Check-Connection"><a href="#Check-Connection" class="headerlink" title="Check Connection:"></a>Check Connection:</h3><p>Before we start to find the second shortest path, we have to firstly check if there’s a possible path from <strong>vertex 1 to vertex m.</strong> We implemented this by Breadth-First-Search.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//keep a queue to store the vertices to be visited</span><br><span class="line">queue&lt;vertexNum&gt; adjVertices</span><br><span class="line">//keep a array to represent each vertices is visted or not</span><br><span class="line">visited&lt;bool&gt; isVisited</span><br><span class="line"></span><br><span class="line">enqueue the first vertex</span><br><span class="line"></span><br><span class="line">while(queue is not empty)</span><br><span class="line">    currentNode = dequeue()</span><br><span class="line">    if(currentNode is visited) </span><br><span class="line">    	continue;</span><br><span class="line">    mark the currentNode as visited;</span><br><span class="line">    enqueue the adjacent nodes of currentNode;</span><br></pre></td></tr></table></figure>

<p>After above process, we check if vertex m has been visited, if not, means there’s no possible path from vertex 1 to vertex m, abort.</p>
<blockquote>
<p>If vertex m has been visited, means there’s at least one path from vertex 1 to vertex m.</p>
<p>In this case, ShortestPath from 1 to m must exist.</p>
</blockquote>
<h3 id="Second-Shortest-Path"><a href="#Second-Shortest-Path" class="headerlink" title="Second Shortest Path:"></a>Second Shortest Path:</h3><p>In the Dijkstra’s algorithm, we find the shortest path by steps below:</p>
<ul>
<li><p>We keep an table, keeps track of each vertex’s <strong>shortest Path Length from Start</strong> and its direct predecessor of in shortest path.</p>
<ul>
<li><p>Each vertex is initialized as cost to infinity and predecessor to -1 as “Unmarked”</p>
</li>
<li><p>Each time visit the <strong>Unvisited Vertex Which Has The <mark>Shortest</mark> Path Length from Start</strong></p>
</li>
<li><p>Compute its neighbors’ cumulative Path Length, </p>
<pre><code>check if it’s shorter than the table’s records
if it&#39;s shorter, update table with the **path length and predecessor**
</code></pre>
</li>
<li><p>After compute, Mark the Vertex as visited.</p>
</li>
</ul>
</li>
<li><p>Dijkstra’s algorithm is an Greedy Algorithm, using local minimum to get global minimum.</p>
<ul>
<li>It’s possible to only record the direct predecessor of each vertex and be able to get the path from the table.<ul>
<li>The shortest path from vertex 1 to m is the global minimum, and each edge along this path is also the global minimum from vertex 1 to that vertex.</li>
</ul>
</li>
<li>An table may look like this</li>
</ul>
<img src="https://i.loli.net/2021/11/20/V2U9aNBSbvxOqH5.png" alt="image-20211120011014800" style="zoom: 33%;" /></li>
</ul>
<blockquote>
<p>Note that each step we have to find the <strong>Unvisited Vertex Which Has The <mark>Shortest</mark> Path Length from Start</strong>, If we do linear scan, the time complexity would be O(V^2). But if we keep a min heap, the time complexity would be O((V+E)log(E)).</p>
</blockquote>
<h3 id="Make-Some-Extension"><a href="#Make-Some-Extension" class="headerlink" title="Make Some Extension"></a>Make Some Extension</h3><p>To find the second shortest path, we simply keep another table, record the second shortest path from vertex 1 to vertex i. And we have to keep track of all of its predecessors <strong>(in implementation, a string)</strong>, instead of a single direct predecessor, since a second shortest path isn’t necessarily made up by multiple second shortest sub-paths.</p>
<p>We made some modification in the update part of the Dijkstra’s algorithm.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for v in adj(u):</span><br><span class="line">    if shortest[u] + cost(u, v) &lt; shortest[v]:</span><br><span class="line">        second_shortest[v] = shortest[v]</span><br><span class="line">        shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line">    else if shortest[u] + cost(u, v) &lt; sec_shortest[v] and shortest[u]+cost(u,v)!=shortest[v]: //in case there are multiple shortest paths.</span><br><span class="line">            second_shortest[v] = shortest[u] + cost(u, v)</span><br></pre></td></tr></table></figure>

<p>Also, to allow backtracking, each node can be pushed on to min heap multiple times. But for the second shortest path, <strong>the node in such path can appear at most twice.</strong> </p>
<blockquote>
<p> This is obvious, if a path 1-&gt;3-&gt;1-&gt;2-&gt;1-&gt;4 contains a node appears more than twice  (1 appears 3 times), there must exist 2 shorter paths where vertex <strong>1 appear 1 and 2 times</strong> and reach 4, and thus it’s not a second shortest path.</p>
</blockquote>
<p>The overall pseudocode looks like below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minHeap.push(vertex1)</span><br><span class="line"></span><br><span class="line">//break the loop if the heap is empty or the second shortest path has been calculated</span><br><span class="line">while(minHeap!=empty and second_shortest[vertexLast].cost == infinity)</span><br><span class="line">&#123;</span><br><span class="line">for v in adj(u):</span><br><span class="line">	if(v has been visited twice)</span><br><span class="line">		continue;</span><br><span class="line">    if shortest[u] + cost(u, v) &lt; shortest[v]:</span><br><span class="line">        second_shortest[v] = shortest[v]</span><br><span class="line">        shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line">    else if shortest[u] + cost(u, v) &lt; sec_shortest[v] and shortest[u]+cost(u,v)!=shortest[v]: //in case there are multiple shortest paths.</span><br><span class="line">            second_shortest[v] = shortest[u] + cost(u, v)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>If the second_shortest[vertexLast].cost=infinity, means there’s no second shortest path from vertex 1 to last vertex.</strong> In this case, we output the shortest path. A shortest path is ensured since we’ve done the BFS in advance.</p>
<h2 id="Chapter-3-Testing-Results"><a href="#Chapter-3-Testing-Results" class="headerlink" title="Chapter 3: Testing Results"></a>Chapter 3: Testing Results</h2><h4 id="Case-1-Sample-Case"><a href="#Case-1-Sample-Case" class="headerlink" title="Case 1: Sample Case"></a>Case 1: Sample Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">150</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">130</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">70</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct"><a href="#Result-Correct" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/6bxgvMzEqNriWGX.png" alt="image-20211120014336249" style="zoom:67%;" />

<h4 id="Case-2-An-Undirectional-Graph"><a href="#Case-2-An-Undirectional-Graph" class="headerlink" title="Case 2: An Undirectional Graph"></a>Case 2: An Undirectional Graph</h4><img src="/Users/naoyuki/Library/Application%20Support/typora-user-images/image-20211120014537752.png" alt="image-20211120014537752" style="zoom: 50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">7</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-1"><a href="#Result-Correct-1" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/pXcBYEsFmk8xKGl.png" alt="image-20211120014515770" style="zoom:67%;" />



<h4 id="Case-3-Two-shortest-paths-exists-second-shortest-path-requires-backtracking"><a href="#Case-3-Two-shortest-paths-exists-second-shortest-path-requires-backtracking" class="headerlink" title="Case 3: Two shortest paths exists, second shortest path requires backtracking"></a>Case 3: Two shortest paths exists, second shortest path requires backtracking</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-2"><a href="#Result-Correct-2" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/DefKAg2FdGR3LZo.png" alt="image-20211120014753271" style="zoom:67%;" />



<h4 id="Case-4-No-second-shortest-path-but-exist-two-shortest-path-of-same-length"><a href="#Case-4-No-second-shortest-path-but-exist-two-shortest-path-of-same-length" class="headerlink" title="Case 4: No second shortest path, but exist two shortest path of same length."></a>Case 4: No second shortest path, but exist two shortest path of same length.</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-3"><a href="#Result-Correct-3" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/PusOXbo5avM1pzN.png" alt="image-20211120014957572" style="zoom:67%;" />



<h4 id="Case-5-No-valid-path-from-1-to-m"><a href="#Case-5-No-valid-path-from-1-to-m" class="headerlink" title="Case 5: No valid path from 1 to m"></a>Case 5: No valid path from 1 to m</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-4"><a href="#Result-Correct-4" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><p><img src="https://i.loli.net/2021/11/20/EncuRtsxgbwQ3dL.png" alt="image-20211120015142150"></p>
<h4 id="Case-6-Minimum-Case"><a href="#Case-6-Minimum-Case" class="headerlink" title="Case 6: Minimum Case"></a>Case 6: Minimum Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Minimum case, 2 vertices and 1 edge (since self loop is not allowed)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Result-Correct-5"><a href="#Result-Correct-5" class="headerlink" title="Result: Correct"></a>Result: Correct</h4><img src="https://i.loli.net/2021/11/20/elAFNhX43WD8HJV.png" alt="image-20211120132214734" style="zoom:67%;" />



<h4 id="Case-7-Maximum-Case"><a href="#Case-7-Maximum-Case" class="headerlink" title="Case 7: Maximum Case"></a>Case 7: Maximum Case</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Get input from largestCase.in</span></span><br><span class="line"><span class="comment">Use macro __FILE__INPUT__</span></span><br><span class="line"><span class="comment">m=1000,n=5000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/11/20/BOb8Rk12uQCMTKg.png" alt="image-20211120015529523"  />



<blockquote>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ul>
<li>The result seems acceptable so far, need some complex test cases for validation.</li>
</ul>
</blockquote>
<h2 id="Chapter-4-Analysis-and-Comments"><a href="#Chapter-4-Analysis-and-Comments" class="headerlink" title="Chapter 4:    Analysis and Comments"></a>Chapter 4:    Analysis and Comments</h2><ul>
<li>M = number of Vertices</li>
<li>N = number of Edges</li>
</ul>
<h3 id="1-Build-Graph"><a href="#1-Build-Graph" class="headerlink" title="1.Build Graph:"></a>1.Build Graph:</h3><p>We keep an multiList by inserting all edges into the vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;</p>
<ul>
<li>Each insertion takes $O(1)$, the overall time complexity would be $O(N)$</li>
</ul>
<h4 id="Overall-Time-Complexity-O-N"><a href="#Overall-Time-Complexity-O-N" class="headerlink" title="Overall Time Complexity: $O(N)$"></a>Overall Time Complexity: $O(N)$</h4><p>We keep an multiList, each element is consist of destination and cost, which is $O(1)$</p>
<p> the overall time complexity would be $O(N)$</p>
<h4 id="Overall-Space-Complexity-O-N"><a href="#Overall-Space-Complexity-O-N" class="headerlink" title="Overall Space Complexity: $O(N)$"></a>Overall Space Complexity: $O(N)$</h4><blockquote>
<p>For Undirectional Graph, the only difference is that the insertion time and space taken by undirectional graph is twice as the directional one. But both are O(N) after all.</p>
</blockquote>
<h3 id="2-Check-Connection"><a href="#2-Check-Connection" class="headerlink" title="2.Check Connection:"></a>2.Check Connection:</h3><ol>
<li>In this step each edge is visited at most once, each node is visited at most once.</li>
<li>The enqueue and dequeue takes $O(1)$ time.</li>
</ol>
<p> the overall time complexity would be $O(N)$</p>
<h4 id="Overall-Time-Complexity-O-M-N"><a href="#Overall-Time-Complexity-O-M-N" class="headerlink" title="Overall Time Complexity: $O(M+N)$"></a>Overall Time Complexity: $O(M+N)$</h4><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity :"></a>Space Complexity :</h4><p>A queue of $O(N)$ (at most contains all edges) is needed in this step.</p>
<h4 id="Overall-Space-Complexity-O-N-1"><a href="#Overall-Space-Complexity-O-N-1" class="headerlink" title="Overall Space Complexity: $O(N)$"></a>Overall Space Complexity: $O(N)$</h4><h3 id="3-Second-Shortest-Path"><a href="#3-Second-Shortest-Path" class="headerlink" title="3.Second Shortest Path"></a>3.Second Shortest Path</h3><ul>
<li><p>We push each node to min heap at most twice (2M)</p>
<ul>
<li><p>Each time a edge is popped</p>
<ul>
<li>We update table, which takes $O(1)$ time</li>
</ul>
</li>
<li><p>Each pop or push takes $O(log(M))$ time</p>
</li>
</ul>
</li>
</ul>
<h4 id="Overall-Time-Complexity-O-Mlog-M"><a href="#Overall-Time-Complexity-O-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(Mlog(M))$"></a>Overall Time Complexity: $O(Mlog(M))$</h4><ul>
<li><p>We keep two tables, each tables takes M elements, each elements contains a string (contains all predecessors, at most length O(N)) and a int (cumulative cost).</p>
<ul>
<li>Two tables occupies $O(2M*N)$ Space.</li>
</ul>
</li>
<li><p>We also keeps an heap of max size $O(N)$, each node occupies $O(1)$ Space.</p>
</li>
</ul>
<h4 id="Overall-Space-Complexity-O-M-N"><a href="#Overall-Space-Complexity-O-M-N" class="headerlink" title="Overall Space Complexity:  $O(M*N)$"></a>Overall Space Complexity:  $O(M*N)$</h4><h3 id="OVERALL"><a href="#OVERALL" class="headerlink" title="OVERALL:"></a>OVERALL:</h3><h4 id="Overall-Time-Complexity-O-N-Mlog-M"><a href="#Overall-Time-Complexity-O-N-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(N+Mlog(M))$"></a>Overall Time Complexity: $O(N+Mlog(M))$</h4><h4 id="Overall-Space-Complexity-O-M-N-1"><a href="#Overall-Space-Complexity-O-M-N-1" class="headerlink" title="Overall Space Complexity:  $O(M*N)$"></a>Overall Space Complexity:  $O(M*N)$</h4><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments:"></a>Comments:</h3><blockquote>
<p>In the actual implementation of the constraint “each node is visited at most twice”, we use a slightly different approach based on the cumulative length, but they should have the same effect.</p>
<p>Although no hacking cases founded now, if things go wrong in some cases, the logic there needs a rewrite to be more accurate.</p>
</blockquote>
<h3 id="Extra-K-Shortest-Path"><a href="#Extra-K-Shortest-Path" class="headerlink" title="Extra: K-Shortest Path"></a>Extra: K-Shortest Path</h3><p>If we extend the same technique to  the K shortest path, we have to keep K table, which takes up $O(K<em>M</em>N)$ Space.</p>
<p>Each node can be pushed to heap at most K times, Which takes overall $O(N + K<em>M</em>log (M))$ time.</p>
<h4 id="Overall-Time-Complexity-O-N-K-Mlog-M"><a href="#Overall-Time-Complexity-O-N-K-Mlog-M" class="headerlink" title="Overall Time Complexity: $O(N+K*Mlog(M))$"></a>Overall Time Complexity: $O(N+K*Mlog(M))$</h4><h4 id="Overall-Space-Complexity-O-KMN"><a href="#Overall-Space-Complexity-O-KMN" class="headerlink" title="Overall Space Complexity:  $$O(KMN)$$"></a>Overall Space Complexity:  $$O(K<em>M</em>N)$$</h4><h2 id="Appendix-Source-Code-in-C-11"><a href="#Appendix-Source-Code-in-C-11" class="headerlink" title="Appendix:    Source Code (in C++11)"></a>Appendix:    Source Code (in C++11)</h2><h4 id="Djikstra-hpp"><a href="#Djikstra-hpp" class="headerlink" title="Djikstra.hpp"></a>Djikstra.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">anscestors are numbered from 0~n-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    string ancestors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">heap node is numbered from 1~n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string ancestors;</span><br><span class="line">    <span class="keyword">int</span> src;</span><br><span class="line">    <span class="keyword">int</span> dst;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HeapNode</span>(string&amp;&amp; ancestors, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> cost)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ancestors = ancestors;</span><br><span class="line">        <span class="keyword">this</span>-&gt;src = src;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dst = dst;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Order minHeap by cost</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> HeapNode &amp;a, <span class="keyword">const</span> HeapNode &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Allowing for both digraph and undirectional graphs.</span></span><br><span class="line"><span class="comment">finding the second shortest path using extended dijkstra algorithm</span></span><br><span class="line"><span class="comment">graph: the graph to be searched</span></span><br><span class="line"><span class="comment">verbose: print out result, by default set to true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(T &amp;graph, <span class="keyword">bool</span> verbose = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type check</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">bool</span> isGraph = std::is_same&lt;T, UGraph&gt;::value || std::is_same&lt;T, DiGraph&gt;::value;</span><br><span class="line">    <span class="keyword">if</span> (!isGraph)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Input is not compatible graph&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    initialize the table,</span></span><br><span class="line"><span class="comment">    with the total path cost to inifinity,</span></span><br><span class="line"><span class="comment">    parent to - 1 as null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   record the shortest path cost</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function">vector&lt;CostTable&gt; <span class="title">costTable</span><span class="params">(graph.getVertexNum(), &#123;INT32_MAX, &#123;<span class="string">&quot;-1&quot;</span>&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   record the second shortest path cost</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function">vector&lt;CostTable&gt; <span class="title">secondCostTable</span><span class="params">(graph.getVertexNum(), &#123;INT32_MAX, &#123;<span class="string">&quot;-1&quot;</span>&#125;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize priority_queue as minHeap. STL implementation by default is maxHeap</span></span><br><span class="line">    priority_queue&lt;HeapNode, vector&lt;HeapNode&gt;, compare&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set starting point</span></span><br><span class="line">    costTable[<span class="number">0</span>].ancestors = <span class="string">&quot;-2&quot;</span>;</span><br><span class="line">    costTable[<span class="number">0</span>].cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    priority_queue doesn&#x27;t offer a iterator</span></span><br><span class="line"><span class="comment">    each node contains source, destination and cumulative cost</span></span><br><span class="line"><span class="comment">    order by cumulative cost</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//push the adjacent nodes of the starting node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph.multiList[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmpNode = <span class="built_in">HeapNode</span>(<span class="string">&quot;1 &quot;</span> + <span class="built_in">to_string</span>(edge.first + <span class="number">1</span>), <span class="number">1</span>, edge.first + <span class="number">1</span>, edge.second);</span><br><span class="line">        minHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while the second shortest path of the given vertex is not determined</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>() &amp;&amp; secondCostTable.<span class="built_in">back</span>().cost == INT32_MAX)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> node = minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalCost = node.cost;</span><br><span class="line">        <span class="keyword">int</span> srcIndex = node.src;</span><br><span class="line">        <span class="keyword">int</span> destIndex = node.dst;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the current node&#x27;s total cost is less than the cost in shortest table</span></span><br><span class="line"><span class="comment">    update the shortest path, and the second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (totalCost &lt; costTable[destIndex - <span class="number">1</span>].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].cost = costTable[destIndex - <span class="number">1</span>].cost;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].ancestors = costTable[destIndex - <span class="number">1</span>].ancestors;</span><br><span class="line">            costTable[destIndex - <span class="number">1</span>].cost = totalCost;</span><br><span class="line">            costTable[destIndex - <span class="number">1</span>].ancestors = node.ancestors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the current node&#x27;s total cost is larger than the shortest</span></span><br><span class="line"><span class="comment">    and less than the cost in second shortest </span></span><br><span class="line"><span class="comment">    update the second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (totalCost &lt; secondCostTable[destIndex - <span class="number">1</span>].cost &amp;&amp; totalCost != costTable[destIndex - <span class="number">1</span>].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].cost = totalCost;</span><br><span class="line">            secondCostTable[destIndex - <span class="number">1</span>].ancestors = node.ancestors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//to find the 2nd shortest path</span></span><br><span class="line">            <span class="comment">// there&#x27;s no need to push the child of 3rd or 4th shortest path to heap</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    push the adjacent nodes, we don&#x27;t check if the node is visited or not</span></span><br><span class="line"><span class="comment">    since we allow backtracking</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph.multiList[destIndex - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            each node is ensured to be visited twice at most</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (secondCostTable[edge.first].cost &lt; totalCost + edge.second)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//push the node to the priority queue</span></span><br><span class="line">            <span class="keyword">auto</span> tmpNode = <span class="built_in">HeapNode</span>(node.ancestors + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(edge.first + <span class="number">1</span>), destIndex, edge.first + <span class="number">1</span>, totalCost + edge.second);</span><br><span class="line">            minHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the ancestors is &quot;-1&quot;, means the second cost table of the last vertex</span></span><br><span class="line"><span class="comment">    haven&#x27;t been visited yet, Which means there&#x27;s no second shortest path, but at least one path</span></span><br><span class="line"><span class="comment">    from start to end is ensured through previous checkConnection().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (secondCostTable.<span class="built_in">back</span>().ancestors == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Doesn&#x27;t exist second shortest path.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;But, the shortest path is&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost = costTable.<span class="built_in">back</span>().cost;</span><br><span class="line">        <span class="keyword">auto</span> path = costTable.<span class="built_in">back</span>().ancestors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cost: &quot;</span> &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">            cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return the second shortest path with given cost table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The second shortest path is&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost = secondCostTable.<span class="built_in">back</span>().cost;</span><br><span class="line">    <span class="keyword">auto</span> path = secondCostTable.<span class="built_in">back</span>().ancestors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cost: &quot;</span> &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Path: &quot;</span>;</span><br><span class="line">        cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Graph-hpp"><a href="#Graph-hpp" class="headerlink" title="Graph.hpp"></a>Graph.hpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Base Class</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//multiList Representation, using vector</span></span><br><span class="line">    <span class="comment">//each element contains destination and cost</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; multiList;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize</span></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> vertexNum, <span class="keyword">int</span> edgeNum)</span><br><span class="line">    &#123;</span><br><span class="line">        vNum = vertexNum;</span><br><span class="line">        eNum = edgeNum;</span><br><span class="line">        multiList.<span class="built_in">resize</span>(vertexNum);</span><br><span class="line">        inDegree.<span class="built_in">resize</span>(vertexNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get number of vertices</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get number of vertices</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    insert an edge from src to dst</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check if the graph contains a certain edge, using lambda expression</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_if</span>(multiList[src].<span class="built_in">begin</span>(), multiList[src].<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;elem)</span><br><span class="line">                    &#123; <span class="keyword">return</span> elem.first == dst; &#125;) != multiList[src].<span class="built_in">end</span>())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; multiList.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; multiList[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; multiList[i][j].first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; multiList[i][j].second &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">    <span class="comment">//number of edges and vertices</span></span><br><span class="line">    <span class="keyword">int</span> vNum;</span><br><span class="line">    <span class="keyword">int</span> eNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a class for undirectional graphs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UGraph</span> :</span> <span class="keyword">public</span> Graph</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UGraph</span>(<span class="keyword">int</span> vNum, <span class="keyword">int</span> eNum) : <span class="built_in">Graph</span>(vNum, eNum)&#123;&#125;;</span><br><span class="line">    <span class="comment">//insert an edge from src to dst</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// minus one, make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update parameters</span></span><br><span class="line">        multiList[src].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dst, cost));</span><br><span class="line">        multiList[dst].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(src, cost));</span><br><span class="line">        inDegree[dst]++;</span><br><span class="line">        inDegree[src]++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a class for Directional graphs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span> :</span> <span class="keyword">public</span> Graph</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DiGraph</span>(<span class="keyword">int</span> vNum, <span class="keyword">int</span> eNum) : <span class="built_in">Graph</span>(vNum, eNum)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert an edge from src to dst</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> srcVertex, <span class="keyword">int</span> dstVertex, <span class="keyword">int</span> cost)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// minus one, make it easier to index</span></span><br><span class="line">        <span class="keyword">int</span> src = srcVertex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dst = dstVertex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update parameters</span></span><br><span class="line">        multiList[src].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dst, cost));</span><br><span class="line">        inDegree[dst]++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS algorithm to check if there&#x27;s a path from the first node to the last node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkConnection</span><span class="params">(T &amp;graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type check</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">bool</span> isGraph = std::is_same&lt;T, UGraph&gt;::value || std::is_same&lt;T, DiGraph&gt;::value;</span><br><span class="line">    <span class="keyword">if</span> (!isGraph)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Input is not compatible graph&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isVisited</span><span class="params">(graph.getVertexNum(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    push in the first node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    each round:</span></span><br><span class="line"><span class="comment">    1.currentNode = dequeue(), if(currentNode is visited) continue;</span></span><br><span class="line"><span class="comment">    2.mark the currentNode as visited.</span></span><br><span class="line"><span class="comment">    3.enqueue the adjacent nodes of currentNode</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> currentNode;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        currentNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isVisited[currentNode])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        isVisited[currentNode] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;adjNode : graph.multiList[currentNode])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(adjNode.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if there&#x27;s no path from the first node to the last node</span></span><br><span class="line"><span class="comment">    means there&#x27;s no possible second shortest path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!isVisited[graph.<span class="built_in">getVertexNum</span>() - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: No Path to Destination&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lab3-cpp"><a href="#lab3-cpp" class="headerlink" title="lab3.cpp"></a>lab3.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Dijkstra.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="comment">// #define __SAMPLE__CASE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CASE__2__</span></span><br><span class="line"><span class="comment">// #define __USER__INPUT__</span></span><br><span class="line"><span class="comment">// #define __FILE__INPUT__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THREADING__</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">change your loopTime here</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> loop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SAMPLE__CASE__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">150</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">130</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">70</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">40</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a bidirectional (undirected graph) case</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__1__</span></span><br><span class="line">    <span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">7</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">there exist two shortest path between 1-3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__2__</span></span><br><span class="line">    <span class="function">UGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Only one shortest path between 1 and 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__3__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Vertex 4 is isolated, no valid path</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__4__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Minimum case, 2 vertices and 1 edge (since self loop is not allowed)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__5__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DiGraph with cycle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CASE__6__</span></span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">insertEdge</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __FILE__INPUT__</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a large input case</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;largestCase.in&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vNum, eNum;</span><br><span class="line">    inputFile &gt;&gt; vNum &gt;&gt; eNum;</span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(vNum, eNum)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src, dst, cost;</span><br><span class="line">    <span class="keyword">while</span> (eNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inputFile &gt;&gt; src &gt;&gt; dst &gt;&gt; cost;</span><br><span class="line">        graph.<span class="built_in">insertEdge</span>(src, dst, cost);</span><br><span class="line">        eNum--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get input from user, by default directional graph</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USER__INPUT__</span></span><br><span class="line">    <span class="keyword">int</span> vNum, eNum;</span><br><span class="line">    cin &gt;&gt; vNum &gt;&gt; eNum;</span><br><span class="line">    <span class="function">DiGraph <span class="title">graph</span><span class="params">(vNum, eNum)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src, dst, cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">getEdgeNum</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; src &gt;&gt; dst &gt;&gt; cost;</span><br><span class="line">        graph.<span class="built_in">insertEdge</span>(src, dst, cost);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;</span><br><span class="line">    start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop::loopTime; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//using async function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __THREADING__</span></span><br><span class="line">        std::future&lt;<span class="keyword">bool</span>&gt; fp = <span class="built_in">async</span>(</span><br><span class="line">            launch::async, checkConnection&lt;<span class="keyword">decltype</span>(graph)&gt;,</span><br><span class="line">            std::<span class="built_in">ref</span>(graph));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THREADING__</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkConnection</span>(graph))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>(graph, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __THREADING__</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isConnected = fp.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (!isConnected)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;e)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: threading failed:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>&gt; duration;</span><br><span class="line">    end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="comment">//print time it takes</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program Completed in: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    test code for graph functionality</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; graph.containsEdge(1, 2) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// graph.print();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Portfolio Site</title>
    <url>/2022/01/16/Portfolio%20Site%20Online/</url>
    <content><![CDATA[<p>Recently I began my Master application for 2022 Fall, and some of the universities, require the applicants to submit their portfolio in the form of personal website. I was intended to submit this site, however, this site only contains daily logs and technical topic posts. So I would rather create another website for my portfolio works.</p>
<p>After one afternoon’s work, new Portfolio Website was online, powering by Wix. Actually I found the Wix tool quite easy to use, only drags and drops are needed, just like what they’ve shown in the Youtube ads. The problem is, it’s not suitable for me to contantly update the contents since it tooks a lot more to render a single site in Wix. You have to drag and drop each paragraph yourself. However, it’s pretty easy to publish a post in Hexo. I can just use Typora and markdown to upload a post in seconds. Also, Wix doesn’t have good support for code snippets as the Markdown does. So I‘m just gonna post most of my daily thoughts and progresses here. And major works on the portfolio site.</p>
<p>I actually want to merge these two sites, this site and the portfolio site, into one. However, I find the two sites’ styles are quite different and I’m not interested in writing pieces of CSS code anyway. Maybe I will merge them someday.</p>
<p>Finally, if you are interested in my portfolio, check  <a href = "https://zhaonzh.wixsite.com/mysite-1">Portfolio Site</a>.</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>About Me</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender 3.1 Alpha Render Test on M1 Max</title>
    <url>/2021/12/11/Blender%203.1%20Render%20Test/</url>
    <content><![CDATA[<h2 id="All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P"><a href="#All-Scenes-are-rendered-using-cycles-using-GPU-Compute-1080P" class="headerlink" title="All Scenes are rendered using cycles using GPU Compute 1080P"></a>All Scenes are rendered using cycles using GPU Compute 1080P</h2><h3 id="1-Classroom-300-Samplings"><a href="#1-Classroom-300-Samplings" class="headerlink" title="1.Classroom 300 Samplings"></a>1.Classroom 300 Samplings</h3><ul>
<li><p>Result: 1min 47.32s = 107.32s </p>
</li>
<li><p>Boost compared to CPU: 8*60/107.32 = 4.47x</p>
</li>
<li><p>Roughly equivalent to CUDA 3060Ti @Blender 2.9x </p>
</li>
<li><p>Roughtly equivalent to Optix 2080 @Blender 2.8x and Optix 3060 @Blender 2.9x</p>
</li>
<li><p>According to Rob Williams@<a href="https://techgage.com/article/blender-3-0-gpu-performance/">https://techgage.com/article/blender-3-0-gpu-performance/</a>, the performance of M1 Max is half of the 3060 with Optix 3060 @Blender 3.00. If we assume there is a performance boost of 2 times in Cycles from 2.9x to 3.00, a rough equivalent will be 2060 Max-Q (206s Optix 2.93).</p>
<p><img src="https://s2.loli.net/2022/01/01/WiZIz8rKlXEcOYM.png" alt="image-20220101235753865"></p>
</li>
</ul>
<h3 id="2-BMW27-GPU-Compute-1225-Samplings"><a href="#2-BMW27-GPU-Compute-1225-Samplings" class="headerlink" title="2.BMW27 (GPU Compute) 1225 Samplings"></a>2.BMW27 (GPU Compute) 1225 Samplings</h3><ul>
<li>Result: 43.59s</li>
<li>Boost Compared to CPU: 210/43.59 = 4.82x</li>
<li>Roughly equivalent to CUDA 3060~3060Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2060 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/wZ35lDaBkiJ7mWQ.png" alt="image-20211219164344829" style="zoom:50%;" /></li>
</ul>
<h3 id="3-Barcelona-Pavilion-1000-Samplings"><a href="#3-Barcelona-Pavilion-1000-Samplings" class="headerlink" title="3.Barcelona Pavilion 1000 Samplings"></a>3.Barcelona Pavilion 1000 Samplings</h3><ul>
<li>Result: 176.51s</li>
<li>Boost Compared to CPU: 640/176.51 = 3.62x</li>
<li>Roughly equivalent to CUDA 3070~3070Ti @Blender 2.9x </li>
<li>Roughtly equivalent to Optix 2070 @Blender 2.8x and Optix 3050Ti @Blender 2.9x</li>
<li><img src="https://s2.loli.net/2022/01/01/oBTbOQra1Dp8nZd.png" alt="image-20211219171113341" style="zoom:33%;" /></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
      <tags>
        <tag>Redering</tag>
        <tag>Blender</tag>
      </tags>
  </entry>
  <entry>
    <title>折叠表达式(Fold Expression)，低速下脚现代C++ Chapter 2 Exercise</title>
    <url>/2021/10/15/%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F(Fold%20Expression)%EF%BC%9A%E4%BD%8E%E9%80%9F%E4%B8%8B%E8%84%9A%E7%8E%B0%E4%BB%A3C++%20Chapter%202%20Exercise/</url>
    <content><![CDATA[<h3 id="折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise"><a href="#折叠表达式（Fold-Expression）：低速下脚现代C-Chapter-2-Exercise" class="headerlink" title="折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise"></a>折叠表达式（Fold Expression）：低速下脚现代C++ Chapter 2 Exercise</h3><p>最近在看高速上手现代C++，这是一本很不错的书，作者用仅80余页的长度介绍了C++自C++11以来至C++20带来的许多特性。这些特性给C++带来了语言可用性上的强化，运行期的强化 etc. 以及使得这门语言本身更好地支持例如函数式编程的范式。</p>
<p>每一章的结尾作者都会提供一些简单的小题目，其中第二章的小题目cover了折叠表达式(Fold Expression, since C++17)和结构化绑定（Structured Binding, since C++17）。在自己闲着摸索的时候发现了一个有意思的小事情，于是稍微写点东西记录一下。</p>
<blockquote>
<p>感觉光看这本书和课后的题的话，内容还是不太能掌握，可能跟着其他博客看一看会比较好。</p>
</blockquote>
<h3 id="为什么需要Fold-Expression"><a href="#为什么需要Fold-Expression" class="headerlink" title="为什么需要Fold Expression?"></a>为什么需要Fold Expression?</h3><p>模版是C++比较重要的一个板块之一，但是C++11之前，模版的参数数量是固定的。自从C++11之后，新引入的表示方法允许声明时引入任意数量的参数，即如下形式:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br></pre></td></tr></table></figure>

<p>有了可变长模版，我们就可以写一个允许任意长度参数的函数模版了。一个显而易见的好处是，我们可用这样的语法实现以下函数功能，并且只要写一个函数模版。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个函数模版 mean_val，接受任意长度的参数，返回平均值</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// return 2</span></span><br><span class="line"><span class="built_in">mean_val</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// return 3.5</span></span><br></pre></td></tr></table></figure>

<p>不过在C++17之前，这样的函数模版在解包(unpack)的时候会比较麻烦，因为我们在写函数模版的时候并不知道究竟会传几个参数进来，而参数包又不像是std::vector之类的容器有简单的方式进行遍历，因此我们对于函数参数的实际操作就变得比较麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如说我想实现max_val，但是我并没有直观的方式遍历args的内容</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//我该怎么获得args的内容呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过目前来说，我们可以通过sizeof… 来计算参数的个数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;std::endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// cout:3</span></span><br></pre></td></tr></table></figure>

<h4 id="一个比较常见的做法是利用递归来进行参数解包"><a href="#一个比较常见的做法是利用递归来进行参数解包" class="headerlink" title="一个比较常见的做法是利用递归来进行参数解包:"></a>一个比较常见的做法是利用递归来进行参数解包:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//书中的案例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt; <span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;<span class="comment">//每次取出一个T，然后递归再取出一个T</span></span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>); <span class="comment">//输出所有参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的确比较繁琐，而C++17中引入了一种比较简洁的方式来实现这种功能需求，这就是标题里的折叠表达式。</p>
<ul>
<li>考虑下面的代码，下面的函数模版可以实现任意长度立即数的求和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> <span class="comment">//C++14，函数返回值自动推断</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> (t + ...); <span class="comment">//折叠表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过书中没有仔细讲这个折叠表达式的内容，因此原理上就有些不清晰，这里做一些补充。</p>
<h3 id="折叠表达式的语法："><a href="#折叠表达式的语法：" class="headerlink" title="折叠表达式的语法："></a>折叠表达式的语法：</h3><ul>
<li><code>pack op ...</code> (一元右折叠 / unary right fold)</li>
<li><code>... op pack</code> (一元左折叠 / unary right fold)</li>
<li><code>pack op ... op init</code> (二元右折叠 / binary right fold)</li>
<li><code>init op ... op pack</code> (二元左折叠 / binary left fold)</li>
</ul>
<p>其中，<code>pack</code>是参数包，即上述代码中的t，op即operator，支持32种二元运算符，例如<code>+,-,*,/</code> , <code>init</code>表示最后一层展开时二元运算符的另一个操作数。 其中在二元折叠中两个operator要保持一致。</p>
<h3 id="以上四个表达式和以下内容等价："><a href="#以上四个表达式和以下内容等价：" class="headerlink" title="以上四个表达式和以下内容等价："></a>以上四个表达式和以下内容等价：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(args op ...) &lt;-&gt; (arg1 op (arg2 op (arg3 op (... op (arg_n-1 op arg_n)))))</span><br><span class="line">(... op args) &lt;-&gt; (((arg1 op arg2) op ...) op arg_n)</span><br><span class="line">(args op ... op init) &lt;-&gt; (arg1 op (... op (arg_n−1 op (arg_n op init))))</span><br><span class="line">(init args op ... op ) &lt;-&gt; ((((init op arg1) op arg2) op ...) op arg_n)</span><br></pre></td></tr></table></figure>

<p>这么写可能还是有点晕，举两个例子可能更好:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">(args - ...) &lt;-&gt; (<span class="number">1</span> - (<span class="number">2</span> - <span class="number">3</span>))</span><br><span class="line">(<span class="number">3</span> - ... - args) &lt;-&gt; (((<span class="number">3</span><span class="number">-1</span>)<span class="number">-2</span>)<span class="number">-3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a></p>
</blockquote>
<p>下面是一个注意点，由于运算符优先级问题，第一种备注是掉的写法并不被接受，需要写成第二种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  return (args + ... + 1 * 2);   // Error: operator with precedence below cast</span></span><br><span class="line">    <span class="keyword">return</span> (args + ... + (<span class="number">1</span> * <span class="number">2</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作业题："><a href="#作业题：" class="headerlink" title="作业题："></a>作业题：</h3><p>利用折叠表达式写一个计算求均值的函数模版:</p>
<p>答案如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mean</span><span class="params">(T... t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mean</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure>

<h3 id="但是…"><a href="#但是…" class="headerlink" title="但是…"></a>但是…</h3><p>不知道为什么我突然想试着把 <code>+</code> 改成 <code>-</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t - ...)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; (<span class="number">1</span>-(<span class="number">2</span>-(<span class="number">3</span>-(<span class="number">4</span><span class="number">-5</span>)))) = (<span class="keyword">int</span>)<span class="number">3</span>/<span class="number">5</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个例子倒是没有问题，如果我改成左折叠:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">return</span> (... - t) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//output: 3689348814741910320</span></span><br></pre></td></tr></table></figure>

<p>这个一长串数字并不是随机数，运行了好几次都是同一个结果。但是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(... - t)/<span class="keyword">sizeof</span>...(t) &lt;-&gt; ((((<span class="number">1</span><span class="number">-2</span>)<span class="number">-3</span>)<span class="number">-4</span>)<span class="number">-5</span>)/<span class="number">5</span> = <span class="number">-13</span>/<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>本应该输出-2才对，那么究竟是哪里出问题了呢？</p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>首先我查看了折叠表达式和<code>sizeof…(t)</code>的返回值，用lldb调试后发现数值没有问题，那么应该是除法这一步出了问题。</p>
<p><img src="https://s2.loli.net/2022/01/01/v2aCilBbDmuOLEj.png" alt="image-20220101230639043"></p>
<p>当我将p的类型从auto改为int之后，返回值就变成-2了：</p>
<p><img src="https://s2.loli.net/2022/01/01/16UWplfXmMLCNTv.png" alt="image-20220101230834880"></p>
<p>那么看来应该是<code>sizeof…</code>返回值的问题。</p>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>询问学长之后发现，<code>sizeof...</code>返回的是一个<code>size_t</code>类型的值，在64-bit操作系统中类型是<code>uint64_t</code>，即64位无符号整型。然后折叠表达式自动推断返回为int（<code>int32_t</code>), 二者做除法的时候int被提升到<code>uint64_t</code>，然后又因为负数的符号位在最高位，被转换成unsigned的时候，数值就变得非常大了。</p>
<p>可以具体算一下这个<code>3689348814741910320</code>的由来，结果是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-13 = (hex) FFFFFFFFFFFFFFF3 -&gt; 18,446,744,073,709,551,603</span><br><span class="line">int(18,446,744,073,709,551,603 / 5) = 3689348814741910320</span><br></pre></td></tr></table></figure>

<p>所以需要注意的是，一行的表达式，其实包含了一次类型推断和一次隐式类型转换，所以使用的时候需要比较小心一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(t + ...) / <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="comment">//equivalent as below</span></span><br><span class="line"><span class="keyword">auto</span> p = (t + ...);</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="keyword">sizeof</span>...(t);</span><br><span class="line"><span class="keyword">return</span> p/i;</span><br></pre></td></tr></table></figure>

<p>等我看完Chapter 4的时候可能会再来写一点内容，感觉还是得一边看一边跟着例子写一点才好。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>382. Linked List Random Node</title>
    <url>/2021/11/16/382.%20Linked%20List%20Random%20Node/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>Implement the <code>Solution</code> class:</p>
<ul>
<li><code>Solution(ListNode head)</code> Initializes the object with the integer array nums.</li>
<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg" alt="getrand-linked-list"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 3, 2, 2, 3]</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li>The number of nodes in the linked list will be in the range <code>[1, 104]</code>.</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
<li>At most <code>10^4</code> calls will be made to <code>getRandom</code>.</li>
</ul>
<blockquote>
<p>Since at most 10k calls will be made, the overall time complexity of each random call is expected to be bounded by O(nlogn).</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><p>A simple approach would be converting the linked list into an array, and then random generate a number and random access the array. This would cost extra <code>O(n)</code> space for keeping an array, and <code>O(1)</code> to random access the array.</p>
<blockquote>
<p>Actually, another implementation is that, we could traverse the list to get the length, and then random generate a number, and then take O(n) step to get the number.</p>
<p>This implementation would take O(1) extra space, and O(n) for traversing and accessing.</p>
</blockquote>
<h3 id="What-if…-just-visit-each-node-only-once-and-use-O-1-space"><a href="#What-if…-just-visit-each-node-only-once-and-use-O-1-space" class="headerlink" title="What if… just visit each node only once and use O(1) space?"></a>What if… just visit each node only once and use O(1) space?</h3><blockquote>
<p>The key is, Each node must have the <strong>same probability</strong> of being chosen.</p>
<p>So to ensure the same probability, it is not necessary to use the built-in random function.</p>
</blockquote>
<h3 id="Introducing-Reservoir-Sampling"><a href="#Introducing-Reservoir-Sampling" class="headerlink" title="Introducing Reservoir Sampling:"></a>Introducing Reservoir Sampling:</h3><p>I found a video on YouTube, explaining this idea in an interesting and great way.</p>
<ul>
<li><h4 id="Scenario-A-man-picking-a-hat"><a href="#Scenario-A-man-picking-a-hat" class="headerlink" title="Scenario: A man picking a hat"></a>Scenario: A man picking a hat</h4><ul>
<li><h4 id="each-round-replace-the-old-hat-or-wear-new-hat"><a href="#each-round-replace-the-old-hat-or-wear-new-hat" class="headerlink" title="each round replace the old hat or wear new hat"></a>each round replace the old hat or wear new hat</h4></li>
<li><p>Each round probability of wearing new hat: 1/n</p>
</li>
<li><p>The first hat has a chance of 1/1, so he 100% wear the hat</p>
</li>
<li><p>The second hat has a chance of 1/2, so he 50% wear the 2nd hat, 50% keep the first hat</p>
</li>
<li><p>The third hat has a chance of 1/3, 1/3 wear the 3nd hat, 2/3 keep the original hat</p>
</li>
<li><p>So on and so forth…</p>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/01/08/F9ehzSj1Ovrx6Tq.png" alt="image-20220108005314005" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/01/08/OA8nIcDtopjaB7x.png" alt="image-20220108005616966" style="zoom:50%;" />

<h3 id="The-Good-Side"><a href="#The-Good-Side" class="headerlink" title="The Good Side:"></a>The Good Side:</h3><p>Reservoir sampling doesn’t need to know the length of the list in advance, it’s an online random algorithm.</p>
<h3 id="Proof-on-Equal-Probability"><a href="#Proof-on-Equal-Probability" class="headerlink" title="Proof on Equal Probability:"></a>Proof on Equal Probability:</h3><p>The $i_{th}$ hat has a probability of $\frac{1}{i}$ of being chosen in its round. The probability of  $i_{th}$ hat being chosen after $n$ times can be given as:</p>
<img src="https://s2.loli.net/2022/01/08/XFk2Rr3On7gaKpM.png" alt="image-20220108005314005" style="zoom: 100%;" />

<p>Which is the multiplication of $i_{th}$ hat being chosen, and all the hats after $i_{th}$ hat not being chosen.</p>
<p>And this RHS equals to $\frac{1}n$, which means every hat has the same probability of being chosen.</p>
<ul>
<li>Link: <a href="https://www.youtube.com/watch?v=A1iwzSew5QY">https://www.youtube.com/watch?v=A1iwzSew5QY</a></li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h3><p>Now let’s implement the Reservoir Sampling into our code, note that we still have to simulate the process of spinning the wheel, using the random function to implement. And it’s generally slower to perform floating point division, use integer instead.</p>
<ul>
<li>Instead of <code>1/i</code>, we have <code>1,2,3…i</code>, but only the <code>1</code> means being chosen</li>
<li><code>i</code> start from <code>1</code>, because it’s not valid to divide by 0.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reservoir sampling</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> ListNode *head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// we are not allowed to modify the head pointer itself</span></span><br><span class="line">        <span class="comment">// each round we create a new node to do the trick</span></span><br><span class="line">        <span class="keyword">auto</span> node = head;</span><br><span class="line">        <span class="keyword">int</span> res = head-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// random generate 1~i, only 1 means being selected</span></span><br><span class="line">            <span class="comment">// i should start from 1, or there would be divide by 0 issue</span></span><br><span class="line">            <span class="keyword">bool</span> replace = (<span class="built_in">rand</span>() % (i - <span class="number">1</span> + <span class="number">1</span>)) + <span class="number">1</span> == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (replace)</span><br><span class="line">                res = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1463. Cherry Pickup II</title>
    <url>/2022/01/08/1463.%20Cherry%20Pickup%20II/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>You are given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries where <code>grid[i][j]</code> represents the number of cherries that you can collect from the <code>(i, j)</code> cell.</p>
<p>You have two robots that can collect cherries for you:</p>
<ul>
<li><strong>Robot #1</strong> is located at the <strong>top-left corner</strong> <code>(0, 0)</code>, and</li>
<li><strong>Robot #2</strong> is located at the <strong>top-right corner</strong> <code>(0, cols - 1)</code>.</li>
</ul>
<p>Return <em>the maximum number of cherries collection using both robots by following the rules below</em>:</p>
<ul>
<li>From a cell <code>(i, j)</code>, robots can move to cell <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code>.</li>
<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.</li>
<li>When both robots stay in the same cell, only one takes the cherries.</li>
<li>Both robots cannot move outside of the grid at any moment.</li>
<li>Both robots should reach the bottom row in <code>grid</code>.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png" alt="sample_1_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.</span><br><span class="line">Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.</span><br><span class="line">Total of cherries: 12 + 12 = 24.</span><br></pre></td></tr></table></figure>



<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p><img src="https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png" alt="sample_2_1802"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.</span><br><span class="line">Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.</span><br><span class="line">Total of cherries: 17 + 11 = 28.</span><br></pre></td></tr></table></figure>



<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a><strong>Constraints:</strong></h3><ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<blockquote>
<p>We have a maximum input size of 70*70 = 4900, a loose limit would be $O((mn)^2)$.</p>
</blockquote>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition:"></a>Intuition:</h3><ul>
<li>Each round, each robot would go exactly one step down. And they will always move forward until reaching the end.<ul>
<li>In this way, we can describe the status of two robots by a 3-element tuple <code>(y,x1,x2)</code>. Since <code>#y: row #x: col</code>, there are $O(r*c^2)$ combinations</li>
</ul>
</li>
<li><code>dp[y][x1][x2]</code> means the maximum cherries collected at this combination</li>
<li>Base Case: <code>y&gt;=r, x&lt;0 or x&gt;c</code> (out of bounary), return 0</li>
<li><strong>Transition Equation:</strong> <code>dp[y+1][x1][x2] =&#123;max[y][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0&#125;</code></li>
<li>Time Complexity: $O(r<em>c^2</em>9)$</li>
<li>Space Complexity: $O(r*c^2)$</li>
<li><strong>To get the answer:</strong> find the maximum value in <code>dp[r-1][x1][x2]</code> (traverse)</li>
</ul>
<h3 id="A-Reverse-Solution"><a href="#A-Reverse-Solution" class="headerlink" title="A Reverse Solution:"></a>A Reverse Solution:</h3><p>Robots start at any grid in the last level, and then they go up until one goes to the left corner, the other go to the right corner.</p>
<ul>
<li><p><strong>Transition Equation:</strong> <code>dp[y][x1][x2] =&#123;max[y+1][x1&#39;][x2&#39;] + grid[y][x1]+grid[y][x2] if x1!=x2 else 0</code>}</p>
</li>
<li><p><strong>To get the answer</strong>: <code>dp[0][0][c-1]</code></p>
</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> triArr = vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">triArr <span class="title">dp</span><span class="params">(r, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(c, vector&lt;<span class="keyword">int</span>&gt;(c, <span class="number">-1</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(<span class="number">0</span>, <span class="number">0</span>, c - <span class="number">1</span>, grid, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// used for recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, triArr &amp;dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; <span class="number">0</span> || x1 &gt;= c || x2 &lt; <span class="number">0</span> || x2 &gt;= c || y &gt;= r || y &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[y][x1][x2];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//if visited return</span></span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSame = x1 == x2;</span><br><span class="line">        <span class="keyword">int</span> cur = grid[y][x1] + (isSame ? <span class="number">0</span> : grid[y][x2]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d1 = <span class="number">-1</span>; d1 &lt;= <span class="number">1</span>; d1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">-1</span>; d2 &lt;= <span class="number">1</span>; d2++)</span><br><span class="line">            &#123; <span class="comment">// each round find the max one from 9 combinations</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur + <span class="built_in">helper</span>(y + <span class="number">1</span>, x1 + d1, x2 + d2, grid, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//update the answer</span></span><br><span class="line">        dp[y][x1][x2] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>Dynamic Programming</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>1345. Jump Game IV</title>
    <url>/2022/01/15/1345.%20Jump%20Game%20IV/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of integers <code>arr</code>, you are initially positioned at the first index of the array.</p>
<p>In one step you can jump from index <code>i</code> to index:</p>
<ul>
<li><code>i + 1</code> where: <code>i + 1 &lt; arr.length</code>.</li>
<li><code>i - 1</code> where: <code>i - 1 &gt;= 0</code>.</li>
<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>
</ul>
<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>
<p>Notice that you can not jump outside of the array at any time.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You do not need to jump.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: arr = [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>
<li><code>-10^8 &lt;= arr[i] &lt;= 10^8</code></li>
</ul>
<blockquote>
<p>The length of the array is up to 10^4, the algorithm is expected to be bounded by ==O(nlogn)==</p>
</blockquote>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force:"></a>Brute Force:</h3><p>Each round, you can jump front or back one step, or jump to the place with the same value.</p>
<ul>
<li>Traverse all possibilities that start from index 0, with <code>#step = 0</code>, <code>minStep = INT_MAX</code><ul>
<li>Each time, try out 3 possibilities, <code>#step++</code><ul>
<li>When reaching the end, update the <code>minStep = min(minStep,#step)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>It’s obvious that this method has a factorial time complexity. We can make a little modification, that is, each place can only be visited at most once, or it can’t be the <code>minimum number of steps</code>.</p>
</blockquote>
<h3 id="An-Graph-like-Intuition"><a href="#An-Graph-like-Intuition" class="headerlink" title="An Graph-like Intuition:"></a>An Graph-like Intuition:</h3><ul>
<li><p>Each place is a node on the graph, nodes are sequentially linked according to their order in the array.</p>
</li>
<li><p>If there are nodes with the same value, link them with an edge.</p>
</li>
<li><p>Since we can move forward and backward at each place, the graph is a undirected graph.</p>
</li>
<li><p>Use BFS for solution (Use queue)</p>
</li>
</ul>
<blockquote>
<p>In actual implementation, a graph is not necessary, we can just keep. a hash map, where key is the value, value is the position of these values.</p>
</blockquote>
<h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity:"></a>Complexity:</h3><p>Vertices = N, Edges at max, all nodes have same value, $O(N^2)$, at min, 0.</p>
<ul>
<li><p>Time Complexity: O(V+E)</p>
</li>
<li><p>Space Complexity: O(V+E) (Use Graph), O(V) (Not using extra graph)</p>
</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h3><p>In the implementation, our time complexity depends on the number of edges. In cases of the same value, there could be edges at $O(N^2)$. (All nodes have the same value), which is obviously gonna give us a TLE.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In the BFS Step, after we enqueue nodes with the same value, we can clear the entry in the hash map.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//same value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//core step, this will get us away from redundant search</span></span><br><span class="line">    <span class="comment">//this step ensures nodes of the same value won&#x27;t get enqueued overly</span></span><br><span class="line">    <span class="comment">//actually, enqueue nodes of the same value once is enough</span></span><br><span class="line">    <span class="comment">//so we clear out the entry </span></span><br><span class="line">    sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;value,position&gt;</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; sameValueSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sameValueSet[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shortestPath</span><span class="params">(arr.size(), INT32_MAX)</span></span>;</span><br><span class="line">        shortestPath[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : sameValueSet[arr[<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [src, dest] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            shortestPath[dest] = <span class="built_in">min</span>(shortestPath[dest], shortestPath[src] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dest == arr.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> shortestPath[dest];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;newDest : sameValueSet[arr[dest]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (shortestPath[newDest] == INT32_MAX)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, newDest));</span><br><span class="line">            &#125;</span><br><span class="line">            sameValueSet[arr[dest]].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest &gt; <span class="number">0</span> &amp;&amp; shortestPath[dest - <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (dest &lt; (arr.<span class="built_in">size</span>() - <span class="number">1</span>) &amp;&amp; shortestPath[dest + <span class="number">1</span>] == INT32_MAX)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dest, dest + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortestPath[arr.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">100</span>, <span class="number">-23</span>, <span class="number">-23</span>, <span class="number">404</span>, <span class="number">100</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">404</span>&#125;;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">minJumps</span>(arr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>DataStructure</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
</search>
